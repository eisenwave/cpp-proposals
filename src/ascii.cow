\cowel_include{libwg21.cow}\
\
\cowel_macro(charset){\tt{\hl(string){[\cowel_put]}}}\
\cowel_macro(ctype){\exposid{character-type}}\

\wg21_head(
  title = ASCII character utilities
){
\dl{
  \dt{Document number:} \dd{\ref(https://wg21.link/P3688){P3688R6}}
  \dt{Date:}            \dd{\tt{2026-02-21}}
  \dt{Audience:}        \dd{LEWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-To:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{Co-Authors:}      \dd{Corentin Jabot <\mail{corentin.jabot@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3688/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/ascii.cow)}
}
\hr
}

\Babstract{
The utilities in \header{cctype} or \header{locale}
are locale-specific,
not \tcode{constexpr},
and provide no support for Unicode character types.
We propose lightweight, locale-independent alternatives.
}

\h2(listed=false){Contents}

\make_contents

\h2{Revision history}

\h3{Changes since R5}

\ul{
  \li{Expand design discussion in \ref(#case-insensitive-comparison)}
  \li{Replace a stray use of \tcode{is_ascii} with \tcode{ascii_is}}
  \li{Remove mention of \tcode{u32string_view} in wording for \tcode{ascii_is_punctuation}}
  \li{Revise the definition of \q{ASCII-compatible} once more}
  \li{Rebase wording on \ref(N5032)}
}

\h3{Changes since R4}

\Bnote{
Since R4, the paper was seen during two SG16 telecons in Q4 2025.
The changes below incorporate the feedback given during these telecons.
}

\ul{
  \li{
    Rename \tt{is_ascii_*} functions to \tt{ascii_is_*}
    to increase consensus in SG16
  }
  \li{Add \ref(#naming)}
  \li{
    Change the \ref(#design) of multiple overloads to a single function template
    for all functions
  }
  \li{
    In \ref(#case-insensitive-comparison), elaborate why mixing different character types
    is not supported
  }
  \li{Replace incorrect \q{\tcode{"C"} locale} with \q{C locale} in \ref(#introduction)}
  \li{Fix an \q{\tcode{asci}} typo}
  \li{Remove stray default argument for \tcode{ascii_is_digit} in \header{ascii} synopsis}
  \li{Rename \tcode{is_ascii_printable} to \tcode{ascii_is_printing} to match C terminology}
  \li{Rename \tcode{is_ascii_graphical} to \tcode{ascii_is_graphic} to match C terminology}
  \li{
    Rename \tcode{is_ascii_alpha} to \tcode{ascii_is_alphabetic} to avoid
    inconsistency with \tcode{ascii_is_alphanumeric} (which is entirely unabbreviated)
  }
  \li{Properly define \q{ASCII-compatible} in \ref(#wording)}
}

\h3{Changes since R3}

\ul{
  \li{Fix a bug in the \tcode{get_hex_digit_value} example in \ref(#is-ascii)}
  \li{Split \tcode{ascii_is_digit} (formerly know as \tcode{is_ascii_digit}) into two overloads}
  \li{Add design discussion in \ref(#namespace-ascii)}
}

\h3{Changes since R2}

\ul{
  \li{
    Expand \ref(#why-no-function-objects)
    based on feedback from BSI (British Standards Institution);
    no changes to design are made.
  }
  \li{Rebase \ref(#wording) on N5014.}
}

\h3{Changes since R1}

\ul{
  \li{
    In \ref(#wording), fix incorrect return type
    for \tcode{ascii_case_insensitive_compare} in synopsis.
  }
  \li{
    In \ref(#wording), fix superfluous \tcode{std::} prefix
    for \tcode{strong_ordering} in definition of \tcode{ascii_case_insensitive_compare}.
  }
}

\h3{Changes since R0}

\ul{
  \li{In \ref(#base-parameter), explain why the precondition is not hardened.}
  \li{In \ref(#wording), fix a missing addition to \eelis{tab:headers.cpp}.}
  \li{Minor editorial changes.}
}

\h2{Introduction}

Testing whether a character falls into a specific subset of ASCII characters
or performing some simple transformations are common tasks in text processing.
For example, applications may need to check if identifiers
are comprised of alphanumeric ASCII characters or underscores;
Unicode properties are not relevant to this task,
and usually, neither are locales.

Unfortunately, these common and simple tasks are only supported
through functions in the \header{cctype} and \header{locale} headers, such as:
\cppblock{
// <cctype>
int isalnum(int ch);
int isalpha(int ch);
// ...
int toupper(int ch);

// <locale>
template<class charT> bool isalnum(charT c, const locale& loc); 
}

Especially the \header{cctype} functions are ridden with problems:
\ol{
  \li{
    There is no support for Unicode character types
    (\tcode{char8_t}, \tcode{char16_t}, and \tcode{char32_t}).
  }
  \li{
    These functions are not \tcode{constexpr},
    but performing basic characters tests would be useful at compile time.
  }
  \li{
    There are distinct function names for \tcode{char} and \tcode{wchar_t}
    such as \tcode{std::isalnum} and \tcode{std::iswalnum},
    making generic programming more difficult.
  }
  \li{
    If \tcode{char} is signed,
    these functions can easily result in undefined behavior
    because the input must be representable as \tcode{unsigned char} or be \tcode{EOF}.
    If \tcode{char} represents a UTF-8 code unit,
    passing any non-ASCII code unit into these functions has undefined behavior.
  }
  \li{
    These functions violate the zero-overhead principle
    by also handling an \tcode{EOF} input,
    and in many use cases, \tcode{EOF} will never be passed into these functions anyway.
    The caller can easily deal with \tcode{EOF} themselves.
  }
  \li{
    The return type of character tests is \tcode{int},
    where a nonzero return value indicates that a test succeeded.
    This is very unnatural in C++, where \tcode{bool} is more idiomatic.
  }
  \li{
    Some functions use the currently installed C locale,
    which makes their use questionable for high-performance tasks
    because each invocation is typically an opaque call that checks the current locale.
  }
}

\strong{We propose lightweight replacement functions which address all these problems.}

\Bnote{
Many of these problems are resolved by the
\tcode{std::locale} overloads in \header{locale},
but their locale dependence makes them unfit for what this proposal aims to achieve.

Testing whether a \tcode{char8_t} (assumed to be a UTF-8 code unit)
is an ASCII digit is obviously a locale-independent task.
}

\h3{Can't you implement this trivially yourself?}

It is worth noting that some of the functions can be implemented very easily by the user.
For example, existing code may already use a check like \tcode{c >= '0' && c <= '9'}
to test for ASCII digits,
and our proposed \tcode{ascii_is_digit} does just that.

However, not all of the proposed functions are this simple.
For example, checking whether a \tcode{char} is an
ASCII punctuation character (\tcode{'#'}, \tcode{'?'}, etc.)
would require lots of separate checks done naively.
In the standard library, it can be efficiently implemented using a 128-bit or 256-bit bitset.

Even if all proposed functions were trivial to implement,
working with ASCII characters is such an overwhelmingly common use case
that it's worth supporting in the standard library.

\h2{Design}

All proposed functions are \tcode{constexpr},
locale-independent,
overloaded (i.e. no separate name for separate input types),
and accept any character type
(\tcode{char}, \tcode{wchar_t}, \tcode{char8_t}, \tcode{char16_t}, and \tcode{char32_t}).
Furthermore, all function names contain \tt{ascii}
to raise awareness for the fact that these functions do not handle Unicode characters.
A user would expect \tcode{is_upper(U'Ä')} to be \tcode{true},
but \tcode{ascii_is_upper(U'Ä')} to be \tcode{false}.

\Bex{
The counterpart to \tcode{std::isalpha} is declared follows:
\cppblock{
template<\ctype T>
  constexpr bool ascii_is_alphabetic(T c) noexcept;
}
}

\tcode{\ctype} is an exposition-only concept
that is modeled by any of the five character types\iref{basic.fundamental}.
There is nothing unusual noteworthy about this signature;
similar function templates (with an extra \tcode{const locale&} parameter)
can be found in \header{locale}.

\Bnote{
While previous revisions of this paper had several overloads instead of function templates,
there was little to no motivation for this.
\header{cmath} functions are arguably the only example in the C++ standard
where this design makes sense;
namely because it permits pulling in C header functions into \tcode{namespace std}
via \tcode{using}.

Furthermore, it is obvious that a function template requires less work to implement
for one-liner functions (such as many of the proposed functions),
compared to writing the same function five times.
That is, unless macros are used.
}

\h3{List of proposed functions}

\style{
  #fun-table {
    margin-left: auto;
    margin-right: auto;
    max-width: 95%;
    table-layout: auto;
  }
  #fun-table td:not(:last-child),
  #fun-table th {
    white-space: nowrap;
    vertical-align: top;
  }
  #fun-table td:last-child,
  #fun-table th:last-child {
    width: 100%;
    text-align: center;
  }
}

Find below a list of proposed functions.
Note that the character set notation \tt{[}...\tt{]} is taken from RegEx.

\table(id=fun-table){
\tr{
  \th{\header{cctype}}
  \th{Proposed name}
  \th{Returns (given ASCII \tcode{char c})}
}
\tr{
  \td{N/A}
  \td{\tcode{ascii_is_any}}
  \td{\tcode{c <= 0x7F}}
}
\tr{
  \td{\tcode{isdigit}}
  \td{\tcode{ascii_is_digit}}
  \td{\tcode{true} if \tcode{c} is in \charset{0-9}, otherwise \tcode{false}}
}
\tr{
  \td{N/A}
  \td{\tcode{ascii_is_bit}}
  \td{\tcode{c == '0' || c == '1'}}
}
\tr{
  \td{N/A}
  \td{\tcode{ascii_is_octal_digit}}
  \td{\tcode{true} if \tcode{c} is in \charset{0-7}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{isxdigit}}
  \td{\tcode{ascii_is_hex_digit}}
  \td{\tcode{true} if \tcode{c} is in \charset{0-9A-Fa-f}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{islower}}
  \td{\tcode{ascii_is_lower}}
  \td{\tcode{true} if \tcode{c} is in \charset{a-z}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{isupper}}
  \td{\tcode{ascii_is_upper}}
  \td{\tcode{true} if \tcode{c} is in \charset{A-Z}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{isalpha}}
  \td{\tcode{ascii_is_alphabetic}}
  \td{\tcode{ascii_is_lower(c) || ascii_is_upper(c)}}
}
\tr{
  \td{\tcode{isalnum}}
  \td{\tcode{ascii_is_alphanumeric}}
  \td{\tcode{ascii_is_alphabetic(c) || ascii_is_digit(c)}}
}
\tr{
  \td{\tcode{ispunct}}
  \td{\tcode{ascii_is_punctuation}}
  \td{\tcode{true} if \tcode{c} is in \charset{!"#\N{DOLLAR SIGN}\N{PERCENT SIGN}&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{|}~}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{isgraph}}
  \td{\tcode{ascii_is_graphic}}
  \td{\tcode{ascii_is_alphanumeric(c) || ascii_is_punctuation(c)}}
}
\tr{
  \td{\tcode{isprint}}
  \td{\tcode{ascii_is_printing}}
  \td{\tcode{ascii_is_graphic(c) || c == ' '}}
}
\tr{
  \td{\tcode{isblank}}
  \td{\tcode{ascii_is_horizontal_whitespace}}
  \td{\tcode{c == ' ' || c == '\\t'}}
}
\tr{
  \td{\tcode{isspace}}
  \td{\tcode{ascii_is_whitespace}}
  \td{\tcode{true} if \tcode{c} is in \charset{ \\f\\n\\r\\t\\v}, otherwise \tcode{false}}
}
\tr{
  \td{\tcode{iscntrl}}
  \td{\tcode{ascii_is_control}}
  \td{\tcode{(c >= 0 && c <= 0x1F) || c == '\\N{DELETE}'}}
}
\tr{
  \td{\tcode{tolower}}
  \td{\tcode{ascii_to_lower}}
  \td{the respective lower-case character if \tcode{ascii_is_upper(c)} is \tcode{true}, otherwise \tcode{c}}
}
\tr{
  \td{\tcode{toupper}}
  \td{\tcode{ascii_to_upper}}
  \td{the respective upper-case character if \tcode{ascii_is_lower(c)} is \tcode{true}, otherwise \tcode{c}}
}
\tr{
  \td{N/A}
  \td{\tcode{ascii_case_insensitive_compare}}
  \td{\i{see \ref(#case-insensitive-comparison)}}
}
\tr{
  \td{N/A}
  \td{\tcode{ascii_case_insensitive_equals}}
  \td{\i{see \ref(#case-insensitive-comparison)}}
}
}

\Bdecision{
The proposed names are mostly unabbreviated
to fit the rest of the standard library style.
Shorter names such as \tcode{ascii_is_alphanum} or \tcode{ascii_is_alnum}
could also be used.
}

\Bdecision{
\tcode{isgraph} should perhaps have no new version.
It is of questionable use,
and both the old and new name aren't obvious.
In the default \tcode{"C"} locale,
\tcode{isgraph} is simply \tcode{isprint} without \tcode{' '}.

Similarly, \tcode{isblank} should perhaps have no new version either.
This proposal simply has a new version for every \header{cctype} function;
if need be, they are easy to remove.
}

\h3(id=is-ascii){\tcode{ascii_is_any}}

This additional function is mainly useful for checking if a character "is ASCII",
i.e. falls into the basic latin block,
before performing an ASCII-only evaluation.

\Bex{
In the following overload set, the \tcode{char32_t} implementation delegates
to the \tcode{char8_t} implementation to avoid repetition of its logic.
The \tcode{std::ascii_is_any(c)} check is needed because
because an unconditional \tcode{get_hex_digit_value(char8_t(c))}
may result in treating U+0130 LATIN CAPITAL LETTER I WITH DOT ABOVE as U+0030 DIGIT ZERO.
\cppblock{
int get_hex_digit_value(char8_t c) {
    return c >= u8'0' && c <= u8'9' ? c - u8'0'
         : c >= u8'A' && c <= u8'F' ? c - u8'A' + 10
         : c >= u8'a' && c <= u8'f' ? c - u8'a' + 10
         : -1;
}

int get_hex_digit_value(char32_t c) {
    return std::ascii_is_any(c) ? get_hex_digit_value(char8_t(c)) : -1;
}
}
}

\h3(id=base-parameter){\tcode{base} parameter in \tcode{ascii_is_digit}}

Similar to \tcode{std::to_chars},
\tcode{std::ascii_is_digit} can also take a \tcode{base} parameter.
There are two overloads:

\cppblock{
template<\ctype T>
  constexpr bool ascii_is_digit(T c, int base) /* not noexcept */;
template<\ctype T>
  constexpr bool ascii_is_digit(T c) noexcept;
}

If \tcode{base} ≤ \tcode{10},
the range of valid ASCII digit character is simply limited.
For greater \tcode{base}, a subset of alphabetic characters is also accepted,
starting with \tcode{'a'} or \tcode{'A'}.
Such a function is useful when parsing numbers with a base of choice,
which is what \tcode{std::to_chars} does, for example.

Similar to \tcode{std::from_chars} and \tcode{std::to_chars},
the given \tcode{base} has to be between 2 and 36 (inclusive).
This is a non-hardened precondition because all functions in \header{ascii}
are low-level, high-performance, and spiritually numeric.
Hardened preconditions are not used within that context.

\Bnote{
The benefit of having two separate overloads is mainly
that the one without a \tcode{base} parameter can be made \tcode{noexcept}.
}

\h3(id=binary-and-octal-is-digit){\tcode{ascii_is_bit} and \tcode{ascii_is_octal_digit}}

C++ and various other programming languages support binary and octal literals,
so it seems like an arbitrary choice to only have dedicated overloads for (hexa)decimal digits.
\tcode{ascii_is_bit} may be especially useful,
such as when dealing with bit-strings like one of the \tcode{std::bitset} constructors.

In conclusion, we may as well have functions for bases 2, 8, 10, and 16;
they're not doing much harm, they're trivial to implement,
and some users may find them useful.

\Bnote{
None of the authors feel strongly about this,
so if LEWG insists,
we could remove \tcode{ascii_is_bit} and \tcode{ascii_is_octal_digit},
and even remove \tcode{ascii_is_hex_digit},
leaving only the multi-base \tcode{ascii_is_digit}.
}

\h3(id=case-insensitive-comparison){Case-insensitive comparison functions}

As shown in the table above,
we also propose the case-insensitive comparison functions.

\cppblock{
template<\ctype T>
constexpr strong_ordering ascii_case_insensitive_compare(
    T a,
    T b
) {
    return ascii_to_upper(a) <=> ascii_to_upper(b);
}

template<\ctype T>
constexpr strong_ordering ascii_case_insensitive_equals(
    T a,
    T b
) {
    return ascii_to_upper(a) == ascii_to_upper(b);
}
}

These functions deliberately have only one template type parameter.
Comparing code units of different encodings is typically meaningless,
and \tcode{ascii_to_upper} only has an effect if \tcode{ascii_is_lower} returns \tcode{true};
therefore, a comparison such as
\tcode{ascii_case_insensitive_equals(c, U'\\N{NO-BREAK SPACE}')}
could yield false positives for some UTF-8 code unit \tcode{c} with value \tcode{0xA0}.

Also note that the choice of \tcode{ascii_to_upper} over \tcode{ascii_to_lower} matters:
\cppblock{
// OK, passes because U'A' < U'^' is true, whereas U'a' < U'^' is false.
static_assert(ascii_case_insensitive_compare(U'a', U'^') < 0);
}
The choice of \tcode{ascii_to_upper} is arbitrary, and this is fine.
However, it may be worth pointing out that the ordering here is
radically different from the case-insensitive string ordering
using the DUCET (Default Unicode Collation Element Table),
which reorders the Basic Latin block almost entirely.
The use of \tcode{ascii_to_upper} deliberately produces different results than Unicode
comparisons because those would essentially involve a 128-character lookup table,
whereas \tcode{ascii_case_insensitive_compare} is easily SIMD-parallelizable
and requires no memory lookup.
Most users probably don't care whether \tcode{U'a'}
compares case-insensitively-less than \tcode{U'^'},
as long as they get a strict weak ordering and the implementation is fast and correct.
The (possibly non-existent) minority who cares
should either use the ICU or emulate the DUCET behavior using a lookup table.

\Bnote{
During the 2026-01-14 SG16 meeting,
concerns were raised about whether the proposal should include these functions;
the following poll was taken:

\Bquote{
\b{Poll 1: P3688R5: Remove the case-insensitive character comparison functions.}
\ul{
  \li{Attendees: 9}
  \li{\five_way_poll(1,0,3,4,1)}
  \li{Consensus against.}
}
}
}

\h3(id=why-no-function-objects){Why no function objects?}

For case-insensitive comparisons and for character tests in general,
function objects may be convenient because they can be more easily used in algorithms:

\cppblock{
std::string_view str = "abc123";
// This does not work if ascii_is_digit is an overloaded function or function template.
auto it = std::ranges::find(str, ascii_is_digit);
}

However, there is no reason why \tcode{ascii_is_digit} \em{needs} to be a function object.
It is not a customization point, but a simple utility,
and the established practice is to make these utilities free functions.

There are countless functions in the standard library that the user
may desire to put directly into an algorithm.
For example, a user may want to put \tcode{std::sqrt} or \tcode{std::abs}
in \tcode{ranges::transform},
or use them as a projection in an algorithm.
Cherry-picking the functions in \header{ascii} to be function objects
is far from solving the general problem;
in fact, encouraging direct use of \header{ascii} function objects in algorithms
could mislead the user into attempting the same with various non-addressable functions,
such as \tcode{std::abs}, making the program IFNDR.

This problem should be solved generally, such as:
\ul{
  \li{
    Overhauling the standard library to convert most functions into function objects.
  }
  \li{
    Standardizing a \tcode{LIFT} macro that wraps an overload set in a lambda,
    or some other means of wrapping,
    possibly as a core language feature
    similar to the one proposed in \ref(P3312R1) "Overload Set Types".
  }
}

Any solution to the general problem far exceeds the scope of this paper.
Perhaps one will emerge via C++26 reflection with further C++29 additions.

\h3(id=encoding){What to do for ASCII-incompatible \tcode{char} and \tcode{wchar_t}}

Not every ordinary and wide character encoding is ASCII-compatible,
such as EBCDIC, Shift JIS, and (defunct) ISO-646,
i.e. code units ≤ \tcode{0x7f} do not represent the same characters as ASCII.

This begs the question:
what should \tcode{ascii_is_digit('0')} do on an EBCDIC platform,
where this call is \tcode{ascii_is_digit(char(0xf0))} ?
We have three options, discussed below.

\Bnote{
\tcode{ascii_is_digit(u8'0')} is equivalent to \tcode{ascii_is_digit(char8_t(0x30))}
on any platform.
In general, the behavior for Unicode character types is obvious,
unlike that for \tcode{char} and \tcode{wchar_t}.
}

\h4{Conditionally supported \tcode{char} overloads}

We could mandate that the ordinary literal encoding is an ASCII superset
for the \tcode{char} overload to exist.
This would force a cast (to \tcode{char8_t}) to use the functions on EBCDIC platforms.
It is not clear how implementations would treat Shift JIS;
GCC assumes \tcode{'\\\\' == '¥'} to be \tcode{true}
(when linked against some \tt{iconv} implementations),
so this option may not be enough to alleviate
the awkwardness of \tcode{ascii_is_punctuation('¥')}.

Also, this option is not very useful.
It is reasonable to have UTF-8 data stored in a \tcode{char[]} on EBCDIC platforms,
and having to perform casts to \tcode{char8_t} would be awkward.

\h4{Transcode \tcode{char} to ASCII}

We could transcode from the ordinary literal encoding
to ASCII and produce an answer for the result of that transcoding.
This would be a greater burden for implementations,
especially on EBCDIC platforms.
The benefit is that \tcode{ascii_is_digit('0')} is always \tcode{true},
although \tcode{ascii_is_digit(char(0x30))} may not be.
However, \tcode{ascii_is_digit(char8_t(0x30))} is always \tcode{true}.

It probably does not solve the \tcode{ascii_is_punctuation('¥')} case,
as implementers may keep transcoding \tcode{'¥'} and \tcode{'\\\\'} in the same way.
It would also give incorrect answers for stateful encodings.
There are EBCDIC control characters that do not have an ASCII equivalent,
so if we were to do conversions, we would have to decide what,
for example, \tcode{ascii_is_control('\\u008B')} should produce.

\Bnote{
This option was originally preferred by one of the authors,
but proved to be \em{hugely} unpopular in discussion of the proposal.
}

\h4{Treat the input as ASCII, regardless of the literal encoding}

\b{This is our proposed behavior.}

The most simple option is to ignore literal encoding entirely,
and assume that \tcode{char} inputs are ASCII-encoded.
The greatest downside is that depending on encoding,
\tcode{ascii_is_digit('0')} may be \tcode{false},
which may be surprising to the user.
However, the main purpose of these functions is to be called with characters taken from ASCII text,
so what results they yield when passing literals is not so important.

There are use cases for this behavior on EBCDIC platforms.
A lot of protocols (HTTP, POP) and file formats (JSON, XML) are ASCII/UTF-8-based
and need to be supported on EBCDIC systems,
making these functions universally useful,
especially as \header{cctype} functions cannot easily be used to deal with ASCII on these platforms.

Ultimately, do we want functions to deal with ASCII or the literal encoding?
If we want them to be a general way to query the ordinary literal encoding,
\tt{ascii_is_*} is a terrible name,
and finding a more general name would prove difficult.

\Bnote{
If we choose this option,
we can still provide the same transcoding functionality as the previous option
by offering a (literal-encoded) \tcode{char} → (code point) \tcode{char32_t} function,
although that may be outside the scope of this proposal.
}

\h3{Naming}

\h4{Why to include \tt{ascii} in each name}

All proposed functions should have \tcode{ascii} somewhere in their name.
This emphasizes that rather than using the literal encoding or execution encoding,
these functions operate only on ASCII characters
(or Basic Latin code points, depending on how you think of it).

\tcode{ascii} also makes it obvious that no Unicode property tests are performed.
Names such as \tcode{std::is_digit} are worth reserving for more general tests.

\h4{\tt{ascii_is_*} vs. \tt{is_ascii_*}}

R4 and previous revisions of this paper used the naming scheme \tt{is_ascii_*}
rather than \tt{is_ascii_*} for character rests.
This was chosen because the name is more natural for English readers.
After discussion of R4 in SG16, the scheme was changed to use the \tt{ascii_} prefix
in all cases because:
\ul{
  \li{
    \tt{is_ascii_*} could be understood as asking:
    \q{Is this thing I have, whatever it is, considered an ASCII digit?}
    This is a problematic question when considering the
    \tcode{is_ascii_digit('0')} problem described in \ref(#encoding).
    The \tt{ascii_is_*} scheme more clearly signals that all functions
    assume a domain of ASCII, as an encoding assumption.
  }
  \li{
    The \tt{ascii_*} scheme can be applied consistently to all functions,
    including \tcode{ascii_case_insensitive_compare}.
  }
}

\h3{What if the input is a non-ASCII code unit?}

Text input is rarely guaranteed to be pure ASCII,
i.e. some code units may be > \tcode{0x7f}.
However, we're still interested in ASCII characters within that input.
For example, we may
\ul{
  \li{parse pure ASCII numbers like \code(json){123} in a UTF-8 JSON (or other config) file,}
  \li{trim ASCII whitespace in HTTP headers, which are encoded with ISO-8859-1,}
  \li{
    parse ASCII-alphanumeric variable names in Lua scripts,
    where non-ASCII characters can appear (comments, string),
  }
\li{...}
}

It is possible (and expected) that the user calls say,
\tcode{ascii_is_digit(U'ö')}, at least indirectly.
For the sake of convenience, all proposed functions should handle such inputs by
\ul{
  \li{returning \tcode{false} in the case of all testing functions, and}
  \li{applying an identity transformation in transformation/case-insensitive comparison functions.}
}

\Bex{
With these semantics, the user can safely write:
\cppblock{
std::u8string_view str = u8"öab 123";
// it is an iterator to '1' because 'ö' is skipped
auto it = std::ranges::find(str, [](char8_t c) { return std::ascii_is_digit(c); });
}
If \tcode{ascii_is_digit} doesn't simply return \tcode{false} on non-ASCII inputs,
the proposal is useless for the common use case where some non-ASCII characters exist in the input.
}

The proposed behavior also works excellently with any ASCII-compatible encoding, such as UTF-8.
Surrogate code units in UTF-8 are all greater than \tcode{0x7F},
so if we implement say, \tcode{ascii_is_digit} naively by checking
\tcode{c >= '0' && c <= '9'}, it "just works".

\h3(id=why-not-integers){Why not accept any integer type?}

Some people argue that a test like \tcode{ascii_is_digit('0')}
is a purely numerical test using the ASCII table,
and so passing \tcode{ascii_is_digit(0x30)} should also be valid.

However, this permissive interface would invite bugs.
For example, \tcode{c - '0'} is the difference between ASCII characters, not an ASCII character,
so passing it into \tcode{ascii_is_digit} would be nonsensical.
Static type systems exist for a reason:
to protect us from stupid mistakes.
While \tcode{char}, \tcode{char32_t} etc. are not required to be ASCII-encoded,
they are at least characters,
so passing them into our functions is likely something the user intended to do,
which we cannot say with confidence about \tcode{int}, \tcode{unsigned int}, etc.

Additionally, if we allowed passing signed integers,
we may want to make the behavior erroneous or undefined for negative inputs
because \tcode{ascii_is_digit(-1'000'000)} is most likely a developer mistake.
Our interface is very simple:
it has a wide contract and almost all functions are \tcode{noexcept}.
Let's keep it that way!

Lastly, even proponents of passing integer types would not want
\tcode{ascii_is_digit(true)} to be valid.

\h3{ASCII case-insensitive views and case transformation algorithms}

Ignoring or transforming ASCII case in algorithms is a fairly common problem.
Therefore, it may be useful to provide views such as \tcode{std::views::ascii_lower},
algorithms like \tcode{std::ranges::equal_ascii_case_insensitive}, etc.

\Bex{
HTML tag names are case-insensitive and comprised of ASCII characters,
like \code(html){<div>}, \code(html){<DIV>} etc.
To identify a \code(html){<div>} element, it would be nice if the user could write:
\cppblock{
std::ranges::equal(tag_name | std::views::ascii_lower, "div");
// or
std::ranges::ascii_case_insensitive_equal(tag_name, "div");
// or
tag_name.ascii_case_insensitive_equals("div");
}
}

While case transformations can be implemented naively using \tcode{std::transform},
dedicated functions would allow an efficient vectorized implementation for contiguous ranges,
which can be many times faster (\ref(AvoidCharByChar), \ref(AVX-512CaseConv))
Similarly, a case-insensitive comparison function can be vectorized.
In fact, POSIX's \tcode{strncasecmp} has been heavily optimized in glibc (\ref(AVX2strncasecmp)),
and providing range-based interfaces would allow delegating to these heavily optimized functions.

\b{We intend to propose such utilities in a future paper or revision of this paper.}
Currently, this proposal is focused exclusively on operations involving character types.

\h3(id=why-just-ascii){Why just ASCII?}

It may be tempting to generalize the proposed utilities beyond ASCII, e.g. to UTF-8.
However, this is not proposed for multiple reasons:
\ul{
  \li{
    You cannot pass \tcode{char8_t} into a UTF-8 \tcode{is_upper} function
    and expect meaningful results.
    In general, operations on variable-length encodings require sequences of code units.
    The interface we propose \em{only} makes sense for ASCII.
  }
  \li{
    Unicode utilities are tremendously more complex than ASCII utilities.
    Some Unicode case conversions even require multi-code-point changes.
  }
}

\h3{\tcode{namespace ascii}}

Instead of "pseudo-namespacing" the proposed functions by including \tcode{ascii} in the name,
it would also be possible to create a new \tcode{namespace ascii}
which houses all functions.
This would have the notable benefit of letting the user opt into shorter functions like:
\cppblock{
using std::ascii::is_lower;
is_lower('a');
}

However, we chose not to do this because it is unusual to create distinct namespace
for these small sets of utilities.
Furthermore, it may be desirable to have SIMD overloads of these utilities in the future.
This begs the question:
would it be \tcode{std::simd::ascii::is_lower} or \tcode{std::ascii::simd::is_lower}?
Would it be \tcode{std::views::ascii::lower} or \tcode{std::ascii::views::lower}?
The simpler option is to avoid namespaces.

\h2{Implementation experience}

A naive implementation of all proposed functions can be found at \ref(CompilerExplorer),
although these are implemented as function templates,
not as overload sets (as proposed).

A more advanced implementation of some functions can be found in \ref(µlight).
Character tests can be optimized using 128-bit or 256-bit bitsets.


\h2{Wording}

The wording changes are relative to \ref(N5032).

In \eelis{tab:headers.cpp}, add a new element to C++ library headers table:

\Bins{
\tt{<ascii>}
}

In subclause \eelis{version.syn},
update the synopsis as follows:

\Bdiff{\codeblock(cpp, borders=false){
\serif{\etc}
#define __cpp_lib_as_const                          201510L // freestanding, also in <utility>
\ins{#define __cpp_lib_ascii                             20XXXXL // freestanding, also in <ascii>}
#define __cpp_lib_associative_heterogeneous_erasure 202110L // also in \serif{\etc}
\serif{\etc}
}}

In Clause \eelis{text},
append a new subclause:

\style{
  ins-block .para::before {
    display: none;
  }

  .stable-ref {
    float: right;
  }
}

\Bins{
\h2(listed=false){ASCII utilities \stable_ref{ascii}}

¶
Subclause [ascii] describes components for dealing with characters
that are encoded using ASCII
or encodings that are \dfn{ASCII-compatible},
which are encodings where
\ul{
  \li{
    any code unit \math{\mi{c}}
    for which \tcode{ascii_is_any(\math{\mi{c}})} is \tcode{true}
    is valid and is the complete encoding of exactly one Unicode code point
    with the same numeric value as \math{\mi{c}}, and
  }
  \li{
    no other sequence of code units
    encodes a Unicode code point in the Basic Latin block.
  }
}
\example{ASCII, UTF-8, UTF-16, and UTF-32 are ASCII-compatible.
EBCDIC and Shift JIS are not ASCII-compatible.}

¶
\recommended
Implementations should emit a warning when a function in this subclause is invoked
using a value produced by a \grammarterm{string-literal}
or \grammarterm{character-literal} whose encoding is not ASCII-compatible.
\br\br
\example{
\tcode{ascii_is_digit('0')} is \tcode{false} if the
ordinary literal encoding\iref{lex.charset} is EBCDIC
or some other ASCII-incompatible encoding,
which can be surprising to the user.
However, \tcode{ascii_is_digit(char{0x30})}
is \tcode{true} regardless of the ordinary literal encoding.
}

\h3(listed=false){Header \tt{<ascii>} synopsis \stable_ref{ascii.syn}}

\codeblock(cpp, borders=false){
// \serif{all freestanding}
namespace std {
  // \serif{exposition-only helpers}
  template<class T>
    concept \ctype = same_as<T, char> || same_as<T, wchar_t>          // \serif{exposition only}
      || same_as<T, char8_t> || same_as<T, char16_t> || same_as<T, char32_t>;

  // \serif{[ascii.chars.test], ASCII character testing}
  template<\ctype T> constexpr bool ascii_is_any(T c) noexcept;

  template<\ctype T> constexpr bool ascii_is_digit(T c, int base);
  template<\ctype T> constexpr bool ascii_is_digit(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_bit(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_octal_digit(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_hex_digit(T c) noexcept;

  template<\ctype T> constexpr bool ascii_is_lower(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_upper(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_alphabetic(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_alphanumeric(T c) noexcept;

  template<\ctype T> constexpr bool ascii_is_punctuation(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_graphic(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_printing(T c) noexcept;

  template<\ctype T> constexpr bool ascii_is_horizontal_whitespace(T c) noexcept;
  template<\ctype T> constexpr bool ascii_is_whitespace(T c) noexcept;

  template<\ctype T> constexpr bool ascii_is_control(T c) noexcept;

  // \serif{[ascii.chars.transform], ASCII character transformation}
  template<\ctype T> constexpr T ascii_to_lower(T c) noexcept;
  template<\ctype T> constexpr T ascii_to_upper(T c) noexcept;

  // \serif{[ascii.chars.case.compare], ASCII case-insensitive character comparison}
  template<\ctype T>
    constexpr strong_ordering ascii_case_insensitive_compare(T a, T b) noexcept;
  template<\ctype T>
    constexpr bool ascii_case_insensitive_equals(T a, T b) noexcept;
}
}

\h3(listed=false){ASCII character testing \stable_ref{ascii.chars.test}}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_any(T c) noexcept;
}
\itemdescr{
\returns
\tcode{static_cast<char32_t>(c) <= 0x7F}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_digit(T c, int base);
}
\itemdescr{
\expects
\tcode{base} has a value between 2 and 36 (inclusive).

\p{
\returns
\codeblock(cpp, borders=false){\comment   (static_cast<char32_t>(c) >= U'0' && static_cast<char32_t>(c) < U'0' + min(base, 10))
|| (static_cast<char32_t>(c) >= U'a' && static_cast<char32_t>(c) < U'a' + max(base - 10, 0))
|| (static_cast<char32_t>(c) >= U'A' && static_cast<char32_t>(c) < U'A' + max(base - 10, 0))
}
}

\remarks
A function call expression that violates the precondition
in the \expects element
is not a core constant expression.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_digit(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_digit(c, 10)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_bit(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_digit(c, 2)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_octal_digit(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_digit(c, 8)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_hex_digit(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_digit(c, 16)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_lower(T c) noexcept;
}
\itemdescr{
\returns
\tcode{static_cast<char32_t>(c) >= U'a' && static_cast<char32_t>(c) <= U'z'}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_upper(T c) noexcept;
}
\itemdescr{
\returns
\tcode{static_cast<char32_t>(c) >= U'A' && static_cast<char32_t>(c) <= U'Z'}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_alphabetic(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_lower(c) || ascii_is_upper(c)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_alphanumeric(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_alphabetic(c) || ascii_is_digit(c)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_punctuation(T c) noexcept;
}
\itemdescr{
\p(style=text-align:left){
\returns
\tcode{true} if \tcode{static_cast<char32_t>(c)} equals one of
\tcode{U'!'},
\tcode{U'"'},
\tcode{U'#'},
\tcode{U'$'},
\tcode{U'%'},
\tcode{U'&'},
\tcode{U'\\''},
\tcode{U'('},
\tcode{U')'},
\tcode{U'*'},
\tcode{U'+'},
\tcode{U','},
\tcode{U'-'},
\tcode{U'.'},
\tcode{U'/'},
\tcode{U':'},
\tcode{U';'},
\tcode{U'<'},
\tcode{U'='},
\tcode{U'>'},
\tcode{U'?'},
\tcode{U'@'},
\tcode{U'['},
\tcode{U'\\\\'},
\tcode{U']'},
\tcode{U'^'},
\tcode{U'_'},
\tcode{U'`'},
\tcode{U'\{'},
\tcode{U'|'},
\tcode{U'\}'}, or
\tcode{U'~'},
otherwise \tcode{false}.
}
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_graphic(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_alphanumeric(c) || ascii_is_punctuation(c)}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_printing(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_graphic(c) || static_cast<char32_t>(c) == U' '}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_horizontal_whitespace(T c) noexcept;
}
\itemdescr{
\returns
\tcode{static_cast<char32_t>(c) == U' ' || static_cast<char32_t>(c) == U'\\t'}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_whitespace(T c) noexcept;
}
\itemdescr{
\returns
\tcode{u32string_view(U" \\f\\n\\r\\t\\v").contains(static_cast<char32_t>(c))}.
}

\itemdecl{
template<\ctype T> constexpr bool ascii_is_control(T c) noexcept;
}
\itemdescr{
\returns
\tcode{static_cast<char32_t>(c) <= 0x1F || static_cast<char32_t>(c) == U'\\N{DELETE}'}.
}

\h3(listed=false){ASCII character transformation \stable_ref{ascii.chars.transform}}

\itemdecl{
template<\ctype T> constexpr T ascii_to_lower(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_upper(c) ? static_cast<T>(static_cast<char32_t>(c) - U'A' + U'a') : c}.
}

\itemdecl{
template<\ctype T> constexpr T ascii_to_upper(T c) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_is_lower(c) ? static_cast<T>(static_cast<char32_t>(c) - U'a' + U'A') : c}.
}

\h3(listed=false){ASCII case-insensitive character comparison \stable_ref{ascii.chars.case.compare}}

\itemdecl{
template<\ctype T>
  constexpr strong_ordering ascii_case_insensitive_compare(T a, T b) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_to_upper(a) <=> ascii_to_upper(b)}.
}

\itemdecl{
template<\ctype T>
  constexpr bool ascii_case_insensitive_equals(T a, T b) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_to_upper(a) == ascii_to_upper(b)}.
}

}

\hr

\editnote{
The wording for \tcode{ascii_is_punctuation} was originally more compact by utilizing
\tcode{std::u32string_\cowel_to_html{\N{SOFT HYPHEN}}view(U"...").contains(c)},
but this approach was scrapped because it suggests a dependence between
\header{ascii} and \header{string_view} which does not exist.

The list of character literals is sorted by their integer values, ascending.
}

\editnote{
Some uses of \tcode{static_cast} are unnecessary to describe semantics.
For example, \tcode{static_cast<char32_t>(c) == U' '}
is equivalent to \tcode{c == U' '}.

However, these uses of \tcode{static_cast} may improve readability and avoid
the use of behavior which is proposed to be deprecated in \ref(P3695R0).
}

\h2{Acknowledgements}

Thanks to Joe Gottman for spotting a mistake in \tcode{get_hex_digit_value}.
Thanks to Hubert Tong for suggesting improvements to discussion and wording.

\h2{References}

\bib(
  id = N5032,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-12-15,
  author = Thomas Köppe,
  link = https://wg21.link/n5032,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5032.pdf,
)\
\bib(
  id = P3312R1,
  title = Overload Set Types,
  date = 2025-04-16,
  author = Bengt Gustafsson,
  link = https://wg21.link/p3312r1,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf,
)\
\bib(
  id = P3695R0,
  title = Deprecate implicit conversions between char8_t\, char16_t\, and char32_t,
  date = 2025-05-18,
  author = Jan Schultke,
  link = https://wg21.link/p3695r0,
  long-link = https://isocpp.org/files/papers/P3695R0.html,
)\
\bib(
  id = CompilerExplorer,
  title = Partial implementation of character utilities,
  author = Jan Schultke\, Corentin Jabot,
  link = https://godbolt.org/z/5nvWzdf8G,
)\
\bib(
  id = µlight,
  title = ascii_chars.hpp utilities in µlight,
  author = Jan Schultke,
  link = https://github.com/Eisenwave/ulight/blob/main/include/ulight/impl/ascii_chars.hpp,
)\
\bib(
  id = AVX2strncasecmp,
  title = glibc [PATCH v1 21/23] x86: Add AVX2 optimized str{n}casecmp,
  date = 2022-03-23,
  author = Noah Goldstein,
  link = https://sourceware.org/pipermail/libc-alpha/2022-March/137272.html,
)\
\bib(
  id = AvoidCharByChar,
  title = Avoid character-by-character processing when performance matters,
  date = 2020-07-21,
  author = Daniel Lemire,
  link = https://lemire.me/blog/2020/07/21/avoid-character-by-character-processing-when-performance-matters/,
)\
\bib(
  id = AVX-512CaseConv,
  title = Converting ASCII strings to lower case at crazy speeds with AVX-512,
  date = 2024-08-03,
  author = Daniel Lemire,
  link = https://lemire.me/blog/2024/08/03/converting-ascii-strings-to-lower-case-at-crazy-speeds-with-avx-512/,
)\

\make_bib
