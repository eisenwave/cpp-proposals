\cowel_include{libwg21.cow}

\wg21_head(
    title = Better shifting
){
\dl{
  \dt{Document number:} \dd{\docnum{D3793R1}}
  \dt{Date:}            \dd{\tt{2025-11-11}}
  \dt{Audience:}        \dd{SG6}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Brian Bi <\mail{bbi5291@gmail.com}>}
  \dt{Co-authors:}      \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3793/github)}
  \dt{Source:}          \dd{\ref(https://github.com/Eisenwave/cpp-proposals/blob/master/src/better-shifting.cow)}
}
\hr
}

\Babstract{
We propose the addition of functions to the \header{bit} header
to perform bit shifts on integer operands.
The \tcode{std::shl} and \tcode{std::shr} functions provide the
following advantages over the built-in shift operators:

\ol{
  \li{They always produce a mathematically correct result when possible.}
  \li{They never have undefined behavior.}
  \li{They avoid the confusing precedence of the built-in shift operators.}
}
}

\h2(listed = false){Contents}

\make_contents

\h2{Revision history}

\h3{Changes since R0}

\ul{
  \li{
    changed the function signatures to take any signed or unsigned \tcode{S}
    instead of \tcode{int}
  }
  \li{changed behavior for negative shift amounts to "shift in the opposite direction"}
  \li{added \ref(#shl-behavior-emulation)}
  \li{added \ref(#shl-benchmarks)}
  \li{added \ref(#possible-implementation)}
  \li{rebased \ref(#wording) on \ref(N5014)}
  \li{fixed various minor wording issues}
}

\h2{Introduction}

C++ has built-in shift operators, \tcode{<<} and \tcode{>>},
inherited from C with semantics essentially unchanged,
including the following two inconvenient properties:

\ol{
  \li{
    The precedence of these operators is less than the precedence of the additive operators,
    which is counterintuitive because shift operations
    behave as multiplication and division by a power of 2.
  }
  \li{
    If the shift amount is greater than or equal to the width of the (promoted)
    left operand or is negative, the behavior is undefined.
    In the remainder of this document,
    we will refer to shifts by a positive amount that is greater than
    or equal to the bit width of the operand as \dfn{overlong} shifts.
  }
}

The first property certainly cannot be changed at this point in time.
Reflector discussion revealed that GCC relies on the second property when vectorizing
multiple shift operations on adjacent memory locations,
and changing it might therefore not be "free".
Besides that, changing the second property is also likely to be contentious
because some committee members prefer to make overlong
shifts erroneous behavior instead of defining them to produce the mathematically
correct result.

For these reasons, we are instead proposing to solve the problems with shifting in C++
by introducing new Standard Library facilities in the \header{bit} header.

\h2(id=motivation){Motivation \N{EM DASH} Why are overlong shifts needed?}

We consider the undefined behavior of overlong shifts to be gratuitous.
Unlike other arithmetic operators, which produce undefined behavior only when the result is
"not mathematically defined or is outside the range of representable values"\iref{expr.pre#4},
the built-in shift operators unconditionally produce UB for overlong shifts.
This behavior is inherited from C,
in which the arithmetic operators were originally designed to do
whatever the corresponding hardware instructions would do;
processor families differ as to how overlong shifts are
handled.
However, it is unclear why the behavior of overlong shifts was
standardized as being undefined behavior as opposed to producing an unspecified result;
perhaps there's some CPU that we (the authors of this paper)
don't know about (and that might even be obsolete)
on which the behavior could include trapping, halting, or otherwise failing to produce a result.

Besides that, there are practical reasons why the undefined behavior of overlong
shifts is inconvenient, particularly when the second operand is equal to the bit
width of the first operand.

\Bex{
Consider the task of implementing the following function:

\cppblock{
/// \serif{Return the value of \tcode{x} with the least significant \tcode{num_bits} bits masked out.}
/// \serif{\tcode{num_bits} shall be nonnegative and \N{LESS THAN OR EQUAL TO} \tcode{32}.}
std::uint32_t mask_lsb(std::uint32_t x, int num_bits);
}

When \tcode{num_bits} is equal to 32, the behavior of \tcode{mask_lsb} is the natural
continuation of the behavior for smaller values of num_bits.
However, to implement this function,
we must guard against \tcode{num_bits == 32}:

\cppblock{
std::uint32_t mask_lsb(std::uint32_t x, int num_bits) {
    if (num_bits == 32) return x;
    return x & ~((static_cast<std::uint32_t>(1) << num_bits) - 1);
}
}

The first statement in the body of \tcode{mask_lsb} would be unnecessary
if the shift operation produced the mathematically correct result of \tcode{0}
when \tcode{num_bits} is equal to \tcode{32}.
}

Overlong bit-shifts can also be a problem with right-shifting,
although these problems are significantly less common.

\Bex{
We can use an integer \tcode{b} to represent a bitset,
where \tcode{1} represents an element which is in the set,
and \tcode{0} represents an integer that does not.

\cppblock{
std::uint32_t bitset = /* ... */;

// \serif{Possibly undefined behavior; would require special cases to guard against overlong shifts.}
bool contains(size_t i) {
    return (bitset >> i) & 1;
}

// \serif{Never undefined.}
bool contains(size_t i) noexcept {
    return std::shr(bitset, int(i)) & 1;
}
}

Reporting an element that \tcode{bitset} has no capacity for
as not being in the set may be exactly the behavior we want, rather than UB,
and \tcode{std::shr} makes that easy.
}

\h2{Design considerations}

\h3{Proposed behavior for overlong shifts}

We propose the addition of Standard Library functions
\tcode{std::shl} and \tcode{std::shr}
that produce mathematically correct results for overlong shifts.
That is, these functions actually just shift the bits by the number of positions specified:
in the case of an overlong shift, that means that all bits that would
be shifted are shifted off the end.
For a logical shift, the result is \tcode{0};
for an arithmetic right shift,
the result is \tcode{-1} when the first operand is negative, and \tcode{0} otherwise.

\h4{Wrapping behavior is not useful}

We believe that the "wrapping" behavior
(most famously exhibited by the x86 family of processors)
in which the shift amount is reduced modulo the bit width
of the other operand is not useful,
other than when implementing bit rotations.
Since the functions \tcode{std::rotl} and \tcode{std::rotr}
are already provided by the Standard
Library, C++ programmers do not need to implement rotations themselves anymore,
and would not benefit from wrapping behavior for shifts.

\h4{Shift amounts which are overlong by more than one should be safe}

Although shifts by an amount that are strictly greater than the bit width of the
first operand are not as useful as when the amount is equal to the bit width,
we believe that requiring the implementation to produce the mathematically correct
result in those cases does not impose an additional performance burden.
For example, if \tcode{x} is \tcode{32} bits wide,
then requiring \tcode{std::shift_left(x, 33)} to produce \tcode{0}
does not impose additional overhead
beyond only requiring \tcode{std::shift_left(x, 32)} to
produce \tcode{0}.

\Bex{
For example, GCC 15.1 at \tt{-O2} or higher produces very similar x86-64
assembly for the following two functions:

\cppblock{
unsigned int shl1(unsigned int x, unsigned int amount) {
    if (amount < 32) return x << amount; else return 0;
}
unsigned int shl2(unsigned int x, unsigned int amount) {
    if (amount > 32) std::unreachable();
    if (amount < 32) return x << amount; else return 0;
}
}

\codeblock(asm){
shl1:
        mov     ecx, esi
        xor     eax, eax
        sal     edi, cl
        cmp     esi, 32
        cmovb   eax, edi
        ret
shl2:
        mov     ecx, esi
        xor     eax, eax
        sal     edi, cl
        cmp     esi, 32
        cmovne  eax, edi
        ret
}

Using \tcode{shl2} instead of \tcode{shl1} can improve performance
only in the sense that UB enables more optimizations in general
(e.g. assuming that the branch leading to the UB is not taken).
The generated code in Clang 20 is very similar.
}

Such similarities in generated assembly are observed across many other architectures
because if a single branch or conditional move instruction is
required in order to produce the mathematically correct result for amount \tcode{>= 32},
then a single one will also be needed merely to account for the case of
\tcode{amount == 32} (when \tcode{amount > 32} is disallowed).

\h3{Logical versus arithmetic shifts}

The built-in \tcode{>>} operator performs an arithmetic shift on signed operands:
that is, the sign bit is extended.
One possible design is to provide both arithmetic and logical right shifts,
either as separate functions or as one function with
an additional parameter indicating the choice of arithmetic or logical shift.

However, we believe that this is unnecessary because in cases where the
programmer wishes to always perform a logical shift,
it is customary to employ unsigned types,
possibly by inserting a cast that will be optimized out.
Conversely, the deliberate choice to use a signed type for the left operand of
a right shift indicates intent to perform an arithmetic shift.
The proposed \tcode{std::to_signed} and \tcode{std::to_unsigned}
functions in \ref(P3643R0) would make such conversions convenient,
even in generic code.

A survey of popular programming languages supports this design direction:

\ul{
  \li{
    Languages that provide an explicit choice between a logical shift or an
    arithmetic shift usually lack unsigned integer types
    (Fortran, Java, JavaScript, OCaml).
    C# had unsigned integer types from its initial release, but
    didn't have the logical right shift operator until version 11.
  }
  \li{
    Languages that do not provide an explicit choice between a logical shift and
    an arithmetic shift always perform arithmetic shifts for negative operands
    (Go, Haskell, Objective-C, Python, Ruby, Rust).
  }
  \li{
    Perl is possibly an exception to the above,
    but it is hard to track down the behavior of shifts prior to version 5.
  }
}

\h3{Negative shift amounts}

The behavior of negative shift amounts
in some popular programming languages is listed below:

\ul{
\li{Shift amount reduced modulo bit width of other operand: C#, Java, JavaScript}
\li{Exception or panic: Go, Haskell, Python}
\li{Shift in other direction: Fortran, Objective-C, Perl, Ruby}
\li{Unspecified or implementation-defined result: OCaml, Rust}
}

The mathematically correct behavior is to "shit in the other direction".
That is if we consider left-shifting to be a multiplication with a power of two;
a negative shift is a negative exponent, i.e. a division by a power of two,
i.e. a right-shift.
\b{We proposes this "mathematically correct" behavior.}

R0 of this paper proposed an implementation-defined result and erroneous behavior.
Possible alternatives were discussed in SG6,
and neither the proposed direction nor the alternatives sparked confidence.
However, we now believe we've identified the right direction for the following reasons:

\ul{
  \li{
    The implementation-defined result in the R0 \tcode{std::shl}
    was perceived as a "half-measure".
  }
  \li{
    Shifting in the opposite direction provides
    a clear distinction in behavior from \tcode{<<}.
    It is as safe as costly as possible,
    whereas \tcode{<<} is as unsafe and cheap as possible.
  }
  \li{
    All other behaviors can be obtained by modifying the call site (\ref(#shl-behavior-emulation)).
  }
  \li{
    The performance cost of shifting in the opposite direction was measured to be acceptable
    (\ref(#shl-benchmarks)).
  }
}

\h4(id=shl-behavior-emulation){Emulating possible behaviors using \tcode{std::shl}}

\Bex{
See below various different ways to use \tcode{std::shl},
from most safe (top) to least safe (bottom):
\cppblock{
int32_t x = /* ... */;
int32_t s = /* ... */;

// If s is negative, shift in the opposite direction.
int32_t r = std::shl(x, s);

// If s is negative, r is meaningless but well-defined.
// This is faster because no check for negatives is necessary.
int32_t r = std::shl(x, uint32_t(s));

// If s is negative, r is meaningless, and a contract violation occurs.
// This is R0 of this paper, except we used EB, not contracts.
contract_assert(s >= 0);
int32_t r = std::shl(x, uint32_t(s));

// If s is negative, the behavior is undefined.
[[assume(s >= 0)]];
int32_t r = std::shl(x, s);

// Equivalent to x << s.
[[assume(s >= 0 && s < 32)]];
int32_t r = std::shl(x, s);
}
}

\h4(id=shl-benchmarks){Benchmarks of \tcode{std::shl} variants}

To make an educated choice about which behavior would be appropriate for negative
shifts in \tcode{std::shl},
find a comparison of the following functions below
(\ref(QuickBench), \ref(CompilerExplorer)):

\Bnote{
The latter functions described as "bidirectional"
shift in the opposite direction for negative shift amounts.
The \tcode{shl_branchless} and \tcode{shl_branching} functions
display behavior that was originally proposed (meaningless result for negative shifts).

Some of the implementations rely on behavior that is \em{technically} undefined,
but "works in practice".
}

\style{
  .tony-table {
    margin-left: auto;
    margin-right: auto;
  }
  .tony-table td:nth-child(1),
  .tony-table td:nth-child(2) {
    background-color: var(--deep-background-color);
    width: 50%;
  }
  .tony-table td {
    border-top: 1px solid var(--border-color);
  }
  .tony-table code-block {
    margin: 0.25em;
  }
}

\table(class=tony-table){
\tr{
  \th{Function}
  \th{Assembly\br{}(\tt{clang++-21 -O2 -march=x86-64-v4})}
  \th{Time}
}

\tr{
\td{\codeblock(cpp, borders=false){
unsigned shl_unsafe(unsigned x, int s) {
    return x << s;
}
}}
\td{\codeblock(nasm, borders=false){
shl_unsafe:
        shlx    eax, edi, esi
        ret
}}
\td{\math{\mrow{\mi{1.0}\mo{×}}}}
}

\tr{
\td{\codeblock(cpp, borders=false){
unsigned shl_branchless(
  unsigned x, int s
) {
    return (s < 32) * (x << s);
}
}}
\td{\codeblock(nasm, borders=false){
shl_branchless:
        xor     ecx, ecx
        cmp     esi, 32
        shlx    eax, edi, esi
        cmovge  eax, ecx
        ret
}}
\td{\math{\mrow{\mi{1.2}\mo{×}}}}
}

\tr{
\td{\codeblock(cpp, borders=false){
unsigned shl_branching(
  unsigned x, int s
) {
    if (s < 32) return x << s;
    else return 0;
}
}}
\td{\codeblock(nasm, borders=false){
shl_branching:
        xor     ecx, ecx
        cmp     esi, 32
        shlx    eax, edi, esi
        cmovge  eax, ecx
        ret
}}
\td{\math{\mrow{\mi{1.2}\mo{×}}}}
}

\tr{
\td{\codeblock(cpp, borders=false){
// Bidirectional (proposed behavior).
unsigned shl_bi_branching(
  unsigned x, int s
) {
    if (s >= 0) {
        if (s < 32) return x << s;
        else return 0;
    } else {
        if (s > -32) return x >> -s;
        else return 0;
    }
}
}}
\td{\codeblock(nasm, borders=false){
shl_bi_branching:
        test    esi, esi
        js      .LBB4_2
        xor     ecx, ecx
        cmp     esi, 32
        shlx    eax, edi, esi
        cmovae  eax, ecx
        ret
.LBB4_2:
        xor     eax, eax
        cmp     esi, -31
        jb      .LBB4_4
        neg     sil
        shrx    eax, edi, esi
.LBB4_4:
        ret
}}
\td{\math{\mrow{\mi{1.6}\mo{×}}}}
}

\tr{
\td{\codeblock(cpp, borders=false){
// Bidirectional (proposed behavior).
unsigned shl_bi_semi_branchless(
  unsigned x, int s
) {
    if (s >= 0) {
        return (s < 32) * (x << s);
    } else {
        return (s > -32) * (x >> -s);
    }
}
}}
\td{\codeblock(nasm, borders=false){
shl_bi_semi_branchless:
        test    esi, esi
        js      .LBB5_2
        xor     ecx, ecx
        cmp     esi, 32
        shlx    eax, edi, esi
        cmovae  eax, ecx
        ret
.LBB5_2:
        mov     eax, esi
        neg     al
        xor     ecx, ecx
        cmp     esi, -31
        shrx    eax, edi, eax
        cmovb   eax, ecx
        ret
}}
\td{\math{\mrow{\mi{1.6}\mo{×}}}}
}

\tr{
\td{\codeblock(cpp, borders=false){
// Bidirectional (proposed behavior).
unsigned shl_bi_branchless(
  unsigned x, int s
) {
    unsigned pos = (x < 32) * (x << s);
    unsigned neg = (x > -32) * (x >> -s);
    int mask = s >> 31;
    return (mask & neg) | (~mask & pos);
}
}}
\td{\codeblock(nasm, borders=false){
shl_bi_branchless:
        xor     ecx, ecx
        cmp     edi, 32
        shlx    eax, edi, esi
        cmovae  eax, ecx
        mov     edx, esi
        neg     dl
        shrx    edx, edi, edx
        mov     r8d, esi
        sar     r8d, 31
        and     r8d, edx
        cmp     edi, -31
        cmovb   r8d, ecx
        test    esi, esi
        cmovs   eax, ecx
        or      eax, r8d
        ret
}}
\td{\math{\mrow{\mi{2.9}\mo{×}}}}
}
}

The key takeaways are:

\ul{
  \li{
    Handling of negative shift amounts incurs roughly a 1.25x performance cost.
  }
  \li{
    Attempts at manual branchless optimization provide little to no value,
    or perform significantly worse.
  }
}

\Bnote{
While the performance penalty of negative shift checks may be alarming,
the user can eliminate it entirely by modifying the call site as shown previously.
When \tcode{s} is unsigned, \tcode{shl_bi_branching} and \tcode{shl_branching} are equivalent.
}

\h3{Naming}

We chose the names \tcode{shl} and \tcode{shr}
because they are as short as possible,
while still being familiar to many programmers.
For example, the x86 and ARM instruction sets
have shift instructions named \tcode{SHL} and \tcode{SHR},
Pascal has built-in operators with these names,
and Rust uses \tcode{Shl} and \tcode{Shr} as the names of the traits
that must be implemented for types to support the shift operators.

We hope the brevity will encourage adoption of \tcode{std::shl} and \tcode{std::shr}
as safe alternatives to the built-in operators.
These abbreviations are also consistent
with the existing \tcode{std::rotl} and \tcode{std::rotr} functions,
which are conspicuously not named \tcode{std::rotate_left} and \tcode{std::rotate_right},
respectively.

\: However, for the bidirectional shift function, which we expect to be used much
\: more rarely, the name sh, which would not be familiar to any programmers as far
\: as we can tell, would not be appropriate. Instead, we propose to name this
\: function shift.

\h3{Signatures}

We propose the following signatures:

\cppblock{
template<class T, class S>
  constexpr T shl(T x, S s) noexcept;

template<class T, class S>
  constexpr T shr(T x, S s) noexcept;
}

The rationale for these signature is as follows:

\ul{
  \li{
    We follow the design of \tcode{std::rotl} and \tcode{std::rotr}
    in proposing that the shift functions do not perform integer promotion.
  }
  \li{
    Like \tcode{rotl} and \tcode{rotr},
    these functions don't participate in overload resolution
    unless \tcode{T} is an integer type.
    Unlike \tcode{rotl} and \tcode{rotr}, the proposed \tcode{shl} and \tcode{shr}
    accept either signed or unsigned integral types for the first operand:
    for \tcode{shr},
    the signedness of the first parameter determines whether an arithmetic or
    logical shift is performed,
    and it would be surprising if \tcode{shl} did not also accept signed types.
  }
  \li{
    Unlike \tcode{rotl} and \tcode{rotr},
    the shift amount is not passed via \tcode{int}.
    That is because shifting by \math{\msup{\mn{2}\mn{32}}} is not equivalent
    to shifting by \math{\mn{0}},
    but such a large value stored in a \tcode{long long} may be turned into zero
    due to upper bits being discarded in the conversion.
    For rotations, this is not a problem because for power-of-two wide integers,
    discarding upper bits has no effect on the result.
  }
  \li{
    The functions are \tcode{noexcept} because they have a wide contract.
  }
}

\h3{SIMD support}

Following \ref(P2933R4),
almost all \header{bit} functions have a corresponding overload in \header{simd},
including \tcode{std::rotl} and \tcode{std::rotr}.

The proposed functions should also have \header{simd} overloads,
in the style of \tcode{simd::rotl} and \tcode{simd::rotr}.
That is, overloads that can either shift a \tcode{simd::vec} by a \tcode{simd::vec}
of shift amounts,
or by a scalar shift amount which applies to all elements in the \tcode{simd::vec}.

\h2{Possible implementation}

The scalar \tcode{std::shl} and \tcode{std::shr} may be implemented as follows:

\cppblock{
template<class T>
concept __signed_or_unsigned
  =  is_integral_v<T>
  && !is_const_v<T>
  && !is_volatile_v<T>
  && !is_same_v<T, bool>;

template<__signed_or_unsigned T, __signed_or_unsigned S>
constexpr T shl(T x, S s) noexcept {
  constexpr auto width = S(numeric_limits<make_unsigned_t<T>>::digits);
  if constexpr (is_signed_v<S>) {
    if (s < 0) {
      constexpr auto fill = T(is_signed_v<T> ? -1 : 0);
      return s <= -width ? fill : x >> -s;
    }
  }
  return s >= width ? T(0) : x << s;
}

template<__signed_or_unsigned T, __signed_or_unsigned S>
constexpr T shr(T x, S s) noexcept {
  constexpr auto width = S(numeric_limits<make_unsigned_t<T>>::digits);
  if constexpr (is_signed_v<S>) {
    if (s >= 0) {
      constexpr auto fill = T(is_signed_v<T> ? -1 : 0);
      return s >= width ? fill : x >> s;
    }
  }
  return s <= -width ? T(0) : x << -s;
}
}

\tcode{simd::shl} and \tcode{simd::shr} may be implemented (naively)
by performing the operation for each element.
A less naive implementation would be based on the \tcode{branchless} variants
shown in \ref(#shl-benchmarks).

\Bnote{
Conveniently, the underlying instructions for comparing integers yield bit masks
where every bit is set when the comparison succeeds.
This makes it easy to implement \tcode{(s < 32) * (x << s)} in terms of e.g.
\tt{VPCMPGTD}, \tt{VPAND}, and \tt{VPSLLD} on x86.
}

\h2{Wording}

The following changes are relative to \ref(N5014).

\Bnote{
The \tcode{shl} and \tcode{shr} functions should immediately precede the
\tcode{rotl} and \tcode{rotr} functions in the wording. Therefore, if this paper
and \ref(P3764R0) are adopted in the same meeting, the \tcode{shl} and \tcode{shr}
functions should be inserted between the \tcode{msb_to_mask} and \tcode{rotl}
functions.
}

\h3{[version.syn]}

Bump feature-test macros in \eelis{version.syn} as follows:

\Bdiff{
\itemdecl{
#define __cpp_lib_bitops \del{201907L} \ins{20XXXXL} // \serif{freestanding, also in \tt{<bit>}}
#define __cpp_lib_simd   \del{202502L} \ins{20XXXXL}   // \serif{also in \tt{<simd>}}
}
}

\h3{[bit]}

In \eelis{bit.syn}, change the synopsis as follows:

\Bdiff{
\itemdecl{
namespace std {
  \etc

\ins{  // \serif{[bit.shift], shifting}
  template<class T, class S>
    constexpr T shl(T x, S s) noexcept;
  template<class T, class S>
    constexpr T shr(T x, S s) noexcept;}

  // \serif{[bit.rotate], rotating}
  template<class T, class S>
    constexpr T rotl(T x, S s) noexcept;
  template<class T, class S>
    constexpr T rotr(T x, S s) noexcept;

  \etc
}
}
}

In \eelis{bit}, add a new subclause immediately preceding \eelis{bit.rotate}:

\Vset(pnum){0}

\Bins{
\cowel_html_element(h3){Shifting \stable_ref{bit.shift}}

\pnum
In the following descriptions,
the result \math{\mi{r}} of an arithmetic operation is
first represented in a hypothetical integer type with sufficient range,
then converted to \tcode{T} as if by \tcode{static_cast<T>(\math{\mi{r}})}.

\pnum
\note{
The value of \tcode{s} in the following descriptions may be negative,
which has the effect of \q{shifting in the opposite direction}.
In any case, invoking the functions below with \tcode{s}
has the same result as \tcode{s} consecutive shifts by \tcode{1}.
}

\itemdecl{
template<class T, class S>
  constexpr T shl(T x, S s) noexcept;
}

\itemdescr{
\pnum
\constraints
Each of \tcode{T} and \tcode{S}
is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
\math{\mrow{\mi{x}\mo{×}\msup{\mn{2}\mi{s}}}}
rounded towards negative infinity.
}

\itemdecl{
template<class T, class S>
  constexpr T shr(T x, S s) noexcept;
}

\itemdescr{
\pnum
\constraints
Each of \tcode{T} and \tcode{S}
is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
\math{\mrow{\mi{x}\mo{×}\msup{\mn{2}\mrow{\mo{−}\mi{s}}}}}
rounded towards negative infinity.

\note{
\tcode{shl(x, s)} is equivalent to \tcode{shr(x, -s)}
if \tcode{s} is of signed type,
except that \tcode{-s} is undefined if \tcode{s} equals \tcode{numeric_limits<S>::min()};
neither \tcode{shl} nor \tcode{shr} exhibit undefined behavior.
}
}
}

\h3{[simd]}

In \eelis{simd.syn}, change the synopsis as follows:

\Bdiff{
\itemdecl{
\etc

// \serif{[simd.bit], bit manipulation}

\etc

\ins{template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 shl(const V0& v, const V1& s) noexcept;
template<\exposid{simd-type} V, class S>
  constexpr V  shl(const V& v, S s) noexcept;

template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 shr(const V0& v, const V1& s) noexcept;
template<\exposid{simd-type} V, class S>
  constexpr V  shr(const V& v, S s) noexcept;}

template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 rotl(const V0& v, const V1& s) noexcept;
template<\exposid{simd-type} V>
  constexpr V  rotl(const V& v, int s) noexcept;

template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 rotr(const V0& v, const V1& s) noexcept;
template<\exposid{simd-type} V>
  constexpr V  rotr(const V& v, int s) noexcept;

\etc

// See \serif{[simd.bit], bit manipulation}
using simd::byteswap;
using simd::bit_ceil;
using simd::bit_floor;
using simd::has_single_bit;
\ins{using simd::shl;}
\ins{using simd::shr;}
using simd::rotl;
using simd::rotr;
using simd::bit_width;
using simd::countl_zero;
using simd::countl_one;
using simd::countr_zero;
using simd::countr_one;
using simd::popcount;

\etc
}
}

In \eelis{simd.bit}, immediately preceding the first declaration of
\tcode{rotl}, insert the following:


\Vset(pnum){10}

\Bins{
\itemdecl{
template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 shl(const V0& v0, const V1& v1) noexcept;
template<\exposid{simd-type} V0, \exposid{simd-type} V1>
  constexpr V0 shr(const V0& v0, const V1& v1) noexcept;
}

\itemdescr{
\pnum
\constraints
\ul{
  \li{The type \tcode{V0::value_type} is a signed or unsigned integer
      type\iref{basic.fundamental},}
  \li{the type \tcode{V1::value_type} is a signed or unsigned integer type,}
  \li{\tcode{V0::size() == V1::size()} is \tcode{true}, and}
  \li{\tcode{sizeof(typename V0::value_type) == sizeof(typename V1::value_type)}
      is \tcode{true}.}
}

\pnum
\returns
A \tcode{basic_vec} object where the \math{\msup{\mi{i}\mtext{th}}} element
is initialized to the result of
\tcode{\exposid{bit-func}(v0[\math{\mi{i}}], v1[\math{\mi{i}}])}
for all \math{\mi{i}} in the range
[\tcode{0}, \tcode{V0::size()}), where \tcode{\exposid{bit-func}} has the same
behavior as the corresponding scalar function from \header{bit}.
}

\itemdecl{
template<\exposid{simd-type} V, class S>
  constexpr V shl(const V& v, S s) noexcept;
template<\exposid{simd-type} V, class S>
  constexpr V shr(const V& v, S s) noexcept;
}

\itemdescr{
\pnum
\constraints
Each of \tcode{V::value_type} and \tcode{S}
is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
A \tcode{basic_vec} object where the \math{\msup{\mi{i}\mtext{th}}} element is
initialized to the result of
\tcode{\exposid{bit-func}(v[\math{\mi{i}}], s)}
for all \math{\mi{i}} in the range [\tcode{0}, \tcode{V::size()}), where
\tcode{\exposid{bit-func}} is the corresponding scalar function from
\header{bit}.
}
}


\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P2933R4,
  title = Extend <bit> header function with overloads  for std::simd,
  author = Daniel Towner\, Ruslan Arutyunyan,
  date = 2025-02-13,
  link = https://wg21.link/p2933r4,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2933r4.html,
)\
\bib(
  id = P3643R0,
  title = \tcode{std::to_signed} and \tcode{std::to_unsigned},
  date = 2025-03-13,
  author = Jan Schultke,
  link = https://wg21.link/p3643r0,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r0.html,
)\
\bib(
  id = P3764R0,
  title = A utility function for propagating the most significant bit,
  date = 2025-07-15,
  author = Jan Schultke,
  link = https://wg21.link/p3764r0,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3764r0.html,
)\
\bib(
  id = QuickBench,
  title = Benchmark for various ways of handling negative shift amounts,
  link = https://quick-bench.com/q/HcAUoOoGFHnm5nx1G_rJs52oLaY,
)\
\bib(
  id = CompilerExplorer,
  title = Assembly comparison for various ways of handling negative shift amounts,
  link = https://godbolt.org/z/1Won5qjo9,
)\

\make_bib
