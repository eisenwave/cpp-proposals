\cowel_include{libwg21.cow}

\wg21_head(
  title = \tcode{std::simd} overloads for bit permutations
){
\dl{
  \dt{Document number:} \dd{\docnum{P3772R1}}
  \dt{Date:}            \dd{\tt{2025-11-13}}
  \dt{Audience:}        \dd{LEWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultkegmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3772/github)}
  \dt{Source:}          \dd{\ref(https://github.com/Eisenwave/cpp-proposals/blob/master/src/bit-permutations-simd.cow)}
}
\hr
}

\Babstract{
\ref(P3104R4) has been been design-approved by LEWG for C++29.
This proposal adds \tcode{std::simd} overloads
to add consistency with \ref(P2933R4).
}

\h2(listed=false){Contents}

\make_contents

\h2{Revision history}

\ul{
  \li{updated paper reference to \ref(P3104R4) (instead of R3)}
  \li{removed stray \tcode{noexcept} on \tcode{simd::bit_repeat}}
  \li{rebased \ref(#wording) on \ref(N5014)}
}

\h2{Introduction}

\ref(P3104R4) has been been design-approved by LEWG for C++29.
During the discussion of the paper,
it was \em{not} mentioned that \ref(P2933R4) adds \tcode{std::simd}
overloads for almost all functions in the \header{bit} header.

For the purpose of consistency,
this proposal adds these overloads.

\Bnote{
This proposal has an extremely minimal motivation and design discussion.
That is because I see it as an obvious extensions of the existing design,
and possibly a bug fix.

Should the need arise,
these topics could be explored more deeply.
}

\h2{Design}

Some of the design in this proposal has direct equivalents:

\ul{
  \li{\tcode{std::simd::bit_repeat} is analogous to \tcode{std::simd::rotl}.}
  \li{\tcode{std::simd::bit_reverse} is analogous to \tcode{std::simd::byteswap}.}
}

The signatures of the the new and respective existing functions are identical.
\tcode{std::bit_compress} and \tcode{std::bit_expand}
are binary operations between two unsigned integers of the same type,
so naturally,
\tcode{std::simd::bit_compress} and \tcode{std::simd::bit_expand}
are binary operations between two \tcode{std::simd::vec}s of the same type.

All added function are \tcode{noexcept},
except the \tcode{simd::bit_repeat} overloads.
That is because \tcode{std::bit_repeat} is not \tcode{noexcept} either;
it has a narrow contract.

\h2{Implementation experience}

None.

\h2{Wording}

In \eelis{version.syn}, bump the feature-test macro:

\Bdiff{
\itemdecl{
#define __cpp_lib_simd \del{202506L} \ins{20XXXXL} // \serif{also in <simd>}
}
}

In \eelis{simd.syn}, change the synopsis as follows:

\Bdiff{\itemdecl{
namespace std::simd {
  \etc
  
  // \serif{\eelis{simd.bit}, bit manipulation}
  template<\exposid{simd-type} V> constexpr V byteswap(const V& v) noexcept;
\ins{  template<\exposid{simd-type} V> constexpr V bit_reverse(const V& v) noexcept;}
  template<\exposid{simd-type} V> constexpr V bit_ceil(const V& v) noexcept;
  template<\exposid{simd-type} V> constexpr V bit_floor(const V& v) noexcept;

  template<\exposid{simd-type} V>
    constexpr typename V::mask_type has_single_bit(const V& v) noexcept;

  template<\exposid{simd-type} V0, \exposid{simd-type} V1>
    constexpr V0 rotl(const V0& v, const V1& s) noexcept;
  template<\exposid{simd-type} V>
    constexpr V  rotl(const V& v, int s) noexcept;

  template<\exposid{simd-type} V0, \exposid{simd-type} V1>
    constexpr V0 rotr(const V0& v, const V1& s) noexcept;
  template<\exposid{simd-type} V>
    constexpr V  rotr(const V& v, int s) noexcept;
\ins{
  template<\exposid{simd-type} V0, \exposid{simd-type} V1>
    constexpr V0 bit_repeat(const V0& v, const V1& l);
  template<\exposid{simd-type} V>
    constexpr V  bit_repeat(const V& v, int l);}

  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      bit_width(const V& v) noexcept;
  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countl_zero(const V& v) noexcept;
  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countl_one(const V& v) noexcept;
  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countr_zero(const V& v) noexcept;
  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countr_one(const V& v) noexcept;
  template<\exposid{simd-type} V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      popcount(const V& v) noexcept;

\ins{  template<\exposid{simd-type} V>
    constexpr V bit_compress(const V& v, const V& m) noexcept;
  template<\exposid{simd-type} V>
    constexpr V bit_expand(const V& v, const V& m) noexcept;

  template<\exposid{simd-type} V>
    constexpr V bit_compress(const V& v, typename V::value_type m) noexcept;
  template<\exposid{simd-type} V>
    constexpr V bit_expand(const V& v, typename V::value_type m) noexcept;}

  \etc
}

namespace std {
  \etc

  // \serif{\eelis{simd.bit}, bit manipulation}
  using simd::byteswap;
  using simd::bit_ceil;
  using simd::bit_floor;
\ins{  using simd::bit_reverse;}
  using simd::has_single_bit;
  using simd::rotl;
  using simd::rotr;
\ins{  using simd::bit_repeat;}
  using simd::bit_width;
  using simd::countl_zero;
  using simd::countl_one;
  using simd::countr_zero;
  using simd::countr_one;
  using simd::popcount;
\ins{  using simd::bit_compress;}
\ins{  using simd::bit_expand;}

  \etc
}
}}

Change \eelis{simd.bit} as follows:

\cowel_macro(mathvar){\math{\mi{\cowel_put}}}
\cowel_macro(mathvar_th){\math{\msup{\mi{\cowel_put}\mtext{th}}}}

\Bdiff{
\cowel_html_element(h3){Bit manipulation \stable_ref{simd.bit}}

\itemdecl{
template<\exposconcept{simd-type} V> constexpr V byteswap(const V& v) noexcept;
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} models \tcode{integral}.

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{std::byteswap(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}).
}

\itemdecl{
\ins{template<\exposconcept{simd-type} V> constexpr V bit_reverse(const V& v) noexcept;}
}

\itemdescr{
\ins{¶
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.}

\ins{¶
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{std::bit_reverse(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}).}
}

\itemdecl{
template<\exposconcept{simd-type} V> constexpr V bit_ceil(const V& v) noexcept;
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.

\pnum
\expects
For every \mathvar{i} in the range [\tcode{0}, \tcode{V::size()}), the smallest power of 2
greater than or equal to \tcode{v[\mathvar{i}]} is representable as a value of type
\tcode{V::value_type}.

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{std::bit_ceil(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}).

\pnum
\remarks
A function call expression that violates the precondition in the \expects
element is not a core constant expression\iref{expr.const}.
}

\itemdecl{
template<\exposconcept{simd-type} V> constexpr V bit_floor(const V& v) noexcept;
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{std::bit_floor(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}).
}

\itemdecl{
template<\exposconcept{simd-type} V>
  constexpr typename V::mask_type has_single_bit(const V& v) noexcept;
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
A \tcode{basic_mask} object where the \mathvar_th{i} element is initialized
to the result of \tcode{std::\brk{}has_single_bit(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}).
}

\itemdecl{
template<\exposconcept{simd-type} V0, \exposconcept{simd-type} V1>
  constexpr V0 rotl(const V0& v0, const V1& v1) noexcept;
template<\exposconcept{simd-type} V0, \exposconcept{simd-type} V1>
  constexpr V0 rotr(const V0& v0, const V1& v1) noexcept;
\ins{template<\exposconcept{simd-type} V0, \exposconcept{simd-type} V1>
  constexpr V0 bit_repeat(const V0& v0, const V1& v1);}
}

\itemdescr{
\pnum
\constraints
\ul{
 \li{The type \tcode{V0::value_type} is an unsigned integer type\iref{basic.fundamental},}
 \li{the type \tcode{V1::value_type} models \tcode{integral},}
 \li{\tcode{V0::size() == V1::size()} is \tcode{true}, and}
 \li{\tcode{sizeof(typename V0::value_type) == sizeof(typename V1::value_type)} is \tcode{true}.}
}

\ins{¶
\expects
For \tcode{bit_repeat},
\tcode{v1[\mathvar{i}] > 0} is \tcode{true}
for all \mathvar{i} in the range [\tcode{0}, \tcode{V0::size()}).
}

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{\placeholder{bit-func}(v0[\mathvar{i}],
static_cast<int>(v1[\mathvar{i}]))} for all \mathvar{i} in the range [\tcode{0}, \tcode{V0::size()}),
where \placeholder{bit-func} is the corresponding scalar function from \libheader{bit}.
}

\itemdecl{
template<\exposconcept{simd-type} V> constexpr V rotl(const V& v, int s) noexcept;
template<\exposconcept{simd-type} V> constexpr V rotr(const V& v, int s) noexcept;
\ins{template<\exposconcept{simd-type} V> constexpr V bit_repeat(const V& v, int l) noexcept;}
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.

\ins{¶
\expects
For \tcode{bit_repeat},
\tcode{l > 0} is \tcode{true}.}

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{\placeholder{bit-func}(v[\mathvar{i}], s)} for all \mathvar{i} in the
range [\tcode{0}, \tcode{V::size()}), where \placeholder{bit-func} is the corresponding
scalar function from \libheader{bit}.
}

\itemdecl{
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> bit_width(const V& v) noexcept;
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> countl_zero(const V& v) noexcept;
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> countl_one(const V& v) noexcept;
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> countr_zero(const V& v) noexcept;
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> countr_one(const V& v) noexcept;
template<\exposconcept{simd-type} V>
  constexpr rebind_t<make_signed_t<typename V::value_type>, V> popcount(const V& v) noexcept;
}

\itemdescr{
\pnum
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{\placeholder{bit-func}(v[\mathvar{i}])} for all \mathvar{i} in the range
[\tcode{0}, \tcode{V::size()}), where \placeholder{bit-func} is the corresponding scalar
function from \libheader{bit}.
}

\itemdecl{
\ins{template<\exposid{simd-type} V>
  constexpr V bit_compress(const V& v, const V& m) noexcept;
template<\exposid{simd-type} V>
  constexpr V bit_expand(const V& v, const V& m) noexcept;}
}

\itemdescr{
\ins{
¶
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.}

\ins{¶
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{\placeholder{bit-func}(v[\mathvar{i}], m[\mathvar{i}])}
for all \mathvar{i} in the range [\tcode{0}, \tcode{V::size()}),
where \placeholder{bit-func} is the corresponding
scalar function from \libheader{bit}.
}
}

\itemdecl{
\ins{template<\exposid{simd-type} V>
  constexpr V bit_compress(const V& v, typename V::value_type m) noexcept;
template<\exposid{simd-type} V>
  constexpr V bit_expand(const V& v, typename V::value_type m) noexcept;}
}

\itemdescr{
\ins{
¶
\constraints
The type \tcode{V::value_type} is an unsigned integer type\iref{basic.fundamental}.}

\ins{¶
\returns
A \tcode{basic_vec} object where the \mathvar_th{i} element is initialized to
the result of \tcode{\placeholder{bit-func}(v[\mathvar{i}], m)}
for all \mathvar{i} in the range [\tcode{0}, \tcode{V::size()}),
where \placeholder{bit-func} is the corresponding
scalar function from \libheader{bit}.
}
}
}

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P3104R4,
  title = Bit permutations,
  date = 2025-06-28,
  author = Jan Schultke,
  link = https://wg21.link/p3104r4,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3104r4.html,
)\
\bib(
  id = P2933R4,
  title = Extend <bit> header function with overloads  for std::simd,
  author = Daniel Towner\, Ruslan Arutyunyan,
  date = 2025-02-13,
  link = https://wg21.link/p2933r4,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2933r4.html,
)\

\make_bib
