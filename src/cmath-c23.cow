\cowel_include{libwg21.cow}

\wg21_head(
  title = Rebasing \tt{<cmath>} on C23
){
\dl{
  \dt{Document number:} \dd{\docnum{D3935R0}}
  \dt{Date:}            \dd{\tt{2025-11-25}}
  \dt{Audience:}        \dd{SG22}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3935/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/cmath-c23.cow)}
}
\hr
}

\Babstract{

}

\h2(listed=false){Contents}

\make_contents

\h2{Introduction}

\ref(P3348R4) rebased the C++26 standard on C23;
it previously referred to C17.
However, this process was deliberately left incomplete:
some of the new C23 \header{math.h} features are only used by decimal floating-point types,
or they require core language changes, etc.

The goal of this proposal is to pull in all the new C23 \header{math.h} features
which are useful not only to decimal floating-point numbers.

\h2{Design}

\h3{New functions}

The functions in the table below are proposed for inclusion in C++29.
The placeholder \tcode{\exposid{F}} is a shorthand for the
\tcode{\exposid{floating-point-type}} placeholder in \eelis{cmath.syn}.
In addition to the functions using an \tcode{\exposid{F}} placeholder,
single-type functions such as \tcode{float acospif(float)} are proposed,
but are not listed in the table for the sake of brevity;
refer to \ref(#wording) for the complete list.

\style{
  #new-functions {
    margin-left: auto;
    margin-right: auto;
  }
  #new-functions td {
    border-top: 1px solid var(--border-color);
  }
}

\table(id=new-functions){
  \tr{
    \th{Function}
    \th{Returns}
  }
  \tr{
    \td{\tcode{bool iscanonical(\exposid{F} x);}}
    \td{
      \tcode{true} if and only if \tcode{x} is canonical
    }
  }
  \tr{
    \td{\tcode{bool issignaling(\exposid{F} x);}}
    \td{
      \tcode{true} if and only if \tcode{x} is a signaling NaN
    }
  }
  \tr{
    \td{\tcode{bool issubnormal(\exposid{F} x);}}
    \td{
      \tcode{true} if and only if \tcode{x} is subnormal
    }
  }
  \tr{
    \td{\tcode{bool iszero(\exposid{F} x);}}
    \td{
      \tcode{true} if and only if \tcode{x} is zero
    }
  }
  \tr{
    \td{\tcode{\exposid{F} acospi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mrow{\mi{arccos}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval [0, 1]
    }
  }
  \tr{
    \td{\tcode{\exposid{F} asinpi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mrow{\mi{arcsin}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval [-12, +12]
    }
  }
  \tr{
    \td{\tcode{\exposid{F} atanpi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mrow{\mi{arctan}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval [-21, +12]
    }
  }
  \tr{
    \td{\tcode{\exposid{F} atan2pi(\exposid{F} y, \exposid{F} x);}}
    \td{
      \math{\mrow{
        \mrow{\mi{atan2}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval [-1, +1]
    }
  }
  \tr{
    \td{\tcode{\exposid{F} cospi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mi{cos}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} sinpi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mi{sin}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} tanpi(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mi{tan}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp10(\exposid{F} x);}}
    \td{
      \math{\msup{
        \mn{10}\mi{x}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp10m1(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \msup{\mn{10}\mi{x}}
        \mo{−}
        \mn{1}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp2m1(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \msup{\mn{2}\mi{x}}
        \mo{−}
        \mn{1}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} log10p1(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \msub{\mi{log}\mn{10}}
        \mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} logp1(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \mi{log}\mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} log2p1(\exposid{F} x);}}
    \td{
      \math{\mrow{
        \msub{\mi{log}\mn{2}}
        \mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} compoundn(\exposid{F} x, long long n);}}
    \td{
      \math{\msup{
        \mrow{
          \mo(stretchy=false){(}
          \mn{1}\mo{+}\mi{x}
          \mo(stretchy=false){)}
        }
        \mi{n}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} pown(\exposid{F} x, long long n);}}
    \td{
      \math{\msup{
        \mi{x}
        \mi{n}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} powr(\exposid{F} y, \exposid{F} x);}}
    \td{
      \math{\msup{
        \mi{e}
        \mrow{
          \mi{y}
          \msub{\mo{log}\mi{e}}
          \mi{x}
        }
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} rootn(\exposid{F} x, long long n);}}
    \td{
      \math{\msup{
        \mi{x}
        \mfrac{\mn{1}\mi{n}}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} rsqrt(\exposid{F} x);}}
    \td{
      \math{\mfrac{
        \mn{1}
        \msqrt{\mi{x}}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} roundeven(\exposid{F} x);}}
    \td{
      \tcode{x} rounded to the nearest integer,\br
      rounding halfway cases to even
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fromfp(\exposid{F} x, int rnd, unsigned width);}}
    \td{
      \tcode{x} rounded to a signed \tcode{width}-bit integer,\br
      or NaN if \tcode{x} is not in range;\br
      \tcode{rnd} is the rounding mode
    }
  }
  \tr{
    \td{\tcode{\exposid{F} ufromfp(\exposid{F} x, int rnd, unsigned width);}}
    \td{
      \tcode{x} rounded to an unsigned \tcode{width}-bit integer,\br
      or NaN if \tcode{x} is not in range;\br
      \tcode{rnd} is the rounding mode
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fromfpx(\exposid{F} x, int rnd, unsigned width);}}
    \td{
      \tcode{fromfp(x, rnd, width)};\br
      may also raise \tt{FE_INEXACT}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} ufromfpx(\exposid{F} x, int rnd, unsigned width);}}
    \td{
      \tcode{ufromfp(x, rnd, width)};\br
      may also raise \tt{FE_INEXACT}
    }
  }
  \tr{
    \td{\tcode{bool canonicalize(\exposid{F}* cx, const \exposid{F}* x);}}
    \td{
      \tcode{true} if and only if canonicalization failed
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fmaximum_mag(\exposid{F} x, \exposid{F} y);}}
    \td{
      the value with greater magnitude,\br
      or \tcode{fmaximum(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fminimum_mag(\exposid{F} x, \exposid{F} y);}}
    \td{
      the value with greater magnitude,\br
      or \tcode{fminimum(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fmaximum_mag_num(\exposid{F} x, \exposid{F} y);}}
    \td{
      the value with greater magnitude,\br
      or \tcode{fmaximum_num(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fminimum_mag_num(\exposid{F} x, \exposid{F} y);}}
    \td{
      the value with greater magnitude,\br
      or \tcode{fminimum_num(x, y)}
    }
  }
  \tr{
    \td{
      \tcode{float fadd(\exposid{F} x, \exposid{F} y);\br
      double dadd(\exposid{F} x, \exposid{F} y);}
    }
    \td{
      \math{\mrow{\mi{x}\mo{+}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fsub(\exposid{F} x, \exposid{F} y);\br
      double dsub(\exposid{F} x, \exposid{F} y);}
    }
    \td{
      \math{\mrow{\mi{x}\mo{−}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fmul(\exposid{F} x, \exposid{F} y);\br
      double dmul(\exposid{F} x, \exposid{F} y);}
    }
    \td{
      \math{\mrow{\mi{x}\mo{×}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fdiv(\exposid{F} x, \exposid{F} y);\br
      double ddiv(\exposid{F} x, \exposid{F} y);}
    }
    \td{
      \math{\mrow{\mi{x}\mo{÷}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float ffma(\exposid{F} x, \exposid{F} y, \exposid{F} z);\br
      double dfma(\exposid{F} x, \exposid{F} y, \exposid{F} z);}
    }
    \td{
      \math{\mrow{
        \mo{(}\mi{x}\mo{×}\mi{y}\mo{)}
        \mo{+}\mi{z}
      }}
    }
  }
  \tr{
    \td{
      \tcode{float fsqrt(\exposid{F} x);\br
      double dsqrt(\exposid{F} x);}
    }
    \td{
      \math{\msqrt{\mi{x}}}
    }
  }
  \tr{
    \td{\tcode{bool iseqsig(\exposid{F} x, \exposid{F} y)}}
    \td{
      \tcode{true} if \tcode{x} and \tcode{y} are equal and\br
      \tcode{false} otherwise
    }
  }
}

\h4{Narrow rounding functions}

The narrow rounding functions (such as \tcode{fadd})
are unusually difficult to expose in C++ in a generic way.
Even the \header{tgmath.h} versions require the user to specify the return type
as a prefix (\tt{f}, \tt{d}, \tt{f32}, …) as part of the function name.
This is extremely hostile to generic code,
and also means there is no support for extended floating-types in C++
because we don't consider \tcode{std::float32_t} to be C23's \tcode{_Float32}
and to have \tcode{sqrtf32} and other functions that accept it.

To solve this, we can do something novel:
add function templates for these rounding functions:

\cppblock{
template<class T, class F> constexpr T fadd(F x, F y) noexcept;
template<class T, class F> constexpr T fsub(F x, F y) noexcept;
template<class T, class F> constexpr T fmul(F x, F y) noexcept;
template<class T, class F> constexpr T fdiv(F x, F y) noexcept;
template<class T, class F> constexpr T ffma(F x, F y, F z) noexcept;
template<class T, class F> constexpr T fsqrt(F x) noexcept;
}

While the prefix \q{\tt{f}} is a bit inappropriate
(it it supposed to indicate a \tcode{float} return type),
there is no obvious alternative prefix,
\q{\tt{f}} definitely won't clash with future \header{math.h} functions,
and having no prefix at all would create undesirable overload sets with other functions.

These templates are constrained so that \tcode{F}
has to be of greater conversion rank than \tcode{T},
which matches the C23 restrictions.
Furthermore, mixing standard and extended floating-point types is not supported.

\h3{New macros}

Besides the new functions,
there are also macros which are pulled in from C23.

\Bnote{
The \tcode{int rnd} parameter in functions such as \tcode{fromfp}
corresponds to one of \tt{FP_INT_*} rounding direction macros.
}

The block below lists all new macros:

\cppblock{
// math rounding direction macros
FP_INT_UPWARD
FP_INT_DOWNWARD
FP_INT_TOWARDZERO
FP_INT_TONEARESTFROMZERO
FP_INT_TONEAREST

// indicates that the respective function is "fast"
FP_FAST_FADD
FP_FAST_FADDL
FP_FAST_DADDL
FP_FAST_FSUB
FP_FAST_FSUBL
FP_FAST_DSUBL
FP_FAST_FMUL
FP_FAST_FMULL
FP_FAST_DMULL
FP_FAST_FDIV
FP_FAST_FDIVL
FP_FAST_DDIVL
FP_FAST_FSQRT
FP_FAST_FSQRTL
FP_FAST_DSQRTL
FP_FAST_FFMA
FP_FAST_FFMAL
FP_FAST_DFMAL
}

\h2{Wording}

The changes are relative to \ref(N5014).

\h3{show-number=false}{[basic.fundamental]}

Immediately prior to \eelis{basic.fundamental#13},
insert a new paragraph:

\Bins{
An implementation may prefer particular representations of values
that have multiple representations in a floating-point type.
The preferred representations of a floating-point type,
including unique representations of values in the type, are called \dfn{canonical}.
A floating-point type may also contain \dfn{non-canonical representations},
for example, redundant representations of some or all its
values, or representations that are extraneous to the floating-point model.
Typically, floating-point operations deliver results with canonical representations.

\note{
The functions \tcode{std::iscanonical} and \tcode{std::canonicalize} distinguish
canonical (preferred) representations,
but this distinction alone does not imply that canonical and non-canonical representations
are of different values.
}
}

\editnote{
As a practical example,
signaling NaN may be considered non-canonical and
quiet NaN may be considered canonical representations of the same value.
Also, an implementation may treat subnormal floating-point numbers
or negative zero as non-canonical representations of zero.

The C23 wording is extremely vague,
and we can't be precise either if we don't want to risk having diverging
behavior for \tcode{iscanonical}.

\tcode{iscanonical} and \tcode{canonicalize} are primarily motivated by
ISO/IEC 60559 decimal floating-point representations anyway,
where it is precisely specified which representations are canonical.
}

\h3(show-number=false){[version.syn]}

Add a feature-test macro to \eelis{version.syn} as follows:

\Bins{
\itemdecl{
#define __cpp_lib_cmath 20XXXXL //\serif{ also in \tt{<cmath>}, \tt{<cstdlib>}}
}
}

\editnote{
Although the proposal also adds a \tcode{__STDC_VERSION_MATH_H__} macro from C23,
this cannot be reliably used to detect the new functions;
it could have also been leaked through a \header{math.h} header from somewhere,
without e.g. \tcode{std::roundeven} actually existing.
}

\h3(show-number=false){[cmath.syn]}

\cowel_macro(floating_point_typ){\exposid{floating-point-type}}

\Bdiff{
\itemdecl{
\ins{#define __STDC_VERSION_MATH_H__ 202311L
        }
#define HUGE_VAL \seebelow
#define HUGE_VALF \seebelow
#define HUGE_VALL \seebelow
#define INFINITY \seebelow
#define NAN \seebelow
\ins{       }
#define FP_INFINITE \seebelow
#define FP_NAN \seebelow
#define FP_NORMAL \seebelow
#define FP_SUBNORMAL \seebelow
#define FP_ZERO \seebelow
\ins{       
#define FP_INT_UPWARD \seebelow
#define FP_INT_DOWNWARD \seebelow
#define FP_INT_TOWARDZERO \seebelow
#define FP_INT_TONEARESTFROMZERO \seebelow
#define FP_INT_TONEAREST \seebelow
        }
#define FP_FAST_FMA \seebelow
#define FP_FAST_FMAF \seebelow
#define FP_FAST_FMAL \seebelow
\ins{#define FP_FAST_FADD \seebelow
#define FP_FAST_FADDL \seebelow
#define FP_FAST_DADDL \seebelow
#define FP_FAST_FSUB \seebelow
#define FP_FAST_FSUBL \seebelow
#define FP_FAST_DSUBL \seebelow
#define FP_FAST_FMUL \seebelow
#define FP_FAST_FMULL \seebelow
#define FP_FAST_DMULL \seebelow
#define FP_FAST_FDIV \seebelow
#define FP_FAST_FDIVL \seebelow
#define FP_FAST_DDIVL \seebelow
#define FP_FAST_FSQRT \seebelow
#define FP_FAST_FSQRTL \seebelow
#define FP_FAST_DSQRTL \seebelow
#define FP_FAST_FFMA \seebelow
#define FP_FAST_FFMAL \seebelow
#define FP_FAST_DFMAL \seebelow
        }
#define FP_ILOGB0 \seebelow
#define FP_ILOGBNAN \seebelow
\ins{        }
#define MATH_ERRNO \seebelow
#define MATH_ERREXCEPT \seebelow

#define math_errhandling \seebelow

namespace std {
  using float_t = \seebelow;
  using double_t = \seebelow;

  constexpr \floating_point_typ acos(\floating_point_typ x);
  constexpr float               acosf(float x);
  constexpr long double         acosl(long double x);

  constexpr \floating_point_typ asin(\floating_point_typ x);
  constexpr float               asinf(float x);
  constexpr long double         asinl(long double x);

  constexpr \floating_point_typ atan(\floating_point_typ x);
  constexpr float               atanf(float x);
  constexpr long double         atanl(long double x);

  constexpr \floating_point_typ atan2(\floating_point_typ y, \floating_point_typ x);
  constexpr float               atan2f(float y, float x);
  constexpr long double         atan2l(long double y, long double x);

  constexpr \floating_point_typ cos(\floating_point_typ x);
  constexpr float               cosf(float x);
  constexpr long double         cosl(long double x);

  constexpr \floating_point_typ sin(\floating_point_typ x);
  constexpr float               sinf(float x);
  constexpr long double         sinl(long double x);

  constexpr \floating_point_typ tan(\floating_point_typ x);
  constexpr float               tanf(float x);
  constexpr long double         tanl(long double x);
\ins{
  constexpr \floating_point_typ acospi(\floating_point_typ x);
  constexpr float               acospif(float x);
  constexpr long double         acospil(long double x);

  constexpr \floating_point_typ asinpi(\floating_point_typ x);
  constexpr float               asinpif(float x);
  constexpr long double         asinpil(long double x);

  constexpr \floating_point_typ atanpi(\floating_point_typ x);
  constexpr float               atanpif(float x);
  constexpr long double         atanpil(long double x);

  constexpr \floating_point_typ atan2(\floating_point_typ y, \floating_point_typ x);
  constexpr float               atan2f(float y, float x);
  constexpr long double         atan2l(long double y, long double x);
  
  constexpr \floating_point_typ cospi(\floating_point_typ x);
  constexpr float               cospif(float x);
  constexpr long double         cospil(long double x);

  constexpr \floating_point_typ sinpi(\floating_point_typ x);
  constexpr float               sinpif(float x);
  constexpr long double         sinpil(long double x);

  constexpr \floating_point_typ tanpi(\floating_point_typ x);
  constexpr float               tanpif(float x);
  constexpr long double         tanpil(long double x);}

  constexpr \floating_point_typ acosh(\floating_point_typ x);
  constexpr float               acoshf(float x);
  constexpr long double         acoshl(long double x);

  constexpr \floating_point_typ asinh(\floating_point_typ x);
  constexpr float               asinhf(float x);
  constexpr long double         asinhl(long double x);

  constexpr \floating_point_typ atanh(\floating_point_typ x);
  constexpr float               atanhf(float x);
  constexpr long double         atanhl(long double x);

  constexpr \floating_point_typ cosh(\floating_point_typ x);
  constexpr float               coshf(float x);
  constexpr long double         coshl(long double x);

  constexpr \floating_point_typ sinh(\floating_point_typ x);
  constexpr float               sinhf(float x);
  constexpr long double         sinhl(long double x);

  constexpr \floating_point_typ tanh(\floating_point_typ x);
  constexpr float               tanhf(float x);
  constexpr long double         tanhl(long double x);

  constexpr \floating_point_typ exp(\floating_point_typ x);
  constexpr float               expf(float x);
  constexpr long double         expl(long double x);
\ins{
  constexpr \floating_point_typ exp10(\floating_point_typ x);
  constexpr float               exp10f(float x);
  constexpr long double         exp10l(long double x);
  
  constexpr \floating_point_typ exp10m1(\floating_point_typ x);
  constexpr float               exp10m1f(float x);
  constexpr long double         exp10m1l(long double x);}

  constexpr \floating_point_typ exp2(\floating_point_typ x);
  constexpr float               exp2f(float x);
  constexpr long double         exp2l(long double x);
\ins{
  constexpr \floating_point_typ exp2m1(\floating_point_typ x);
  constexpr float               exp2m1f(float x);
  constexpr long double         exp2m1l(long double x);}

  constexpr \floating_point_typ expm1(\floating_point_typ x);
  constexpr float               expm1f(float x);
  constexpr long double         expm1l(long double x);

  constexpr \floating_point_typ frexp(\floating_point_typ value, int* exp);
  constexpr float               frexpf(float value, int* exp);
  constexpr long double         frexpl(long double value, int* exp);

  constexpr int ilogb(\floating_point_typ x);
  constexpr int ilogbf(float x);
  constexpr int ilogbl(long double x);

  constexpr \floating_point_typ ldexp(\floating_point_typ x, int exp);
  constexpr float               ldexpf(float x, int exp);
  constexpr long double         ldexpl(long double x, int exp);

  constexpr \floating_point_typ log(\floating_point_typ x);
  constexpr float               logf(float x);
  constexpr long double         logl(long double x);

  constexpr \floating_point_typ log10(\floating_point_typ x);
  constexpr float               log10f(float x);
  constexpr long double         log10l(long double x);
\ins{
  constexpr \floating_point_typ log10p1(\floating_point_typ x);
  constexpr float               log10p1f(float x);
  constexpr long double         log10p1l(long double x);}

  constexpr \floating_point_typ log1p(\floating_point_typ x);
  constexpr float               log1pf(float x);
  constexpr long double         log1pl(long double x);
\ins{  
  constexpr \floating_point_typ logp1(\floating_point_typ x);
  constexpr float               logp1f(float x);
  constexpr long double         logp1l(long double x);}  

  constexpr \floating_point_typ log2(\floating_point_typ x);
  constexpr float               log2f(float x);
  constexpr long double         log2l(long double x);
\ins{
  constexpr \floating_point_typ log2p1(\floating_point_typ x);
  constexpr float               log2p1f(float x);
  constexpr long double         log2p1l(long double x);}

  constexpr \floating_point_typ logb(\floating_point_typ x);
  constexpr float               logbf(float x);
  constexpr long double         logbl(long double x);

  constexpr \floating_point_typ modf(\floating_point_typ value, \floating_point_typ* iptr);
  constexpr float               modff(float value, float* iptr);
  constexpr long double         modfl(long double value, long double* iptr);

  constexpr \floating_point_typ scalbn(\floating_point_typ x, int n);
  constexpr float               scalbnf(float x, int n);
  constexpr long double         scalbnl(long double x, int n);

  constexpr \floating_point_typ scalbln(\floating_point_typ x, long int n);
  constexpr float               scalblnf(float x, long int n);
  constexpr long double         scalblnl(long double x, long int n);

  constexpr \floating_point_typ cbrt(\floating_point_typ x);
  constexpr float               cbrtf(float x);
  constexpr long double         cbrtl(long double x);
\ins{
  constexpr \floating_point_typ compoundn(\floating_point_typ x, long long int n);
  constexpr float               compoundn(float x, long long int n);
  constexpr long double         compoundn(long double x, long long int n);}

  //\serif{ [c.math.abs], absolute values}
  constexpr int                 abs(int j);                             //\serif{ freestanding}
  constexpr long int            abs(long int j);                        //\serif{ freestanding}
  constexpr long long int       abs(long long int j);                   //\serif{ freestanding}
  constexpr \floating_point_typ abs(\floating_point_typ j);             //\serif{ freestanding-deleted}

  constexpr \floating_point_typ fabs(\floating_point_typ x);
  constexpr float               fabsf(float x);
  constexpr long double         fabsl(long double x);

  constexpr \floating_point_typ hypot(\floating_point_typ x, \floating_point_typ y);
  constexpr float               hypotf(float x, float y);
  constexpr long double         hypotl(long double x, long double y);

  //\serif{ [c.math.hypot3], three-dimensional hypotenuse}
  constexpr \floating_point_typ hypot(\floating_point_typ x, \floating_point_typ y,
                                      \floating_point_typ z);

  constexpr \floating_point_typ pow(\floating_point_typ x, \floating_point_typ y);
  constexpr float               powf(float x, float y);
  constexpr long double         powl(long double x, long double y);
\ins{
  constexpr \floating_point_typ pown(\floating_point_typ x, long long int n);
  constexpr float               pownf(float x, long long int n);
  constexpr long double         pownl(long double x, long long long int n);

  constexpr \floating_point_typ powr(\floating_point_typ x, \floating_point_typ y);
  constexpr float               powrf(float x, float y);
  constexpr long double         powrl(long double x, long double y);

  constexpr \floating_point_typ rootn(\floating_point_typ x);
  constexpr float               rootnf(float x);
  constexpr long double         rootnl(long double x);

  constexpr \floating_point_typ rsqrt(\floating_point_typ x);
  constexpr float               rsqrtf(float x);
  constexpr long double         rsqrtl(long double x);}

  constexpr \floating_point_typ sqrt(\floating_point_typ x);
  constexpr float               sqrtf(float x);
  constexpr long double         sqrtl(long double x);

  constexpr \floating_point_typ erf(\floating_point_typ x);
  constexpr float               erff(float x);
  constexpr long double         erfl(long double x);

  constexpr \floating_point_typ erfc(\floating_point_typ x);
  constexpr float               erfcf(float x);
  constexpr long double         erfcl(long double x);

  constexpr \floating_point_typ lgamma(\floating_point_typ x);
  constexpr float               lgammaf(float x);
  constexpr long double         lgammal(long double x);

  constexpr \floating_point_typ tgamma(\floating_point_typ x);
  constexpr float               tgammaf(float x);
  constexpr long double         tgammal(long double x);

  constexpr \floating_point_typ ceil(\floating_point_typ x);
  constexpr float               ceilf(float x);
  constexpr long double         ceill(long double x);

  constexpr \floating_point_typ floor(\floating_point_typ x);
  constexpr float               floorf(float x);
  constexpr long double         floorl(long double x);

  \floating_point_typ nearbyint(\floating_point_typ x);
  float               nearbyintf(float x);
  long double         nearbyintl(long double x);

  \floating_point_typ rint(\floating_point_typ x);
  float               rintf(float x);
  long double         rintl(long double x);

  long int lrint(\floating_point_typ x);
  long int lrintf(float x);
  long int lrintl(long double x);

  long long int llrint(\floating_point_typ x);
  long long int llrintf(float x);
  long long int llrintl(long double x);

  constexpr \floating_point_typ round(\floating_point_typ x);
  constexpr float               roundf(float x);
  constexpr long double         roundl(long double x);

  constexpr long int lround(\floating_point_typ x);
  constexpr long int lroundf(float x);
  constexpr long int lroundl(long double x);

  constexpr long long int llround(\floating_point_typ x);
  constexpr long long int llroundf(float x);
  constexpr long long int llroundl(long double x);
\ins{
  constexpr \floating_point_typ roundeven(\floating_point_typ x);
  constexpr float               roundevenf(float x);
  constexpr long double         roundevenl(long double x);}

  constexpr \floating_point_typ trunc(\floating_point_typ x);
  constexpr float               truncf(float x);
  constexpr long double         truncl(long double x);
\ins{
  constexpr \floating_point_typ fromfp(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               fromfpf(float x, int rnd, unsigned int width);
  constexpr long double         fromfpl(long double x, int rnd, unsigned int width);

  constexpr \floating_point_typ ufromfp(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               ufromfpf(float x, int rnd, unsigned int width);
  constexpr long double         ufromfpl(long double x, int rnd, unsigned int width);
  
  constexpr \floating_point_typ fromfpx(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               fromfpxf(float x, int rnd, unsigned int width);
  constexpr long double         fromfpxl(long double x, int rnd, unsigned int width);

  constexpr \floating_point_typ ufromfpx(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               ufromfpxf(float x, int rnd, unsigned int width);
  constexpr long double         ufromfpxl(long double x, int rnd, unsigned int width);}

  constexpr \floating_point_typ fmod(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmodf(float x, float y);
  constexpr long double         fmodl(long double x, long double y);

  constexpr \floating_point_typ remainder(\floating_point_typ x, \floating_point_typ y);
  constexpr float               remainderf(float x, float y);
  constexpr long double         remainderl(long double x, long double y);

  constexpr \floating_point_typ remquo(\floating_point_typ x, \floating_point_typ y, int* quo);
  constexpr float               remquof(float x, float y, int* quo);
  constexpr long double         remquol(long double x, long double y, int* quo);

  constexpr \floating_point_typ copysign(\floating_point_typ x, \floating_point_typ y);
  constexpr float               copysignf(float x, float y);
  constexpr long double         copysignl(long double x, long double y);

  double      nan(const char* tagp);
  float       nanf(const char* tagp);
  long double nanl(const char* tagp);

  constexpr \floating_point_typ nextafter(\floating_point_typ x, \floating_point_typ y);
  constexpr float               nextafterf(float x, float y);
  constexpr long double         nextafterl(long double x, long double y);

  constexpr \floating_point_typ nexttoward(\floating_point_typ x, long double y);
  constexpr float               nexttowardf(float x, long double y);
  constexpr long double         nexttowardl(long double x, long double y);

  constexpr \floating_point_typ nextup(\floating_point_typ x);
  constexpr float               nextupf(float x);
  constexpr long double         nextupl(long double x);

  constexpr \floating_point_typ nextdown(\floating_point_typ x);
  constexpr float               nextdownf(float x);
  constexpr long double         nextdownl(long double x);
\ins{
  constexpr bool canonicalize(\floating_point_typ* cx, const \floating_point_typ* x);
  constexpr bool canonicalizef(float cx, const float* x);
  constexpr bool canonicalizel(long double cx, const long double* x);}

  constexpr \floating_point_typ fdim(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fdimf(float x, float y);
  constexpr long double         fdiml(long double x, long double y);

  constexpr \floating_point_typ fmax(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmaxf(float x, float y);
  constexpr long double         fmaxl(long double x, long double y);

  constexpr \floating_point_typ fmin(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fminf(float x, float y);
  constexpr long double         fminl(long double x, long double y);

  constexpr \floating_point_typ fmaximum(\floating_point_typ x, \floating_point_typ y);
  constexpr \floating_point_typ fmaximum_num(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr \floating_point_typ fmaximum_mag(\floating_point_typ x, \floating_point_typ y);
  constexpr \floating_point_typ fmaximum_mag_num(\floating_point_typ x, \floating_point_typ y);
  }
  constexpr \floating_point_typ fminimum(\floating_point_typ x, \floating_point_typ y);
  constexpr \floating_point_typ fminimum_num(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr \floating_point_typ fminimum_mag(\floating_point_typ x, \floating_point_typ y);
  constexpr \floating_point_typ fminimum_mag_num(\floating_point_typ x, \floating_point_typ y);}

  constexpr \floating_point_typ fma(\floating_point_typ x, \floating_point_typ y,
                                    \floating_point_typ z);
  constexpr float               fmaf(float x, float y, float z);
  constexpr long double         fmal(long double x, long double y, long double z);

\ins{  //\serif{ [c.math.narrow], narrowing operations}
  template<class T, class F> constexpr T fadd(F x, F y) noexcept;
  constexpr float  fadd(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float  faddl(long double x, long double y);
  constexpr double dadd(long double x, long double y);
  constexpr double daddl(long double x, long double y);

  template<class T, class F> constexpr T fsub(F x, F y) noexcept;
  constexpr float  fsub(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float  fsubl(long double x, long double y);
  constexpr double dsub(long double x, long double y);
  constexpr double dsubl(long double x, long double y);

  template<class T, class F> constexpr T fmul(F x, F y) noexcept;
  constexpr float  fmul(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float  fmull(long double x, long double y);
  constexpr double dmul(long double x, long double y);
  constexpr double dmull(long double x, long double y);

  template<class T, class F> constexpr T fdiv(F x, F y) noexcept;
  constexpr float  fdiv(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float  fdivl(long double x, long double y);
  constexpr double ddiv(long double x, long double y);
  constexpr double ddivl(long double x, long double y);

  template<class T, class F> constexpr T ffma(F x, F y, F z) noexcept;
  constexpr float  ffma(\exposid{double-type} x, \exposid{double-type} y, \exposid{double-type} z);
  constexpr float  ffmal(long double x, long double y, long double z);
  constexpr double dfma(long double x, long double y, long double z);
  constexpr double dfmal(long double x, long double y, long double z);

  template<class T, class F> constexpr T fsqrt(F x) noexcept;
  constexpr float  fsqrt(\exposid{double-type} x);
  constexpr float  fsqrtl(long double x);
  constexpr double dsqrt(long double x);
  constexpr double dsqrtl(long double x);}

  //\serif{ [c.math.lerp], linear interpolation}
  constexpr \floating_point_typ lerp(\floating_point_typ a, \floating_point_typ b,
                                     \floating_point_typ t) noexcept;

  //\serif{ [c.math.fpclass], classification / comparison functions}
  constexpr int fpclassify(\floating_point_typ x);
\ins{  constexpr bool iscanonical(\floating_point_typ x);}
  constexpr bool isfinite(\floating_point_typ x);
  constexpr bool isinf(\floating_point_typ x);
  constexpr bool isnan(\floating_point_typ x);
  constexpr bool isnormal(\floating_point_typ x);
  constexpr bool signbit(\floating_point_typ x);
\ins{  constexpr bool issignaling(\floating_point_typ x);}
\ins{  constexpr bool issubnormal(\floating_point_typ x);}
\ins{  constexpr bool iszero(\floating_point_typ x);}
  constexpr bool isgreater(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isgreaterequal(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isless(\floating_point_typ x, \floating_point_typ y);
  constexpr bool islessequal(\floating_point_typ x, \floating_point_typ y);
  constexpr bool islessgreater(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isunordered(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr bool iseqsig(\floating_point_typ x, \floating_point_typ y);}

  //\serif{ [sf.cmath], mathematical special functions}

  \etc
}
}
}

Change \eelis{cmath.syn#1} as follows:

\Bdiff{
The contents and meaning of the header \header{cmath} are a subset of
the C standard library header \header{math.h}
and only the declarations shown in the synopsis above are present,
with the addition of
a three-dimensional hypotenuse function,
a linear interpolation function, and
the mathematical special functions described in \eelis{sf.cmath}.
}

Do \u{not} change \eelis{cmath.syn#2}:

\Bquote{
For each function with at least one parameter of type \tcode{\floating_point_typ},
the implementation provides an overload
for each cv-unqualified floating-point type\iref{basic.fundamental}
where all uses of \tcode{\floating_point_typ} in the function signature are replaced
with that floating-point type.
}

Insert a new paragraph immediately following \eelis{cmath.syn#2}:

\Bins{
For each function with at least one parameter of type \tcode{\exposid{double-type}},
the implementation provides an overload
for \tcode{double} and \tcode{long double}
where all uses of \tcode{\exposid{double-type}} in the function signature are replaced
with that floating-point type.
}

Insert a new items following that:

\Bins{
¶
Let \tcode{\exposid{common-floating-point-type}} and
\tcode{\exposid{common-double-type}}
be the following exposition-only alias templates:

\itemdecl{
template<class... Ts>
  using \exposid{common-floating-point-type} = \seebelow;
template<class... Ts>
  using \exposid{common-double-type} = \seebelow;
}

\itemdescr{
¶
\constraints
Each type in the pack \tcode{Ts} is a
cv-unqualified arithmetic type\iref{basic.fundamental}.

¶
Let \tcode{R} be defined as follows:
\ul{
  \li{
    For \tcode{\exposid{common-floating-point-type}},
    let \tcode{R} be the floating-point type with the
    greatest floating-point conversion rank and
    greatest floating-point conversion subrank among the types in \tcode{Ts},
    where integer types are considered to have
    the same floating-point conversion rank as \tcode{double}.
  }
  \li{
    For \tcode{\exposid{common-double-type}},
    let \tcode{R} be \tcode{long double} if any of the types in \tcode{Ts}
    is \tcode{long double}, and
    \tcode{double} otherwise.
  }
}

¶
\mandates
\tcode{R} is defined.

¶
\result
\tcode{R}.
}
}

\editnote{
\tcode{\exposid{common-floating-point-type}} is just following the existing
semantics of \eelis{cmath.syn#3} in the form of an exposition-only alias template.

\tcode{\exposid{common-double-type}} is meant to emulate
the behavior of the \header{tgmath.h} macros \tcode{fadd}, \tcode{fsub}, etc.

For \tcode{dadd}, \tcode{dsub}, etc. no such thing is necessary because without
decimal floating-point types,
the behavior is always to convert all arguments to \tcode{long double}.
}

Change \eelis{cmath.syn#3} as follows:

\Bdiff{
For each function with at least one parameter of type
\tcode{\floating_point_typ} \ins{or \tcode{\exposid{double-type}}}
other than \tcode{abs},
the implementation also provides additional overloads sufficient to ensure that,
if every argument corresponding to a
\tcode{\floating_point_typ} \ins{or \tcode{\exposid{double-type}}}
parameter has arithmetic type,
then every such argument is effectively cast to
\del{the floating-point type
with the greatest floating-point conversion rank and
greatest floating-point conversion subrank among the types of all such arguments,
where arguments of integer type are considered to have
the same floating-point conversion rank as \tcode{double}}
\ins{\tcode{\exposid{common-floating-point-type}<Args...>}
or \tcode{\exposid{common-double-type}<Args...>}}, respectively.
If \del{no such floating-point type with the greatest rank and subrank exists}
\ins{that specialization of the alias template is ill-formed},
then overload resolution does not result in a usable candidate\iref{over.match.general}
from the overloads provided by the implementation.
}

\h3(show-number=false){[c.math.narrow]}

Add a new subclause as follows:

\Bins{
\cowel_html_element(h3){Narrowing operations \stable_ref{c.math.narrow}}

\itemdecl{
constexpr float  f\placeholder{op}(long double x, long double y);
constexpr double d\placeholder{op}(long double x, long double y);
}

\itemdescr{
¶
Let \tcode{\placeholder{op}} be a placeholder for
\tcode{add}, \tcode{sub}, \tcode{mul}, \tcode{div}, \tcode{fma}, or \tcode{sqrt}.

¶
\effects
Each of the functions
\tcode{f\placeholder{op}} and \tcode{d\placeholder{op}}
has the same behavior as the functions
\tcode{f\placeholder{op}l} and \tcode{d\placeholder{op}l},
respectively.
}

\itemdecl{
template<class T, class F1, class F2>
  constexpr T fadd(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fsub(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fmul(F1 x, F2 y) noexcept;
template<class T, class F1>
  constexpr T fdiv(F1 x, F2 y) noexcept;
template<class T, class F1, class F2, class F3>
  constexpr T ffma(F1 x, F2 y, F3 z) noexcept;
template<class T, class F1>
  constexpr T fsqrt(F1 x) noexcept;
}

\itemdescr{
¶
Let \tcode{Fs} be the pack of template type parameters following \tcode{T}.
Let \tcode{F} be the type determined as follows:
\ul{
  \li{
    If \tcode{T} is \tcode{double} or
    if any type in \tcode{Fs} is \tcode{long double},
    \tcode{F} is \tcode{long double}.
  }
  \li{
    Otherwise, if \tcode{T} is \tcode{float},
    \tcode{F} is \tcode{double}.
  }
  \li{
    Otherwise, if \tcode{T} is an extended floating-point type
    named by the alias \tcode{std::float\placeholder{N}_t},
    \tcode{F} is the type named by \tcode{std::float\placeholder{M}_t},
    where \math{\mrow{\mi{M}\mo{=}\mi{N}\mo{×}\mn{2}}},
    if such a type exists.
  }
  \li{
    Otherwise, \tcode{F} is implementation-defined
    and may not exist.
  }
}

¶
\constraints
\ul{
  \li{Each type in \tcode{Fs} is a cv-unqualified arithmetic type.}
  \li{\tcode{F} exists.}
  \li{\tcode{T} is a cv-unqualified floating-point type.}
}
\example{
It is implementation-defined whether the constraints
of \tcode{fadd<bfloat16_t, float32_t>} are satisfied.
}

¶
\effects
All arguments are converted to \tcode{F}.
Each of the function templates has the same behavior as the corresponding
non-template overload with the same name,
except for the difference in return type and parameter types.

¶
\remarks
The \tcode{FP_FAST} macros also relate to specializations of these function templates.
\br\example{
\tcode{FP_FAST_DADDL} relates to \tcode{daddl} and \tcode{fadd<double, long double>}.
}
}
}

\h2{Acknowledgements}

Thanks to Hubert Tong for reviewing the library wording
and pointing out asymmetries with the behavior of \header{tgmath.h} macros.

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P3348R4,
  title = C++26 should refer to C23 not C17,
  date = 2025-06-19,
  author = Jonathan Wakely,
  link = https://wg21.link/p3348r4,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r4.pdf,
)\

\make_bib
