\cowel_include{libwg21.cow}

\wg21_head(
  title = Rebasing \tt{<cmath>} on C23
){
\dl{
  \dt{Document number:} \dd{\docnum{D3935R0}}
  \dt{Date:}            \dd{\tt{2025-12-03}}
  \dt{Audience:}        \dd{SG22}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3935/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/cmath-c23.cow)}
}
\hr
}

\Babstract{
Most of C++26 is based on C23, but the header \header{cmath}
is still based on C17.
There are many useful C23 \header{math.h} features that should be provided in C++.
}

\h2(listed=false){Contents}

\make_contents

\h2{Introduction}

\ref(P3348R4) rebased the C++26 standard on C23;
it previously referred to C17.
However, this process was deliberately left incomplete:
some of the new C23 \header{math.h} features are only used by decimal floating-point types,
or they require core language changes, etc.

The goal of this proposal is to pull in all the new C23 \header{math.h} features
which are useful not only to decimal floating-point numbers.

Introducing decimal floating-point numbers into C++ is out-of scope.
That is, adding C's \tcode{_Decimal128} type as a \tcode{std::decimal128_t} alias
is not proposed.
However, this proposal lays a bit of groundwork to make that happen in the future,
such as introducing the concept of canonical representations into the core language.

\h2{Design}

\h3{New functions}

The functions in the table below are proposed for inclusion in C++29.
The placeholder \tcode{\exposid{F}} is a shorthand for the
\tcode{\exposid{floating-point-type}} placeholder in \eelis{cmath.syn}.
In addition to the functions using an \tcode{\exposid{F}} placeholder,
single-type functions such as \tcode{float acospif(float)} are proposed,
but are not listed in the table for the sake of brevity;
refer to \ref(#wording) for the complete list.

\style{
  #new-functions {
    margin-left: auto;
    margin-right: auto;
  }
  #new-functions td {
    border-top: 1px solid var(--border-color);
  }
  #new-functions code {
    white-space: pre;
  }
}

\table(id=new-functions){
  \tr{
    \th{Function}
    \th{ISO/IEC 60559 op.}
    \th{Returns}
  }
  \tr{
    \td{\tcode{bool iscanonical(\exposid{F} x);}}
    \td{isCanonical}
    \td{
      \tcode{true} if and only if \tcode{x} is canonical
    }
  }
  \tr{
    \td{\tcode{bool issignaling(\exposid{F} x);}}
    \td{isSignaling}
    \td{
      \tcode{true} if and only if \tcode{x} is a signaling NaN
    }
  }
  \tr{
    \td{\tcode{bool issubnormal(\exposid{F} x);}}
    \td{isSubnormal}
    \td{
      \tcode{true} if and only if \tcode{x} is subnormal
    }
  }
  \tr{
    \td{\tcode{bool iszero(\exposid{F} x);}}
    \td{isZero}
    \td{
      \tcode{true} if and only if \tcode{x} is zero
    }
  }
  \tr{
    \td{\tcode{\exposid{F} acospi(\exposid{F} x);}}
    \td{acosPi}
    \td{
      \math{\mrow{
        \mrow{\mi{arccos}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval \math{\mrow{\mo{[}
        \mn{0}\mo{,}\mn{1}
      \mo{]}}}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} asinpi(\exposid{F} x);}}
    \td{asinPi}
    \td{
      \math{\mrow{
        \mrow{\mi{arcsin}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval \math{\mrow{
        \mo{[}
        \mo(form=prefix){−}\mfrac{\mn{1}\mn{2}}\mo{,}
        \mo(form=prefix){+}\mfrac{\mn{1}\mn{2}}\mo{]}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} atanpi(\exposid{F} x);}}
    \td{atanPi}
    \td{
      \math{\mrow{
        \mrow{\mi{arctan}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval \math{\mrow{\mo{[}
        \mo(form=prefix){−}\mfrac{\mn{1}\mn{2}}\mo{,}
        \mo(form=prefix){+}\mfrac{\mn{1}\mn{2}}
      \mo{]}}}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} atan2pi(\exposid{F} y, \exposid{F} x);}}
    \td{atan2Pi}
    \td{
      \math{\mrow{
        \mrow{\mi{atan2}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}
        \mo{÷}
        \mi{π}
      }}
      in the interval \math{\mrow{\mo{[}
        \mo(form=prefix){−}\mn{1}\mo{,}
        \mo(form=prefix){+}\mn{1}
      \mo{]}}}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} cospi(\exposid{F} x);}}
    \td{cosPi}
    \td{
      \math{\mrow{
        \mi{cos}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} sinpi(\exposid{F} x);}}
    \td{sinPi}
    \td{
      \math{\mrow{
        \mi{sin}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} tanpi(\exposid{F} x);}}
    \td{tanPi}
    \td{
      \math{\mrow{
        \mi{tan}\mo(stretchy=false){(}
        \mi{x}\mo{×}\mi{π}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp10(\exposid{F} x);}}
    \td{exp10}
    \td{
      \math{\msup{
        \mn{10}\mi{x}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp10m1(\exposid{F} x);}}
    \td{exp10m1}
    \td{
      \math{\mrow{
        \msup{\mn{10}\mi{x}}
        \mo{−}
        \mn{1}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} exp2m1(\exposid{F} x);}}
    \td{exp2m1}
    \td{
      \math{\mrow{
        \msup{\mn{2}\mi{x}}
        \mo{−}
        \mn{1}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} log10p1(\exposid{F} x);}}
    \td{log10p1}
    \td{
      \math{\mrow{
        \msub{\mi{log}\mn{10}}
        \mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} logp1(\exposid{F} x);}}
    \td{logp1}
    \td{
      \math{\mrow{
        \mi{log}\mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} log2p1(\exposid{F} x);}}
    \td{log2p1}
    \td{
      \math{\mrow{
        \msub{\mi{log}\mn{2}}
        \mo(stretchy=false){(}
        \mn{1}\mo{+}\mi{x}
        \mo(stretchy=false){)}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} compoundn(\exposid{F} x,
  long long n);}}
    \td{compound}
    \td{
      \math{\msup{
        \mrow{
          \mo(stretchy=false){(}
          \mn{1}\mo{+}\mi{x}
          \mo(stretchy=false){)}
        }
        \mi{n}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} pown(\exposid{F} x, long long n);}}
    \td{pown}
    \td{
      \math{\msup{
        \mi{x}
        \mi{n}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} powr(\exposid{F} y, \exposid{F} x);}}
    \td{powr}
    \td{
      \math{\msup{
        \mi{e}
        \mrow{
          \mi{y}
          \msub{\mo{log}\mi{e}}
          \mi{x}
        }
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} rootn(\exposid{F} x, long long n);}}
    \td{rootn}
    \td{
      \math{\msup{
        \mi{x}
        \mfrac{\mn{1}\mi{n}}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} rsqrt(\exposid{F} x);}}
    \td{rSqrt}
    \td{
      \math{\mfrac{
        \mn{1}
        \msqrt{\mi{x}}
      }}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} roundeven(\exposid{F} x);}}
    \td{roundToIntegralTiesToEven}
    \td{
      \tcode{x} rounded to the nearest integer,\br
      rounding halfway cases to even
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fromfp(\exposid{F} x, int rnd,
  unsigned width);}}
    \td{convertToInteger…}
    \td{
      \tcode{x} rounded to a signed \tcode{width}-bit integer,\br
      or NaN if \tcode{x} is not in range;\br
      \tcode{rnd} is the rounding mode
    }
  }
  \tr{
    \td{\tcode{\exposid{F} ufromfp(\exposid{F} x, int rnd,
  unsigned width);}}
    \td{convertToInteger…}
    \td{
      \tcode{x} rounded to an unsigned \tcode{width}-bit integer,\br
      or NaN if \tcode{x} is not in range;\br
      \tcode{rnd} is the rounding mode
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fromfpx(\exposid{F} x, int rnd,
  unsigned width);}}
    \td{convertToIntegerExact…}
    \td{
      \tcode{fromfp(x, rnd, width)};\br
      may also raise \tt{FE_INEXACT}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} ufromfpx(\exposid{F} x, int rnd,
  unsigned width);}}
    \td{convertToIntegerExact…}
    \td{
      \tcode{ufromfp(x, rnd, width)};\br
      may also raise \tt{FE_INEXACT}
    }
  }
  \tr{
    \td{\tcode{int canonicalize(
  \exposid{F}* cx, const \exposid{F}* x);}}
    \td{convertFormat (same format)}
    \td{
      zero if canonicalization succeeded,\br
      and nonzero value otherwise
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fmaximum_mag(\exposid{F} x, \exposid{F} y);}}
    \td{maximumMagnitude}
    \td{
      the value with greater magnitude,\br
      or \tcode{fmaximum(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fminimum_mag(\exposid{F} x, \exposid{F} y);}}
    \td{minimumMagnitude}
    \td{
      the value with greater magnitude,\br
      or \tcode{fminimum(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fmaximum_mag_num(\exposid{F} x, \exposid{F} y);}}
    \td{maximumMagnitudeNumber}
    \td{
      the value with greater magnitude,\br
      or \tcode{fmaximum_num(x, y)}
    }
  }
  \tr{
    \td{\tcode{\exposid{F} fminimum_mag_num(\exposid{F} x, \exposid{F} y);}}
    \td{minimumMagnitudeNumber}
    \td{
      the value with greater magnitude,\br
      or \tcode{fminimum_num(x, y)}
    }
  }
  \tr{
    \td{
      \tcode{float fadd(\exposid{F} x, \exposid{F} y);
double dadd(\exposid{F} x, \exposid{F} y);}
    }
    \td{addition}
    \td{
      \math{\mrow{\mi{x}\mo{+}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fsub(\exposid{F} x, \exposid{F} y);
double dsub(\exposid{F} x, \exposid{F} y);}
    }
    \td{subtraction}
    \td{
      \math{\mrow{\mi{x}\mo{−}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fmul(\exposid{F} x, \exposid{F} y);
double dmul(\exposid{F} x, \exposid{F} y);}
    }
    \td{multiplication}
    \td{
      \math{\mrow{\mi{x}\mo{×}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float fdiv(\exposid{F} x, \exposid{F} y);
double ddiv(\exposid{F} x, \exposid{F} y);}
    }
    \td{division}
    \td{
      \math{\mrow{\mi{x}\mo{÷}\mi{y}}}
    }
  }
  \tr{
    \td{
      \tcode{float ffma(\exposid{F} x, \exposid{F} y, \exposid{F} z);
double dfma(\exposid{F} x, \exposid{F} y, \exposid{F} z);}
    }
    \td{fusedMultiplyAdd}
    \td{
      \math{\mrow{
        \mo{(}\mi{x}\mo{×}\mi{y}\mo{)}
        \mo{+}\mi{z}
      }}
    }
  }
  \tr{
    \td{
      \tcode{float fsqrt(\exposid{F} x);
double dsqrt(\exposid{F} x);}
    }
    \td{squareRoot}
    \td{
      \math{\msqrt{\mi{x}}}
    }
  }
  \tr{
    \td{\tcode{bool iseqsig(\exposid{F} x, \exposid{F} y)}}
    \td{compareSignalingEqual}
    \td{
      \tcode{true} if \tcode{x} and \tcode{y} are equal and\br
      \tcode{false} otherwise
    }
  }
  \tr{
    \td{\tcode{bool totalorder(
  const \exposid{F}* x,
  const \exposid{F}* y);}}
    \td{totalOrder}
    \td{
      \tcode{true} if totalOrder(\tcode{*x}, \tcode{*y})
      is true,\br
      as per ISO/IEC 60559
    }
  }
  \tr{
    \td{\tcode{bool totalordermag(
  const \exposid{F}* x,
  const \exposid{F}* y);}}
    \td{totalOrderMag}
    \td{
      \tcode{true} if totalOrderMag(\tcode{*x}, \tcode{*y})
      is true,\br
      as per ISO/IEC 60559
    }
  }
  \tr{
    \td{\tcode{\exposid{F} getpayload(const \exposid{F}* x);}}
    \td{getPayload}
    \td{
      the NaN payload in \tcode{*x},\br
      or -1 if the \tcode{*x} is not a NaN
    }
  }
  \tr{
    \td{\tcode{int setpayload(
  \exposid{F}* res, \exposid{F} pl);}}
    \td{setPayload}
    \td{
      zero if the NaN payload in \tcode{*res} could be set,\br
      and nonzero value otherwise
    }
  }
  \tr{
    \td{\tcode{int setpayloadsig(
  \exposid{F}* res, \exposid{F} pl);}}
    \td{setPayloadSig}
    \td{
      same as \tcode{setpayload},\br
      but creates sNaN instead of qNan
    }
  }
}

\h4{Narrow rounding functions}

The narrow rounding functions (such as \tcode{fadd})
are unusually difficult to expose in C++ in a generic way.
Even the \header{tgmath.h} versions require the user to specify the return type
as a prefix (\tt{f}, \tt{d}, \tt{f32}, …) as part of the function name.
This is extremely hostile to generic code,
and also means there is no support for extended floating-types in C++
because we don't consider \tcode{std::float32_t} to be C23's \tcode{_Float32}
and to have \tcode{sqrtf32} and other functions that accept it.

To solve this, we can do something novel:
add function templates for these rounding functions:

\cppblock{
template<class T, class F1, class F2>
  constexpr T fadd(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fsub(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fmul(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fdiv(F1 x, F2 y) noexcept;
template<class T, class F1, class F2, class F3>
  constexpr T ffma(F1 x, F2 y, F3 z) noexcept;
template<class T, class F1>
  constexpr T fsqrt(F1 x) noexcept;
}

While the prefix \q{\tt{f}} is a bit inappropriate
(it it supposed to indicate a \tcode{float} return type),
there is no obvious alternative prefix,
\q{\tt{f}} definitely won't clash with future \header{math.h} functions,
and having no prefix at all would create undesirable overload sets with other functions.

The design goal for these functions is for the user to be able to write:
\cppblock{
#ifdef __cplusplus
  #define f32add(...) \cowel_highlight(cpp){::std::fadd<std::float32_t>(__VA_ARGS__)}
  // ...
#else
  #include <tgmath.h>
#endif
}

There is also a non-template \tcode{std::fadd} function
which is meant to emulate the behavior of the \header{tgmath.h} macro
by selecting between the \tcode{long double}→\tcode{float} and \tcode{double}→\tcode{float}
overloads.

\h4{Canonical floating-point representations and canonicalization}

C23 introduced the concept of "canonical representations"
identified by \tcode{iscanonical},
and a function \tcode{canonicalize}
to convert to canonical representations of the same value.

\Bex{
Examples of canonical/non-canonical representations include:
\ul{
  \li{
    Representations for decimal floating-point types are specified
    to be canonical or non-canonical by ISO/IEC 60559.
  }
  \li{Signaling NaN may be non-canonical, whereas quiet NaN may be canonical.}
  \li{
    An implementation that flushes subnormals to zero
    may consider all subnormal normals to be non-canonical representations of zero.
  }
  \li{
    Negative zero may be considered a non-canonical representation
    of positive zero, which is canonical.
  }
}
}

Unless working with decimal floating-point types,
the classification of representations as "canonical"
is largely based on the subjective preferences of the implementation;
there are no hard rules other than a canonical representation being unique.

\h3{New macros}

Besides the new functions,
there are also macros which are pulled in from C23.

\Bnote{
The \tcode{int rnd} parameter in functions such as \tcode{fromfp}
corresponds to one of \tt{FP_INT_*} rounding direction macros.
}

The block below lists all new macros:

\cppblock{
// rounding direction macros
FP_INT_UPWARD
FP_INT_DOWNWARD
FP_INT_TOWARDZERO
FP_INT_TONEARESTFROMZERO
FP_INT_TONEAREST

// indicates that the respective function is "fast"
FP_FAST_FADD
FP_FAST_FADDL
FP_FAST_DADDL
FP_FAST_FSUB
FP_FAST_FSUBL
FP_FAST_DSUBL
FP_FAST_FMUL
FP_FAST_FMULL
FP_FAST_DMULL
FP_FAST_FDIV
FP_FAST_FDIVL
FP_FAST_DDIVL
FP_FAST_FSQRT
FP_FAST_FSQRTL
FP_FAST_DSQRTL
FP_FAST_FFMA
FP_FAST_FFMAL
FP_FAST_DFMAL
}

\h2{Implementation experience}

All non-template additions are taken from C23,
and most have been implemented in gnulibc.

The new narrow rounding function templates simply dispatch to some
non-template overload based on the template argument \tcode{T}.

\h2{Wording}

The changes are relative to \ref(N5014).

\h3(show-number=false){[basic.fundamental]}

Immediately prior to \eelis{basic.fundamental#13},
insert a new paragraph:

\Bins{
An implementation may prefer particular representations of values
that have multiple representations in a floating-point type.
The preferred representations of a floating-point type,
including unique representations of values in the type, are called \dfn{canonical}.
A floating-point type may also contain \dfn{non-canonical representations},
for example, redundant representations of some or all its
values, or representations that are extraneous to the floating-point model.
Typically, floating-point operations deliver results with canonical representations.

\note{
The functions \tcode{std::iscanonical} and \tcode{std::canonicalize} distinguish
canonical (preferred) representations,
but this distinction alone does not imply that canonical and non-canonical representations
are of different values.
}
}

\editnote{
The C23 wording is extremely vague,
and we can't be precise either if we don't want to risk having diverging
behavior for \tcode{iscanonical}.

\tcode{iscanonical} and \tcode{canonicalize} are primarily motivated by
ISO/IEC 60559 decimal floating-point representations anyway,
where it is precisely specified which representations are canonical.
}

\h3(show-number=false){[version.syn]}

Add a feature-test macro to \eelis{version.syn} as follows:

\Bins{
\itemdecl{
#define __cpp_lib_cmath 20XXXXL //\serif{ also in \tt{<cmath>}, \tt{<cstdlib>}}
}
}

\editnote{
Although the proposal also adds a \tcode{__STDC_VERSION_MATH_H__} macro from C23,
this cannot be reliably used to detect the new functions;
it could have also been leaked through a \header{math.h} header from somewhere,
without e.g. \tcode{std::roundeven} actually existing.
}

\h3(show-number=false){[cmath.syn]}

\cowel_macro(floating_point_typ){\exposid{floating-point-type}}
\cowel_macro(optional){//\serif{ optional}}

\style{
h- {
  overflow: visible;
  display: inline-block;
}
}

\Bdiff{
\itemdecl{
\ins{#define __STDC_VERSION_MATH_H__ 202311L
        }
#define HUGE_VAL \seebelow
#define HUGE_VALF \seebelow
#define HUGE_VALL \seebelow
\ins{#define HUGE_VAL_F\placeholder{N} \seebelow \optional}
#define INFINITY \seebelow
#define NAN \seebelow
\ins{       }
#define FP_INFINITE \seebelow
#define FP_NAN \seebelow
#define FP_NORMAL \seebelow
#define FP_SUBNORMAL \seebelow
#define FP_ZERO \seebelow
\ins{       
#define FP_INT_UPWARD \seebelow
#define FP_INT_DOWNWARD \seebelow
#define FP_INT_TOWARDZERO \seebelow
#define FP_INT_TONEARESTFROMZERO \seebelow
#define FP_INT_TONEAREST \seebelow
        }
#define FP_FAST_FMA \seebelow
#define FP_FAST_FMAF \seebelow
#define FP_FAST_FMAL \seebelow
\ins{#define FP_FAST_FMAF\placeholder{N} \seebelow
#define FP_FAST_FADD \seebelow
#define FP_FAST_FADDL \seebelow
#define FP_FAST_DADDL \seebelow
#define FP_FAST_F\placeholder{M}ADD\placeholder{N} \seebelow
#define FP_FAST_FSUB \seebelow
#define FP_FAST_FSUBL \seebelow
#define FP_FAST_DSUBL \seebelow
#define FP_FAST_F\placeholder{M}SUB\placeholder{N} \seebelow
#define FP_FAST_FMUL \seebelow
#define FP_FAST_FMULL \seebelow
#define FP_FAST_DMULL \seebelow
#define FP_FAST_F\placeholder{M}MUL\placeholder{N} \seebelow
#define FP_FAST_FDIV \seebelow
#define FP_FAST_FDIVL \seebelow
#define FP_FAST_DDIVL \seebelow
#define FP_FAST_F\placeholder{M}DIV\placeholder{N} \seebelow
#define FP_FAST_FSQRT \seebelow
#define FP_FAST_FSQRTL \seebelow
#define FP_FAST_DSQRTL \seebelow
#define FP_FAST_F\placeholder{M}SQRT\placeholder{N} \seebelow
#define FP_FAST_FFMA \seebelow
#define FP_FAST_FFMAL \seebelow
#define FP_FAST_DFMAL \seebelow
#define FP_FAST_F\placeholder{M}FMA\placeholder{N} \seebelow
        }
#define FP_ILOGB0 \seebelow
#define FP_ILOGBNAN \seebelow
\ins{        }
#define MATH_ERRNO \seebelow
#define MATH_ERREXCEPT \seebelow

#define math_errhandling \seebelow

namespace std {
  using float_t = \seebelow;
  using double_t = \seebelow;
\ins{  using long_double_t = \seebelow;}

  constexpr \floating_point_typ acos(\floating_point_typ x);
  constexpr float               acosf(float x);
  constexpr long double         acosl(long double x);
\ins{  constexpr float\placeholder{N}_t            acosf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ asin(\floating_point_typ x);
  constexpr float               asinf(float x);
  constexpr long double         asinl(long double x);
\ins{  constexpr float\placeholder{N}_t            asinf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ atan(\floating_point_typ x);
  constexpr float               atanf(float x);
  constexpr long double         atanl(long double x);
\ins{  constexpr float\placeholder{N}_t            atanf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ atan2(\floating_point_typ y, \floating_point_typ x);
  constexpr float               atan2f(float y, float x);
  constexpr long double         atan2l(long double y, long double x);
\ins{  constexpr float\placeholder{N}_t            atan2f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ cos(\floating_point_typ x);
  constexpr float               cosf(float x);
  constexpr long double         cosl(long double x);
\ins{  constexpr float\placeholder{N}_t            cosf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ sin(\floating_point_typ x);
  constexpr float               sinf(float x);
  constexpr long double         sinl(long double x);
\ins{  constexpr float\placeholder{N}_t            sinf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ tan(\floating_point_typ x);
  constexpr float               tanf(float x);
  constexpr long double         tanl(long double x);
\ins{  constexpr float\placeholder{N}_t            tanf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ acospi(\floating_point_typ x);
  constexpr float               acospif(float x);
  constexpr long double         acospil(long double x);
  constexpr float\placeholder{N}_t            acospif\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ asinpi(\floating_point_typ x);
  constexpr float               asinpif(float x);
  constexpr long double         asinpil(long double x);
  constexpr float\placeholder{N}_t            asinpif\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ atanpi(\floating_point_typ x);
  constexpr float               atanpif(float x);
  constexpr long double         atanpil(long double x);
  constexpr float\placeholder{N}_t            atanf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ atan2pi(\floating_point_typ y, \floating_point_typ x);
  constexpr float               atan2pif(float y, float x);
  constexpr long double         atan2pil(long double y, long double x);
  constexpr float\placeholder{N}_t            atan2pif\placeholder{N}(float\placeholder{N}_t y, float\placeholder{N}_t x);
  
  constexpr \floating_point_typ cospi(\floating_point_typ x);
  constexpr float               cospif(float x);
  constexpr long double         cospil(long double x);
  constexpr float\placeholder{N}_t            cospif\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ sinpi(\floating_point_typ x);
  constexpr float               sinpif(float x);
  constexpr long double         sinpil(long double x);
  constexpr float\placeholder{N}_t            sinpif\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ tanpi(\floating_point_typ x);
  constexpr float               tanpif(float x);
  constexpr long double         tanpil(long double x);
  constexpr float\placeholder{N}_t            tanpif\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ acosh(\floating_point_typ x);
  constexpr float               acoshf(float x);
  constexpr long double         acoshl(long double x);
\ins{  constexpr float\placeholder{N}_t            acoshf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ asinh(\floating_point_typ x);
  constexpr float               asinhf(float x);
  constexpr long double         asinhl(long double x);
\ins{  constexpr float\placeholder{N}_t            asinhf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ atanh(\floating_point_typ x);
  constexpr float               atanhf(float x);
  constexpr long double         atanhl(long double x);
\ins{  constexpr float\placeholder{N}_t            atanhf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ cosh(\floating_point_typ x);
  constexpr float               coshf(float x);
  constexpr long double         coshl(long double x);
\ins{  constexpr float\placeholder{N}_t            coshf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ sinh(\floating_point_typ x);
  constexpr float               sinhf(float x);
  constexpr long double         sinhl(long double x);
\ins{  constexpr float\placeholder{N}_t            sinhf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ tanh(\floating_point_typ x);
  constexpr float               tanhf(float x);
  constexpr long double         tanhl(long double x);
\ins{  constexpr float\placeholder{N}_t            tanhf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ exp(\floating_point_typ x);
  constexpr float               expf(float x);
  constexpr long double         expl(long double x);
\ins{  constexpr float\placeholder{N}_t            expf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ exp10(\floating_point_typ x);
  constexpr float               exp10f(float x);
  constexpr long double         exp10l(long double x);
  constexpr float\placeholder{N}_t            exp10f\placeholder{N}(float\placeholder{N}_t x);
  
  constexpr \floating_point_typ exp10m1(\floating_point_typ x);
  constexpr float               exp10m1f(float x);
  constexpr long double         exp10m1l(long double x);
  constexpr float\placeholder{N}_t            exp10m1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ exp2(\floating_point_typ x);
  constexpr float               exp2f(float x);
  constexpr long double         exp2l(long double x);
\ins{  constexpr float\placeholder{N}_t            exp2f\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ exp2m1(\floating_point_typ x);
  constexpr float               exp2m1f(float x);
  constexpr long double         exp2m1l(long double x);
  constexpr float\placeholder{N}_t            exp2m1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ expm1(\floating_point_typ x);
  constexpr float               expm1f(float x);
  constexpr long double         expm1l(long double x);
\ins{  constexpr float\placeholder{N}_t            expm1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ frexp(\floating_point_typ value, int* exp);
  constexpr float               frexpf(float value, int* exp);
  constexpr long double         frexpl(long double value, int* exp);
\ins{  constexpr float\placeholder{N}_t            frexpf\placeholder{N}(float\placeholder{N}_t value, int* exp);}

  constexpr int ilogb(\floating_point_typ x);
  constexpr int ilogbf(float x);
  constexpr int ilogbl(long double x);
\ins{  constexpr int ilogb(float\placeholder{N}_t x);}

  constexpr \floating_point_typ ldexp(\floating_point_typ x, int exp);
  constexpr float               ldexpf(float x, int exp);
  constexpr long double         ldexpl(long double x, int exp);
\ins{  constexpr float\placeholder{N}_t            ldexpf\placeholder{N}(float\placeholder{N}_t x, int exp);}

  constexpr \floating_point_typ log(\floating_point_typ x);
  constexpr float               logf(float x);
  constexpr long double         logl(long double x);
\ins{  constexpr float\placeholder{N}_t            logf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ log10(\floating_point_typ x);
  constexpr float               log10f(float x);
  constexpr long double         log10l(long double x);
\ins{  constexpr float\placeholder{N}_t            log10f\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ log10p1(\floating_point_typ x);
  constexpr float               log10p1f(float x);
  constexpr long double         log10p1l(long double x);
  constexpr float\placeholder{N}_t            log10p1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ log1p(\floating_point_typ x);
  constexpr float               log1pf(float x);
  constexpr long double         log1pl(long double x);
\ins{  constexpr float\placeholder{N}_t            log1pf\placeholder{N}(float\placeholder{N}_t x);
  
  constexpr \floating_point_typ logp1(\floating_point_typ x);
  constexpr float               logp1f(float x);
  constexpr long double         logp1l(long double x);
  constexpr float\placeholder{N}_t            logp1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ log2(\floating_point_typ x);
  constexpr float               log2f(float x);
  constexpr long double         log2l(long double x);
\ins{  constexpr float\placeholder{N}_t            log2f\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ log2p1(\floating_point_typ x);
  constexpr float               log2p1f(float x);
  constexpr long double         log2p1l(long double x);
  constexpr float\placeholder{N}_t            log2p1f\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ logb(\floating_point_typ x);
  constexpr float               logbf(float x);
  constexpr long double         logbl(long double x);
\ins{  constexpr float\placeholder{N}_t            logbf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ modf(\floating_point_typ value, \floating_point_typ* iptr);
  constexpr float               modff(float value, float* iptr);
  constexpr long double         modfl(long double value, long double* iptr);
\ins{  constexpr float\placeholder{N}_t            modf\placeholder{N}(float\placeholder{N}_t value, float\placeholder{N}_t* iptr);}

  constexpr \floating_point_typ scalbn(\floating_point_typ x, int n);
  constexpr float               scalbnf(float x, int n);
  constexpr long double         scalbnl(long double x, int n);
\ins{  constexpr float\placeholder{N}_t            scalbnf\placeholder{N}(float\placeholder{N}_t x, int n);}

  constexpr \floating_point_typ scalbln(\floating_point_typ x, long int n);
  constexpr float               scalblnf(float x, long int n);
  constexpr long double         scalblnl(long double x, long int n);
\ins{  constexpr float\placeholder{N}_t            scalblnf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ cbrt(\floating_point_typ x);
  constexpr float               cbrtf(float x);
  constexpr long double         cbrtl(long double x);
\ins{  constexpr float\placeholder{N}_t            cbrtf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ compoundn(\floating_point_typ x, long long int n);
  constexpr float               compoundn(float x, long long int n);
  constexpr long double         compoundn(long double x, long long int n);
  constexpr float\placeholder{N}_t            compoundnf\placeholder{N}(float\placeholder{N}_t x, long long n);}

  //\serif{ [c.math.abs], absolute values}
  constexpr int                 abs(int j);                             //\serif{ freestanding}
  constexpr long int            abs(long int j);                        //\serif{ freestanding}
  constexpr long long int       abs(long long int j);                   //\serif{ freestanding}
  constexpr \floating_point_typ abs(\floating_point_typ j);             //\serif{ freestanding-deleted}

  constexpr \floating_point_typ fabs(\floating_point_typ x);
  constexpr float               fabsf(float x);
  constexpr long double         fabsl(long double x);
\ins{  constexpr float\placeholder{N}_t            fabsf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ hypot(\floating_point_typ x, \floating_point_typ y);
  constexpr float               hypotf(float x, float y);
  constexpr long double         hypotl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            hypotf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  //\serif{ [c.math.hypot3], three-dimensional hypotenuse}
  constexpr \floating_point_typ hypot(\floating_point_typ x, \floating_point_typ y,
                                      \floating_point_typ z);

  constexpr \floating_point_typ pow(\floating_point_typ x, \floating_point_typ y);
  constexpr float               powf(float x, float y);
  constexpr long double         powl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            powf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ pown(\floating_point_typ x, long long int n);
  constexpr float               pownf(float x, long long int n);
  constexpr long double         pownl(long double x, long long long int n);
  constexpr float\placeholder{N}_t            pownf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ powr(\floating_point_typ x, \floating_point_typ y);
  constexpr float               powrf(float x, float y);
  constexpr long double         powrl(long double x, long double y);
  constexpr float\placeholder{N}_t            powrf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ rootn(\floating_point_typ x, long long int n);
  constexpr float               rootnf(float x, long long int n);
  constexpr long double         rootnl(long double x, long long int n);
  constexpr float\placeholder{N}_t            rootf\placeholder{N}(float\placeholder{N}_t x, long long int n);

  constexpr \floating_point_typ rsqrt(\floating_point_typ x);
  constexpr float               rsqrtf(float x);
  constexpr long double         rsqrtl(long double x);
  constexpr float\placeholder{N}_t            rsqrtf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ sqrt(\floating_point_typ x);
  constexpr float               sqrtf(float x);
  constexpr long double         sqrtl(long double x);
\ins{  constexpr float\placeholder{N}_t            sqrtf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ erf(\floating_point_typ x);
  constexpr float               erff(float x);
  constexpr long double         erfl(long double x);
\ins{  constexpr float\placeholder{N}_t            erff\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ erfc(\floating_point_typ x);
  constexpr float               erfcf(float x);
  constexpr long double         erfcl(long double x);
\ins{  constexpr float\placeholder{N}_t            erfcf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ lgamma(\floating_point_typ x);
  constexpr float               lgammaf(float x);
  constexpr long double         lgammal(long double x);
\ins{  constexpr float\placeholder{N}_t            lgammaf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ tgamma(\floating_point_typ x);
  constexpr float               tgammaf(float x);
  constexpr long double         tgammal(long double x);
\ins{  constexpr float\placeholder{N}_t            tgammaf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ ceil(\floating_point_typ x);
  constexpr float               ceilf(float x);
  constexpr long double         ceill(long double x);
\ins{  constexpr float\placeholder{N}_t            ceilf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ floor(\floating_point_typ x);
  constexpr float               floorf(float x);
  constexpr long double         floorl(long double x);
\ins{  constexpr float\placeholder{N}_t            floorf\placeholder{N}(float\placeholder{N}_t x);}

  \floating_point_typ nearbyint(\floating_point_typ x);
  float               nearbyintf(float x);
  long double         nearbyintl(long double x);
\ins{  float\placeholder{N}_t            nearbyintf\placeholder{N}(float\placeholder{N}_t x);}

  \floating_point_typ rint(\floating_point_typ x);
  float               rintf(float x);
  long double         rintl(long double x);
\ins{  float\placeholder{N}_t            rintf\placeholder{N}(float\placeholder{N}_t x);}

  long int lrint(\floating_point_typ x);
  long int lrintf(float x);
  long int lrintl(long double x);
\ins{  long int lrintf\placeholder{N}(float\placeholder{N}_t x);}

  long long int llrint(\floating_point_typ x);
  long long int llrintf(float x);
  long long int llrintl(long double x);
\ins{  long long int llrintf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ round(\floating_point_typ x);
  constexpr float               roundf(float x);
  constexpr long double         roundl(long double x);
\ins{  constexpr float\placeholder{N}_t            roundf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr long int lround(\floating_point_typ x);
  constexpr long int lroundf(float x);
  constexpr long int lroundl(long double x);
\ins{  constexpr long int lroundf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr long long int llround(\floating_point_typ x);
  constexpr long long int llroundf(float x);
  constexpr long long int llroundl(long double x);
\ins{  constexpr long long int llroundf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ roundeven(\floating_point_typ x);
  constexpr float               roundevenf(float x);
  constexpr long double         roundevenl(long double x);
  constexpr float\placeholder{N}_t            roundevenf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ trunc(\floating_point_typ x);
  constexpr float               truncf(float x);
  constexpr long double         truncl(long double x);
\ins{  constexpr float\placeholder{N}_t            truncf\placeholder{N}(float\placeholder{N}_t x);

  constexpr \floating_point_typ fromfp(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               fromfpf(float x, int rnd, unsigned int width);
  constexpr long double         fromfpl(long double x, int rnd, unsigned int width);
  constexpr float\placeholder{N}_t            fromfpf\placeholder{N}(float\placeholder{N}_t x, int rnd, unsigned int width);

  constexpr \floating_point_typ ufromfp(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               ufromfpf(float x, int rnd, unsigned int width);
  constexpr long double         ufromfpl(long double x, int rnd, unsigned int width);
  constexpr float\placeholder{N}_t            ufromfpf\placeholder{N}(float\placeholder{N}_t x, int rnd, unsigned int width);
  
  constexpr \floating_point_typ fromfpx(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               fromfpxf(float x, int rnd, unsigned int width);
  constexpr long double         fromfpxl(long double x, int rnd, unsigned int width);
  constexpr float\placeholder{N}_t            fromfpxf\placeholder{N}(float\placeholder{N}_t x, int rnd, unsigned int width);

  constexpr \floating_point_typ ufromfpx(\floating_point_typ x, int rnd, unsigned int width);
  constexpr float               ufromfpxf(float x, int rnd, unsigned int width);
  constexpr long double         ufromfpxl(long double x, int rnd, unsigned int width);
  constexpr float\placeholder{N}_t            ufromfpxf\placeholder{N}(float\placeholder{N}_t x, int rnd, unsigned int width);}

  constexpr \floating_point_typ fmod(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmodf(float x, float y);
  constexpr long double         fmodl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            fmodf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ remainder(\floating_point_typ x, \floating_point_typ y);
  constexpr float               remainderf(float x, float y);
  constexpr long double         remainderl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            remainderf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ remquo(\floating_point_typ x, \floating_point_typ y, int* quo);
  constexpr float               remquof(float x, float y, int* quo);
  constexpr long double         remquol(long double x, long double y, int* quo);
\ins{  constexpr float\placeholder{N}_t            remquof\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t, int* quo);}

  constexpr \floating_point_typ copysign(\floating_point_typ x, \floating_point_typ y);
  constexpr float               copysignf(float x, float y);
  constexpr long double         copysignl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            copysignf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  double      nan(const char* tagp);
  float       nanf(const char* tagp);
  long double nanl(const char* tagp);
\ins{  float\placeholder{N}_t    nanf\placeholder{N}(const char* tagp);}

  constexpr \floating_point_typ nextafter(\floating_point_typ x, \floating_point_typ y);
  constexpr float               nextafterf(float x, float y);
  constexpr long double         nextafterl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            nextafterf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ nexttoward(\floating_point_typ x, long double y);
  constexpr float               nexttowardf(float x, long double y);
  constexpr long double         nexttowardl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            nexttowardf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ nextup(\floating_point_typ x);
  constexpr float               nextupf(float x);
  constexpr long double         nextupl(long double x);
\ins{  constexpr float\placeholder{N}_t            nextupf\placeholder{N}(float\placeholder{N}_t x);}

  constexpr \floating_point_typ nextdown(\floating_point_typ x);
  constexpr float               nextdownf(float x);
  constexpr long double         nextdownl(long double x);
\ins{  constexpr float\placeholder{N}_t            nextdownf\placeholder{N}(float\placeholder{N}_t x);

  constexpr int canonicalize(\floating_point_typ* cx, const \floating_point_typ* x);
  constexpr int canonicalizef(float cx, const float* x);
  constexpr int canonicalizel(long double cx, const long double* x);
  constexpr int canonicalizef\placeholder{N}(float\placeholder{N}_t* cx, const float\placeholder{N}_t* x);}

  constexpr \floating_point_typ fdim(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fdimf(float x, float y);
  constexpr long double         fdiml(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            fdimf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fmax(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmaxf(float x, float y);
  constexpr long double         fmaxl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            fmaxf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fmin(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fminf(float x, float y);
  constexpr long double         fminl(long double x, long double y);
\ins{  constexpr float\placeholder{N}_t            fminf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fmaximum(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr float               fmaximumf(float x, float y);
  constexpr long double         fmaximuml(long double x, long double y);
  constexpr float\placeholder{N}_t            fmaximumf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fmaximum_num(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr float               fmaximum_numf(float x, float y);
  constexpr long double         fmaximum_numl(long double x, long double y);
  constexpr float\placeholder{N}_t            fmaximum_numf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ fmaximum_mag(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmaximum_magf(float x, float y);
  constexpr long double         fmaximum_magl(long double x, long double y);
  constexpr float\placeholder{N}_t            fmaximum_magf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ fmaximum_mag_num(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmaximum_mag_numf(float x, float y);
  constexpr long double         fmaximum_mag_numl(long double x, long double y);
  constexpr float\placeholder{N}_t            fmaximum_mag_numf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);
  }
  constexpr \floating_point_typ fminimum(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr float               fminimumf(float x, float y);
  constexpr long double         fminimuml(long double x, long double y);
  constexpr float\placeholder{N}_t            fminimumf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fminimum_num(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr float               fminimum_numf(float x, float y);
  constexpr long double         fminimum_numl(long double x, long double y);
  constexpr float\placeholder{N}_t            fminimum_numf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ fminimum_mag(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fminimum_magf(float x, float y);
  constexpr long double         fminimum_magl(long double x, long double y);
  constexpr float\placeholder{N}_t            fminimum_magf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);

  constexpr \floating_point_typ fminimum_mag_num(\floating_point_typ x, \floating_point_typ y);
  constexpr float               fmaximum_mag_numf(float x, float y);
  constexpr long double         fmaximum_mag_numl(long double x, long double y);
  constexpr float\placeholder{N}_t            fmaximum_mag_numf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  constexpr \floating_point_typ fma(\floating_point_typ x, \floating_point_typ y,
                                    \floating_point_typ z);
  constexpr float               fmaf(float x, float y, float z);
  constexpr long double         fmal(long double x, long double y, long double z);
\ins{  constexpr float\placeholder{N}_t            fmaf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y, float\placeholder{N}_t z);

  //\serif{ [c.math.narrow], narrowing operations}
  template<class T, class F> constexpr T fadd(F x, F y) noexcept;
  constexpr float      fadd(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float      faddl(long double x, long double y);
  constexpr double     dadd(long double x, long double y);
  constexpr double     daddl(long double x, long double y);
  constexpr float\placeholder{N}_t   f\placeholder{N}add(\seebelow x, \seebelow y);

  template<class T, class F> constexpr T fsub(F x, F y) noexcept;
  constexpr float      fsub(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float      fsubl(long double x, long double y);
  constexpr double     dsub(long double x, long double y);
  constexpr double     dsubl(long double x, long double y);
  constexpr float\placeholder{N}_t   f\placeholder{N}sub(\seebelow x, \seebelow y);

  template<class T, class F> constexpr T fmul(F x, F y) noexcept;
  constexpr float      fmul(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float      fmull(long double x, long double y);
  constexpr double     dmul(long double x, long double y);
  constexpr double     dmull(long double x, long double y);
  constexpr float\placeholder{N}_t   f\placeholder{N}mul(\seebelow x, \seebelow y);

  template<class T, class F> constexpr T fdiv(F x, F y) noexcept;
  constexpr float      fdiv(\exposid{double-type} x, \exposid{double-type} y);
  constexpr float      fdivl(long double x, long double y);
  constexpr double     ddiv(long double x, long double y);
  constexpr double     ddivl(long double x, long double y);
  constexpr float\placeholder{N}_t   f\placeholder{N}div(\seebelow x, \seebelow y);

  template<class T, class F> constexpr T ffma(F x, F y, F z) noexcept;
  constexpr float      ffma(\exposid{double-type} x, \exposid{double-type} y, \exposid{double-type} z);
  constexpr float      ffmal(long double x, long double y, long double z);
  constexpr double     dfma(long double x, long double y, long double z);
  constexpr double     dfmal(long double x, long double y, long double z);
  constexpr float\placeholder{N}_t   f\placeholder{N}fma(\seebelow x, \seebelow y, \seebelow z);

  template<class T, class F> constexpr T fsqrt(F x) noexcept;
  constexpr float      fsqrt(\exposid{double-type} x);
  constexpr float      fsqrtl(long double x);
  constexpr double     dsqrt(long double x);
  constexpr double     dsqrtl(long double x);
  constexpr float\placeholder{N}_t   f\placeholder{N}sqrt(\seebelow x);}

  //\serif{ [c.math.lerp], linear interpolation}
  constexpr \floating_point_typ lerp(\floating_point_typ a, \floating_point_typ b,
                                     \floating_point_typ t) noexcept;

  //\serif{ [c.math.fpclass], classification / comparison functions}
  constexpr int fpclassify(\floating_point_typ x);
\ins{  constexpr bool iscanonical(\floating_point_typ x);}
  constexpr bool isfinite(\floating_point_typ x);
  constexpr bool isinf(\floating_point_typ x);
  constexpr bool isnan(\floating_point_typ x);
  constexpr bool isnormal(\floating_point_typ x);
  constexpr bool signbit(\floating_point_typ x);
\ins{  constexpr bool issignaling(\floating_point_typ x);}
\ins{  constexpr bool issubnormal(\floating_point_typ x);}
\ins{  constexpr bool iszero(\floating_point_typ x);}
  constexpr bool isgreater(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isgreaterequal(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isless(\floating_point_typ x, \floating_point_typ y);
  constexpr bool islessequal(\floating_point_typ x, \floating_point_typ y);
  constexpr bool islessgreater(\floating_point_typ x, \floating_point_typ y);
  constexpr bool isunordered(\floating_point_typ x, \floating_point_typ y);
\ins{  constexpr bool iseqsig(\floating_point_typ x, \floating_point_typ y);

  //\serif{ ISO/IEC 60559 specific functions}
  constexpr bool totalorder(const \floating_point_typ* x, const \floating_point_typ* y);
  constexpr bool totalorderf(const float* x, const float* y);
  constexpr bool totalorderl(const long double* x, const long double* y);
  constexpr bool totalorderf\placeholder{N}(const float\placeholder{N}_t* x, float\placeholder{N}_t* y);

  constexpr bool totalordermag(const \floating_point_typ* x, const \floating_point_typ* y);
  constexpr bool totalordermagf(const float* x, const float* y);
  constexpr bool totalordermagl(const long double* x, const long double* y);
  constexpr bool totalordermagf\placeholder{N}(const float\placeholder{N}_t* x, float\placeholder{N}_t* y);

  constexpr \floating_point_typ getpayload(const \floating_point_typ* x);
  constexpr float               getpayloadf(const float* x);
  constexpr long double         getpayloadl(const long double* x);
  constexpr float\placeholder{N}_t            getpayloadf\placeholder{N}(const float\placeholder{N}_t* x);

  constexpr int setpayload(\floating_point_typ* res, \floating_point_typ pl);
  constexpr int setpayloadf(float* res, float pl);
  constexpr int setpayloadl(long double* res, long double pl);
  constexpr int setpayloadf\placeholder{N}(float\placeholder{N}_t* res, float\placeholder{N}_t pl);}

  //\serif{ [sf.cmath], mathematical special functions}

  //\serif{ [sf.cmath.assoc.laguerre], associated Laguerre polynomials}
  \floating_point_typ assoc_laguerre(unsigned n, unsigned m, \floating_point_typ x);
  float               assoc_laguerref(unsigned n, unsigned m, float x);
  long double         assoc_laguerrel(unsigned n, unsigned m, long double x);
\ins{  float\placeholder{N}_t            assoc_laguerref\placeholder{N}(unsigned n, unsigned m, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.assoc.legendre], associated Legendre functions}
  \floating_point_typ assoc_legendre(unsigned l, unsigned m, \floating_point_typ x);
  float               assoc_legendref(unsigned l, unsigned m, float x);
  long double         assoc_legendrel(unsigned l, unsigned m, long double x);
\ins{  float\placeholder{N}_t            assoc_legendref\placeholder{N}(unsigned l, unsigned m, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.beta], beta function}
  \floating_point_typ beta(\floating_point_typ x, \floating_point_typ y);
  float               betaf(float x, float y);
  long double         betal(long double x, long double y);
\ins{  float\placeholder{N}_t            betaf\placeholder{N}(float\placeholder{N}_t x, float\placeholder{N}_t y);}

  //\serif{ [sf.cmath.comp.ellint.1], complete elliptic integral of the first kind}
  \floating_point_typ comp_ellint_1(\floating_point_typ k);
  float               comp_ellint_1f(float k);
  long double         comp_ellint_1l(long double k);
\ins{  float\placeholder{N}_t            comp_ellint_1f\placeholder{N}(float\placeholder{N}_t k);}

  //\serif{ [sf.cmath.comp.ellint.2], complete elliptic integral of the second kind}
  \floating_point_typ comp_ellint_2(\floating_point_typ k);
  float               comp_ellint_2f(float k);
  long double         comp_ellint_2l(long double k);
\ins{  float\placeholder{N}_t            comp_ellint_2f\placeholder{N}(float\placeholder{N}_t k);}

  //\serif{ [sf.cmath.comp.ellint.3], complete elliptic integral of the third kind}
  \floating_point_typ comp_ellint_3(\floating_point_typ k, \floating_point_typ nu);
  float               comp_ellint_3f(float k, float nu);
  long double         comp_ellint_3l(long double k, long double nu);
\ins{  float\placeholder{N}_t            comp_ellint_3f\placeholder{N}(float\placeholder{N}_t k, float\placeholder{N}_t nu);}

  //\serif{ [sf.cmath.cyl.bessel.i], regular modified cylindrical Bessel functions}
  \floating_point_typ cyl_bessel_i(\floating_point_typ nu, \floating_point_typ x);
  float               cyl_bessel_if(float nu, float x);
  long double         cyl_bessel_il(long double nu, long double x);
\ins{  float\placeholder{N}_t            cyl_bessel_if\placeholder{N}(float\placeholder{N}_t nu, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.cyl.bessel.j], cylindrical Bessel functions of the first kind}
  \floating_point_typ cyl_bessel_j(\floating_point_typ nu, \floating_point_typ x);
  float               cyl_bessel_jf(float nu, float x);
  long double         cyl_bessel_jl(long double nu, long double x);
\ins{  float\placeholder{N}_t            cyl_bessel_jf\placeholder{N}(float\placeholder{N}_t nu, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.cyl.bessel.k], irregular modified cylindrical Bessel functions}
  \floating_point_typ cyl_bessel_k(\floating_point_typ nu, \floating_point_typ x);
  float               cyl_bessel_kf(float nu, float x);
  long double         cyl_bessel_kl(long double nu, long double x);
\ins{  float\placeholder{N}_t            cyl_bessel_kf\placeholder{N}(float\placeholder{N}_t nu, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.cyl.neumann], cylindrical Neumann functions}
  // cylindrical Bessel functions of the second kind
  \floating_point_typ cyl_neumann(\floating_point_typ nu, \floating_point_typ x);
  float               cyl_neumannf(float nu, float x);
  long double         cyl_neumannl(long double nu, long double x);
\ins{  float\placeholder{N}_t            cyl_neumannf\placeholder{N}(float\placeholder{N}_t nu, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.ellint.1], incomplete elliptic integral of the first kind}
  \floating_point_typ ellint_1(\floating_point_typ k, \floating_point_typ phi);
  float               ellint_1f(float k, float phi);
  long double         ellint_1l(long double k, long double phi);
\ins{  float\placeholder{N}_t            ellint_1f\placeholder{N}(float\placeholder{N}_t k, float\placeholder{N}_t phi);}

  //\serif{ [sf.cmath.ellint.2], incomplete elliptic integral of the second kind}
  \floating_point_typ ellint_2(\floating_point_typ k, \floating_point_typ phi);
  float               ellint_2f(float k, float phi);
  long double         ellint_2l(long double k, long double phi);
\ins{  float\placeholder{N}_t            ellint_2f\placeholder{N}(float\placeholder{N}_t k, float\placeholder{N}_t phi);}

  //\serif{ [sf.cmath.ellint.3], incomplete elliptic integral of the third kind}
  \floating_point_typ ellint_3(\floating_point_typ k, \floating_point_typ nu,
                               \floating_point_typ phi);
  float               ellint_3f(float k, float nu, float phi);
  long double         ellint_3l(long double k, long double nu, long double phi);
\ins{  float\placeholder{N}_t            ellint_3f\placeholder{N}(float\placeholder{N}_t k, float\placeholder{N}_t nu, float\placeholder{N}_t phi);}

  //\serif{ [sf.cmath.expint], exponential integral}
  \floating_point_typ expint(\floating_point_typ x);
  float               expintf(float x);
  long double         expintl(long double x);
\ins{  float\placeholder{N}_t            expintf\placeholder{N}(float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.hermite], Hermite polynomials}
  \floating_point_typ hermite(unsigned n, \floating_point_typ x);
  float               hermitef(unsigned n, float x);
  long double         hermitel(unsigned n, long double x);
\ins{  float\placeholder{N}_t            hermitef\placeholder{N}(unsigned n, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.laguerre], Laguerre polynomials}
  \floating_point_typ laguerre(unsigned n, \floating_point_typ x);
  float               laguerref(unsigned n, float x);
  long double         laguerrel(unsigned n, long double x);
\ins{  float\placeholder{N}_t            laguerref\placeholder{N}(unsigned n, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.legendre], Legendre polynomials}
  \floating_point_typ legendre(unsigned l, \floating_point_typ x);
  float               legendref(unsigned l, float x);
  long double         legendrel(unsigned l, long double x);
\ins{  float\placeholder{N}_t            legendref\placeholder{N}(unsigned l, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.riemann.zeta], Riemann zeta function}
  \floating_point_typ riemann_zeta(\floating_point_typ x);
  float               riemann_zetaf(float x);
  long double         riemann_zetal(long double x);
\ins{  float\placeholder{N}_t            riemann_zetaf\placeholder{N}(float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.sph.bessel], spherical Bessel functions of the first kind}
  \floating_point_typ sph_bessel(unsigned n, \floating_point_typ x);
  float               sph_besself(unsigned n, float x);
  long double         sph_bessell(unsigned n, long double x);
\ins{  float\placeholder{N}_t            sph_besself\placeholder{N}(unsigned n, float\placeholder{N}_t x);}

  //\serif{ [sf.cmath.sph.legendre], spherical associated Legendre functions}
  \floating_point_typ sph_legendre(unsigned l, unsigned m, \floating_point_typ theta);
  float               sph_legendref(unsigned l, unsigned m, float theta);
  long double         sph_legendrel(unsigned l, unsigned m, long double theta);
\ins{  float\placeholder{N}_t            sph_legendref\placeholder{N}(unsigned l, unsigned m, float\placeholder{N}_t theta);}

  //\serif{ [sf.cmath.sph.neumann], spherical Neumann functions;}
  //\serif{ spherical Bessel functions of the second kind}
  \floating_point_typ sph_neumann(unsigned n, \floating_point_typ x);
  float               sph_neumannf(unsigned n, float x);
  long double         sph_neumannl(unsigned n, long double x);
\ins{  float\placeholder{N}_t            sph_neumannf\placeholder{N}(unsigned n, float\placeholder{N}_t x);}
}
}
}

Change \eelis{cmath.syn#1} as follows:

\Bdiff{
The contents and meaning of the header \header{cmath} are a subset of
the C standard library header \header{math.h}
and only the declarations shown in the synopsis above are present,
with the addition of
a three-dimensional hypotenuse function,
a linear interpolation function, and
the mathematical special functions described in \eelis{sf.cmath}.
}

Do \u{not} change \eelis{cmath.syn#2}:

\Bquote{
For each function with at least one parameter of type \tcode{\floating_point_typ},
the implementation provides an overload
for each cv-unqualified floating-point type\iref{basic.fundamental}
where all uses of \tcode{\floating_point_typ} in the function signature are replaced
with that floating-point type.
}

Insert a new paragraph immediately following \eelis{cmath.syn#2}:

\Bins{
For each function with at least one parameter of type \tcode{\exposid{double-type}},
the implementation provides an overload
for \tcode{double} and \tcode{long double}
where all uses of \tcode{\exposid{double-type}} in the function signature are replaced
with that floating-point type.
}

Insert a new items following that:

\Bins{
¶
Let \tcode{\exposid{common-floating-point-type}} and
\tcode{\exposid{common-double-type}}
be the following exposition-only alias templates:

\itemdecl{
template<class... Ts>
  using \exposid{common-floating-point-type} = \seebelow;
template<class... Ts>
  using \exposid{common-double-type} = \seebelow;
}

\itemdescr{
¶
\constraints
Each type in the pack \tcode{Ts} is a
cv-unqualified arithmetic type\iref{basic.fundamental}.

¶
Let \tcode{R} be defined as follows:
\ul{
  \li{
    For \tcode{\exposid{common-floating-point-type}},
    let \tcode{R} be the floating-point type with the
    greatest floating-point conversion rank and
    greatest floating-point conversion subrank among the types in \tcode{Ts},
    where integer types are considered to have
    the same floating-point conversion rank as \tcode{double}.
  }
  \li{
    For \tcode{\exposid{common-double-type}},
    let \tcode{R} be \tcode{long double} if any of the types in \tcode{Ts}
    is \tcode{long double}, and
    \tcode{double} otherwise.
  }
}

¶
\mandates
\tcode{R} is defined.

¶
\result
\tcode{R}.
}
}

\editnote{
\tcode{\exposid{common-floating-point-type}} is just following the existing
semantics of \eelis{cmath.syn#3} in the form of an exposition-only alias template.

\tcode{\exposid{common-double-type}} is meant to emulate
the behavior of the \header{tgmath.h} macros \tcode{fadd}, \tcode{fsub}, etc.

For \tcode{dadd}, \tcode{dsub}, etc. no such thing is necessary because without
decimal floating-point types,
the behavior is always to convert all arguments to \tcode{long double}.
}

Change \eelis{cmath.syn#3} as follows:

\Bdiff{
For each function with at least one parameter of type
\tcode{\floating_point_typ} \ins{or \tcode{\exposid{double-type}}}
other than \tcode{abs},
the implementation also provides additional overloads sufficient to ensure that,
if every argument corresponding to a
\tcode{\floating_point_typ} \ins{or \tcode{\exposid{double-type}}}
parameter has arithmetic type,
then every such argument is effectively cast to
\del{the floating-point type
with the greatest floating-point conversion rank and
greatest floating-point conversion subrank among the types of all such arguments,
where arguments of integer type are considered to have
the same floating-point conversion rank as \tcode{double}}
\ins{\tcode{\exposid{common-floating-point-type}<Args...>}
or \tcode{\exposid{common-double-type}<Args...>}}, respectively.
If \del{no such floating-point type with the greatest rank and subrank exists}
\ins{that specialization of the alias template is ill-formed},
then overload resolution does not result in a usable candidate\iref{over.match.general}
from the overloads provided by the implementation.
}

Add a new paragraph immediately following \eelis{cmath.syn#3}:

\Bins{
The implementation may provide additional overloads of
\tcode{\placeholder{p}add},
\tcode{\placeholder{p}sub},
\tcode{\placeholder{p}mul},
\tcode{\placeholder{p}div},
\tcode{\placeholder{p}fma}, and
\tcode{\placeholder{p}sqrt},
for any prefix \tcode{\placeholder{p}},
with parameters of cv-unqualified arithmetic types
to ensure consistent behavior with the corresponding macro
in C header \header{tgmath.h}.
}

\editnote{
While the implementation is generally free to provide additional overloads,
this is not allowed to alter the behavior of a conforming program.
If an implementation provided an extended floating-point type \tcode{_Decimal128},
\tcode{dadd} would need to convert arguments of type \tcode{_Decimal128}
to \tcode{long double},
but the C23 behavior is to call \tcode{daddd128}.

This would not be the case if \tcode{_Decimal128} was a compiler extension,
in which case the program isn't standard C++ anyway,
and the implementation can do whatever it wants.
}

\h3(show-number=false){[c.math.narrow]}

Add a new subclause as follows:

\Bins{
\cowel_html_element(h3){Narrowing operations \stable_ref{c.math.narrow}}

\itemdecl{
constexpr float  f\placeholder{op}(long double x, long double y);
constexpr double d\placeholder{op}(long double x, long double y);
}

\itemdescr{
¶
Let \tcode{\placeholder{op}} be a placeholder for
\tcode{add}, \tcode{sub}, \tcode{mul}, \tcode{div}, \tcode{fma}, or \tcode{sqrt}.

¶
\effects
Each of the functions
\tcode{f\placeholder{op}} and \tcode{d\placeholder{op}}
has the same behavior as the functions
\tcode{f\placeholder{op}l} and \tcode{d\placeholder{op}l},
respectively.
}

\itemdecl{
template<class T, class F1, class F2>
  constexpr T fadd(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fsub(F1 x, F2 y) noexcept;
template<class T, class F1, class F2>
  constexpr T fmul(F1 x, F2 y) noexcept;
template<class T, class F1>
  constexpr T fdiv(F1 x, F2 y) noexcept;
template<class T, class F1, class F2, class F3>
  constexpr T ffma(F1 x, F2 y, F3 z) noexcept;
template<class T, class F1>
  constexpr T fsqrt(F1 x) noexcept;
}

\itemdescr{
¶
Let \tcode{Fs} be a pack of template type parameters following \tcode{T}.
Let \tcode{F} be the type determined as follows:
\ul{
  \li{
    If \tcode{T} is \tcode{double} or
    if any type in \tcode{Fs} is \tcode{long double},
    \tcode{F} is \tcode{long double}.
  }
  \li{
    Otherwise, if \tcode{T} is \tcode{float},
    \tcode{F} is \tcode{double}.
  }
  \li{
    Otherwise, if \tcode{T} is an extended floating-point type
    named by an alias \tcode{std::float\placeholder{N}_t}\iref{stdfloat.syn},
    \tcode{F} is the type named by \tcode{std::float\placeholder{M}_t},
    where \math{\mrow{\mi{M}\mo{=}\mi{N}\mo{×}\mn{2}}},
    if such an alias is defined.
  }
  \li{
    Otherwise, \tcode{F} is implementation-defined
    and may not exist.
  }
}

¶
\constraints
\ul{
  \li{Each type in \tcode{Fs} is a cv-unqualified arithmetic type.}
  \li{\tcode{F} exists.}
  \li{\tcode{T} is a cv-unqualified floating-point type other than \tcode{long double}.}
}
\example{
It is implementation-defined whether the constraints
of \tcode{fadd<bfloat16_t, float32_t>} are satisfied.
}

¶
\effects
All parameters are converted to prvalues of type \tcode{F}.
Each of the function templates has the same behavior as the corresponding
non-template overload with the same name,
if that overload had return type \tcode{T} and parameters all of type \tcode{F}.

¶
\remarks
The \tcode{FP_FAST} macros also relate to specializations of these function templates.
\br\example{
\tcode{FP_FAST_DSQRTL} relates to \tcode{dsqrtl} and \tcode{fsqrt<double, long double>}.
}
}
}

\h2{Acknowledgements}

Thanks to Hubert Tong for reviewing the library wording
and pointing out asymmetries with the behavior of \header{tgmath.h} macros.

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P3348R4,
  title = C++26 should refer to C23 not C17,
  date = 2025-06-19,
  author = Jonathan Wakely,
  link = https://wg21.link/p3348r4,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r4.pdf,
)\

\make_bib
