\cowel_include{libwg21.cow}

\wg21_head(
  title = Values of floating-point types
){
\dl{
  \dt{Document number:} \dd{\docnum{P3938R0}}
  \dt{Date:}            \dd{\tt{2025-12-13}}
  \dt{Audience:}        \dd{SG6, EWG, CWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3938/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/floating-point-values.cow)}
}
\hr
}

\Babstract{
It is not specified what values a floating-point type may represent in C++,
leading to an unclear model for floating-point types.
This paper introduces the necessary wording to specify what may be found between the lines
of the standard.
}

\h2(listed=false){Contents}

\make_contents

\h2{Introduction}

The core language wording in the C++ standard does not specify
what values a floating-point type may represent.
There are a few questions that have no obvious answer:

\ul{
  \li{
    Do infinity and NaN exist from a core language perspective?
  }
  \li{
    Can there be an unsigned zero, infinity, or NaN value,
    or are all floating-point values signed?
  }
  \li{
    Conversely, can there be a signed zero, infinity, or NaN value?
  }
  \li{
    Can there be a negative zero and an unsigned infinity,
    or is the "signedness requirement" all-or-none?
  }
  \li{
    Are negative zero and positive zero distinct values?
    That is, do they compare equal, and if so,
    is there an observable difference (beyond looking at the sign bit) between them?
  }
  \li{
    Is negative zero negative?
    That is, when a \i{Preconditions} element requires a "non-negative" value,
    is the behavior undefined when negative zero is provided?
  }
  \li{
    Similarly, are negative infinity and negative NaN negative?
  }
  \li{
    Is "negative NaN" distinct from "positive NaN",
    or are these effectively the same NaN values with different "payloads"?
  }
  \li{
    Can an extended floating-point type be so imprecise
    that it is incapable of representing any number?
    That is, could an \tcode{\exposid{infinity-t}}  type in the style of \tcode{nullptr_t}
    be considered a floating-point type?
  }
  \li{
    Does the core language need to distinguish between normal and subnormal numbers?
  }
  \li{
    Are there any other possible categories of values beyond finite values, infinity, and NaN?
  }
  \li{
    Are different NaN payloads distinct values?
    If so, does that imply \tcode{std::has_unique_object_representations_v<std::float32_t>}
    is \tcode{true}?
  }
  \li{
    What does it mean for a type to \q{adhere to ISO/IEC 60559},
    as mentioned in \tcode{std::numeric_limits::is_iec559}?
  }
  \li{Is \tcode{0.0} positive or negative zero, or is it implementation-defined/unspecified?}
  \li{Are arithmetic operations required to preserve the sign of zero?}
}


Bits of information may be found in various parts of the standard,
such as in the concept of "adhering to ISO/IEC 60559",
\tcode{numeric_limits} requirements,
the inheritance of C features such as \tcode{std::fpclassify}, etc.
However, some of these questions are so deeply unclear that a core issue
alone wouldn't be sufficient to solve the problem.

The goal of this paper is to answer these questions,
not by making any evolutionary changes to the language,
but by investigating what the status quo is and turning that into wording.

\h2{Q&A}

In the following subsections,
the paper tries to find a good answer to the questions above.
These answers are primarily based on the existing wording
and on existing implementation practice.

\h3{Do infinity and NaN exist from a core language perspective?}

Yes.
\eelis{basic.fundamental} mentions infinity.
While NaN is not mentioned explicitly,
\tcode{numeric_limits::quiet_NaN()} implies it.

At the very least,
floating-point types may represent

\ul{
  \li{zero, for zero-initialization to make sense,}
  \li{\q{negative zero}, since both C and C++ already mention this term many times, and}
  \li{
    infinity, qNaN, and sNan, \eelis{numeric.limits} to make sense and to have types
    that adhere to ISO/IEC 60559.
  }
}

\h3{Can there be an unsigned zero, infinity, or NaN value, or are all floating-point values signed?}

There can be fully unsigned floating-point numbers.
The C standard explicitly mentions unsigned infinity and unsigned zero,
and different NaN signs are typically not distinct values.
The C++ standard presumably inherits the C model because all of the
\header{cmath} functions are stated to work like C23's \header{math.h}.
There is no C++ restriction on \tcode{fpclassify}.

Furthermore, \eelis{numeric.limits.members}
states that \tcode{numeric_limits::is_signed} is meaningful for all specializations,
so there is presumably no requirement that a floating-point type
or any of its values are signed.

\h3{Conversely, can there be a signed zero, infinity, or NaN value?}

Presumably.
The C++ standard mentions negative zero and negative infinity in a number of places.
NaN with negative sign bit and NaN with positive sign bit are usually
not considered distinct values (e.g. ISO/IEC 60559),
but the C++ standard has no wording that would prohibit that distinction.

\h3{Can there be a negative zero and an unsigned infinity, or is the "signedness requirement" all-or-none?}

It's not all-or-none.
There are floating-point types that adhere to ISO/IEC 60559,
and these do not have a distinct negative and positive NaN,
so it cannot be all-or-none.

\h3{Is negative zero negative? What about infinity and NaN?}

No.
The wording uses \q{negative} in the \q{less than zero}
sense\iref{complex.numbers#lib:polar,complex}.
The C23 standard defines a \q{negative value} to values which are less than zero,
so negative zero and \q{negative NaN} (NaN with negative sign bit) are not negative.

Negative infinity is negative because it compares less than zero.

\h3{Is \q{negative NaN} distinct from \q{positive NaN}?}

Presumably.
While ISO/IEC 60559 does not consider NaNs with different sign bit
to be distinct values,
the C++ standard does not prohibit such a model.

\h3{Can an extended floating-point type have no finite values?}

No.
This would make zero-initialization unimplementable,
and would make \tcode{numeric_limits} members such as \tcode{epsilon()}
worded in a nonsensical way.

\h3{Does the core language need to distinguish between normal/subnormal numbers?}

No.
Subnormals either get \q{flushed} to zero,
meaning that they are alternative representations of zero, numerically,
or they are simply finite numbers like any other.
The classification of \q{normal} and \q{subnormal}
is an implementation detail of the floating-point format.

\h3{Are there values beyond finite values, infinity, and NaN?}

The exotic and surprising part is that floating-point types may represent
additional implementation-defined values beyond finite values, infinity, and NaN.
This is backed by
\ul{
  \li{C23 §5.2.5.3.3 [Characteristics of floating types <float.h>] paragraph 8, and}
  \li{C23 §7.12 [Mathematics <math.h>] paragraph 12.}
}

These paragraphs support the existence of such additional implementation-defined
classifications.
C++ inherits the behavior of \tcode{fpclassify} from \header{math.h},
so it must support the same classifications to be compatible.

\Bex{
\ref(NetBSD-fpclassify) documents that the \tcode{fpclassify} macro for
\ref(https://en.wikipedia.org/wiki/VAX){VAX floating-point numbers}
may yield \tcode{FP_ROP} (reserved operand),
which raises a reserved operand fault,
i.e. a CPU exception when processed,
similar to integer division by zero.

This is different from signaling NaN in that by default,
signaling NaN only raises a floating-point exception but doesn't trap.
}

While neither the C23 wording nor the C++ wording handles these
extra implementation-defined classifications well,
they nonetheless exist,
and it seems like an unmotivated breaking change to drop support for them.

\h3{Are different NaN payloads distinct values?}

Sometimes.
\tcode{numeric_limits::quiet_NaN()} and
\tcode{numeric_limits::signaling_NaN()} are two NaNs distinguished only by payload.
However, not every implementation treats these distinctly.
For example, when compiling to WASM,
none of the \tcode{f32} or \tcode{f64} instructions handle signaling NaNs.

\h3{What does it mean for a type to \q{adhere to ISO/IEC 60559}?}

It just means that the value representation is one of
binary16, binary32, binary64, binary128,
or some extended or decimal floating-point format specified
in ISO/IEC 60559.

When it comes to operations,
the C++ standard specifies no mapping between expressions (e.g. \tcode{/})
and the ISO/IEC 60559 operations (e.g. \q{division}).
In fact, it seems to deliberately deviate from the ISO/IEC 60559 operations
by declaring division by zero to be undefined behavior,
even for floating-point types\iref{expr.mul}.

\Bex{
This implies that e.g. \tcode{numeric_limits<float>::infinity() + 0} is not infinity,
but \q{UB by omission} or \q{UB by wording hole},
even if \tcode{float} \q{adheres to ISO/IEC 60559}.
}

While it would be desirable to align the C++ operations with ISO/IEC 60559 operations,
this would require significant wording effort.
There exists no core wording that even attempts at doing so.
Note that implementations don't always compute results correctly rounded
(with the greatest available precision),
while the ISO/IEC 60559 operations are usually correctly rounded.
Therefore, aligning the C++ expressions with ISO/IEC 60559 may break most implementations.

\h3{Is \tcode{0.0} positive or negative zero?}

Presumably positive.
The C++ standard does not mandate a specific sign for \gterm{floating-point-literal}s,
but no implementation makes them negative,
nor does it make practical sense to do so.
We should mandate that literals have no negative sign.

\h3{Are arithmetic operations required to preserve the sign of zero?}

Presumably no.
While the ISO/IEC 60559 multiplication operation
preserves the sign bit when multiplying with 1,
the C++ standard does not clearly mandate such behavior.

Especially considering that not every type adheres to ISO/IEC 60559,
we should require a specific handling of sign bits, explicitly.
For example, the unary \tcode{-} operator should be required to flip the sign bit
even for zero,
otherwise \tcode{-0.0} may not be a spelling of negative zero,
as users rely on.

\h2{Impact on the standard}

The clarify the floating-point specification,
a bit of additional wording is required.

This paper only \q{picks the low-hanging fruits},
so to speak.
In the long run, specifying the handling of NaNs and infinities by C++ expressions,
documenting ISO/IEC 60559 conformance,
and other large changes may be desirable.
However, those would require much greater changes.

\h2{Impact on implementations}

All proposed wording changes document the current behavior of major implementations.

\h2{Wording}

The changes are relative to \ref(N5014).

\h3(show-number=false){[lex]}

Change \eelis{lex.fcon#3} as follows:

\Bdiff{
If the scaled value is not in the range of representable values for its type,
the program is ill-formed.
Otherwise, the value of a \grammarterm{floating-point-literal} is
the scaled value if representable,
else the larger or smaller representable value nearest the scaled value,
chosen in an implementation-defined manner.
\ins{The value of a \grammarterm{floating-point-literal} is non-negative.}

\ins{\example{
\tcode{0.0} is positive zero, and
\tcode{-0.0} is negative zero if \tcode{double}
has a signed zero (\eelis{basic.fundamental}, \eelis{expr.unary.op}).
}}
}

\h3(show-number=false){[basic]}

Immediately preceding \eelis{basic.fundamental#13},
insert three new paragraphs:

\Bins{
A floating-point type \dfn{adheres to ISO/IEC 60559}
if its value representation is one of the floating-point formats
specified in ISO/IEC 60559 and can represent the sets of floating-point values
listed in ISO/IEC 60559.
For a floating-point type
whose value representation is in a binary format that adheres to ISO/IEC 60559,
it is implementation-defined which (if any)
representations of NaN are quiet or signaling.

\note{
Adherence to ISO/IEC 60559 does not imply that operations on floating-point types
behave exactly as specified in that standard.
For example, the behavior of addition in C++\iref{expr.add}
can differ from the \q{addition} operation in ISO/IEC 60559.
}
}

\editnote{
The following change resolves
\ref(https://github.com/cplusplus/CWG/issues/819){CWG submission #819}.
}

\Bins{
A floating-point type shall at least represent a subset of rational numbers.
Depending on the implementation-defined value representation for the type,
it may additionally represent the non-finite values
\ul{
  \li{infinity,}
  \li{quiet \q{Not a Number} value,}
  \li{signaling \q{Not a Number} value, and}
  \li{further implementation-defined values.}
}

For any of the above (including zero),
a floating-point type may represent either a single unsigned value or
two distinct values with negative and positive sign.

\note{
A floating-point type which adheres to ISO/IEC 60559 is capable of representing
a negative and positive variant of finite values and infinity,
an unsigned quiet NaN, and
an unsigned signaling NaN.
Such a type has multiple object representations for quiet NaN and signaling NaN.
}
}

\editnote{
The following change resolves
\ref(https://github.com/cplusplus/CWG/issues/817){CWG submission #817}.
}

Immediately preceding \eelis{basic.fundamental#14},
insert a new paragraph:

\Bins{
A value is \dfn{negative} if and only if it compares less than 0\iref{expr.rel}.

\note{
Thus, negative zeros and NaNs are not negative values.
}
}

\h3(show-number=false){[expr]}

At the end of \eelis{expr.pre},
insert a new paragraph:

\Bins{
Unless otherwise stated,
it is unspecified which of the alternative representations for a value
is chosen as the result of an expression.
Furthermore,
if the result is of a floating-point type that can represent negative and positive zero,
it is implementation-defined which zero is chosen as the result of the expression.
}

Change \eelis{conv.fpint#2} as follows:

\Bdiff{
A prvalue of an integer type or of an unscoped enumeration type
can be converted to a prvalue of a floating-point type.
The result is exact if possible.
\ins{If the value being converted is zero,
the result is positive or unsigned zero.}
If the value being converted is in the range of values that can be represented
but the value cannot be represented exactly,
it is an implementation-defined choice of either the next lower or higher representable value.

\note{
Loss of precision occurs if the integral value cannot be represented exactly
as a value of the floating-point type.
}

If the value being converted is outside the range of values that can be represented,
the behavior is undefined.
If the source type is \tcode{bool}, the value false is converted to zero and
the value \tcode{true} is converted to one.
}

Change \eelis{expr.unary.op#8} as follows:

\Bdiff{
The operand of the unary \tcode{-} operator shall be a prvalue of
arithmetic or unscoped enumeration type
and the result is the negative of its operand.
Integral promotion is performed on integral or enumeration operands.
The negative of an unsigned quantity is computed by subtracting its value from
\math{\msup{\mn{2}\mi{n}}},
where \math{\mi{n}} is the number of bits in the promoted operand.
\ins{For floating-point types that may represent negative and positive zero,
the unary \tcode{-} operator results in the zero with opposite sign.}
The type of the result is the type of the promoted operand.
}

\editnote{
The following changes resolve
\ref(https://github.com/cplusplus/CWG/issues/814){CWG submission #814}.
}

Change \eelis{expr.spaceship#4} as follows:

\Bdiff{
If both operands have arithmetic types,
or one operand has integral type and the other operand has unscoped enumeration type,
the usual arithmetic conversions are applied to the operands.
Then:
\ul{
  \li{
    If a narrowing conversion\iref{cl.init.list} is required,
    other than from an integral type to a floating-point type,
    the program is ill-formed.
  }
  \li{
    Otherwise, if the operands have integral type, \etc{}.
  }
  \li{
    Otherwise, the operands have floating-point type,
    and the result is of type \tcode{std::partial_ordering}.
    The expression \tcode{a <=> b} yields
    \tcode{std::partial_ordering::less} if a is less than b,
    \tcode{std::partial_ordering::greater} if a is greater than b,
    \tcode{std::partial_ordering::equivalent} if a is equivalent to b, and
    \tcode{std::partial_ordering::unordered} otherwise.
    \ins{Positive zeros are equivalent to negative zeros.}
  }
}
}

Change \eelis{expr.rel#6} as follows:

\Bdiff{
If both operands (after conversions) are of arithmetic or enumeration type,
each of the operators shall yield
\tcode{true} if the specified relationship is \tcode{true} and
\tcode{false} if it is \tcode{false}.
\ins{Positive zeros compare equal to negative zeros.}
}

Change \eelis{expr.eq#8} as follows:

\Bdiff{
If both operands are of arithmetic or enumeration type,
the usual arithmetic conversions\iref{expr.arith.conv} are performed on both operands;
each of the operators shall yield
\tcode{true} if the specified relationship is \tcode{true} and
\tcode{false} if it is \tcode{false}.
\ins{Positive zeros compare equal to negative zeros.}
}

\h3(show-number=false){[temp]}

\editnote{
The following changes resolve
\ref(https://github.com/cplusplus/draft/pull/8573){Editorial PR #8375}.
}

Immediately preceding \eelis{temp.type#2},
insert a new paragraph:

\Bins{
Two values \math{\mi{x}} and \math{\mi{y}} of a type \tcode{T}
are \dfn{bitwise identical} if
\tcode{std::bit_cast<U>(\math{\mi{x}}) == std::bit_cast<U>(\math{\mi{y}})}\iref{bit.cast}
is \tcode{true},
where \tcode{U} is a hypothetical unsigned integer type with the same size as \tcode{T} and
the same amount and positioning of padding bits in its object representation as \tcode{T}.

\note{
It is possible that two values are the same but not bitwise identical.
For example, a floating-point type \tcode{T} can have multiple representations
of zero,
of any other finite number,
of the same NaN value,
and more,
even if the object representation of \tcode{T} has no padding bits.
}
}

\editnote{
The ISO/IEC 60559 standard also uses the term \q{bitwise identical}.
}

Change \eelis{temp.type#2} as follows:

\Bdiff{
Two values are \dfn{template-argument-equivalent} if they are of the same type and
\ul{
  \li{they are of integral type and their values are the same, or}
  \li{
    they are of floating-point type and their values are \ins{bitwise} identical, or
  }
  \li{they are of type \tcode{std::nullptr_t}, or}
  \li{\etc}
}
}

\editnote{
We cannot simply say that the value representations of the template arguments is equal
because we are talking about values, not objects,
so a value and object representation isn't available in the first place.

While it would be possible to define \q{bitwise identical}
without the use of \tcode{std::bit_cast},
the use of \tcode{std::bit_cast} makes the intent obvious at first glance.
The use of \q{unsigned} may seem unnecessary,
but it makes the wording more obvious,
and there exist integer types such as \tcode{bool} which don't behave
like the hypothetical type we want here.
}

\editnote{
This wording approach implies that template arguments
have a value representation that can be used to distinguish different
template specializations all using the same qNaN argument with different payloads.
The rest of the wording may not actually support this,
but that is how every implementation works.
}

\h3(show-number=false){[support]}

Change \eelis{numeric.limits.members} as follows:

\Bdiff{
\etc

\itemdecl{
static constexpr bool has_signaling_NaN;
}

\itemdescr{
\tcode{true} if the type has a representation for a signaling \q{Not a Number}.

Meaningful for all floating-point types.

Shall be \tcode{true} for all specializations in which
\tcode{is_iec559 \del{!= false} \ins{&& \tcode{radix == 10}}} \ins{is \tcode{true}}.
}
}

\editnote{
ISO/IEC 60559 does not require that for its binary format,
any specific representation in a binary format is a signaling NaN.
In fact, implementations (e.g. GCC by default, Clang by default for WASM target)
report \tcode{is_iec559} for \tcode{float},
despite there not existing a signaling NaN.
Implementations want to signal \tcode{is_iec559} for a type,
even when none of the representations are signaling.

Doing so seemingly complies with ISO/IEC 60559 because it is not mandated
that at least one signaling NaN representation exists.
Even the specification of the setPayloadSignaling operation
does not clearly prohibit an implementation that has no permissible payloads.

On the other hand, ISO/IEC 60559 defines which of the decimal floating-point
NaNs are quiet and signaling.
}

Change \eelis{numeric.limits.members} as follows:

\Bdiff{
\itemdecl{
static constexpr T signaling_NaN() noexcept;
}

\itemdescr{
Representation of a signaling \q{Not a Number}, if available.

Meaningful for all specializations for which \tcode{has_signaling_NaN != false}.
Required in specializations for which \tcode{is_iec559 \del{!= false}}
\ins{\tcode{&& radix == 10} is \tcode{true}}.
}
}

Change \eelis{cmp.alg#2} as follows:

\Bdiff{
The name weak_order denotes a customization point object\iref{customization.point.object}.
Given subexpressions \tcode{E} and \tcode{F},
the expression \tcode{weak_order(E, F)} is expression-equivalent\iref{defns.expression.equivalent}
to the following:
\ul{
  \li{\etc}
  \li{
    Otherwise, if the decayed type \tcode{T} of \tcode{E} is a floating-point type,
    yields a value of type \tcode{weak_ordering}
    that is consistent with the ordering observed by \tcode{T}'s comparison operators
    and \tcode{strong_order},
    and if \tcode{numeric_limits<T>::is_iec559} is \tcode{true},
    is additionally consistent with the following equivalence classes,
    ordered from lesser to greater:\ul{
      \li{together, all \del{negative} NaN values \ins{with negative sign bit};}
      \li{negative infinity;}
      \li{each normal negative value;}
      \li{each subnormal negative value;}
      \li{together, both zero values;}
      \li{each subnormal positive value;}
      \li{each normal positive value;}
      \li{positive infinity;}
      \li{together, all \del{positive} NaN values \ins{with positive sign bit}.}
    }
  }
  \li{\etc}
}
}

\editnote{
ISO/IEC 60559 floating-point types have no \q{negative NaN} or \q{positive NaN},
so the existing wording makes no sense,
especially not with the new definition of \q{negative}.
}

\h3(show-number=false){[meta]}

Change \eelis{meta.unary.prop#10} as follows:

\Bdiff{
The predicate condition for a template specialization
\tcode{has_unique_object_representations<T>} shall be satisfied if and only if
\ul{
  \li{\tcode{T} is trivially copyable, and}
  \li{any two objects of type T with the same value have the same object representation, where\ul{
    \li{
      two objects of array or non-union class type \etc
    }
    \li{
      two objects of union type \etc
    }
  }}
}
The set of scalar types\ins{\iref{basic.fundamental}}
for which this condition holds is implementation-defined.

\ins{\example{
The condition does not hold for floating-point types that adhere to ISO/IEC 60559
because there are multiple representations of the same NaN value.
The condition also does not hold for any type
whose object representation contains padding bits.
}} 
}

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = NetBSD-fpclassify,
  title = fpclassify(3) - NetBSD Manual Pages,
  link = https://man.netbsd.org/NetBSD-10.1/fpclassify.3,
)\

\make_bib
