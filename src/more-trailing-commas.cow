\cowel_include{libwg21.cow}

\wg21_head(
    title = More trailing commas
){
\dl{
  \dt{Document number:} \dd{\docnum{P3776R0}}
  \dt{Date:}            \dd{\tt{2025-08-25}}
  \dt{Audience:}        \dd{EWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3776/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/more-trailing-commas.cow)}
}
\hr
}

\Babstract{
C++ should support trailing commas in more places,
such as in function parameter lists.
}

\h2(listed = false){Contents}

\make_contents

\h2{Introduction}

C++ permits the use of trailing commas in some lists, but not in others.
For example, trailing commas are permitted at the end of an \gterm{initializer-list},
but not following a
\gterm{mem-initializer-list},
\gterm{capture-list},
\gterm{template-parameter-list},
\gterm{expression-list},
in a \gterm{postfix-expression}, etc.
It would be convenient if the support for trailing commas was extended
to those other lists.

For example, the following should be valid:

\cppblock{
void f(
    int x,
    int y, // \N{LEFTWARDS ARROW} trailing comma here
);
}

\h3{Recent history}

While this proposal is new,
a very similar proposal \ref(P0562R2) has recently passed through EWG and CWG,
but was ultimately not polled due to implementability concerns.
\ref(P0562R2) argues in favor of trailing commas
following \gterm{mem-initializer-list} and \gterm{base-specifier-list},
with similar rationale as this proposal.
The concern in question is that a comma after a \gterm{mem-initializer-list}
introduces a parsing ambiguity
between expressions and function bodies;
see \ref(P0562R2ReflectorDiscussion):

\Bquote{
Classes are parsed in two phases: first, declarations are parsed, skipping
the bodies of member functions and a few other things, and then those
delayed parts are parsed in a context where the class is complete. 

For most functions, skipping the body in the first pass is easy. There's an
open brace, and you can just skip to the close brace. At worst, there's
\tcode{try \N{LEFT CURLY BRACKET}},
and you need to find the end of the last catch handler.

The problem is that a
\gterm{mem-initializer-id} can be a \gterm{template-id} that refers to a base class, and
the identifiers it uses to name the base class might be declared
(possibly after the constructor) in the same class \N{EM DASH} meaning that we've not parsed
them yet.
Therefore when we see a \tcode{<}, we don't know if it's introducing a
template argument list.
For example: 

\cppblock{
struct X {};
struct Y : X {
  Y() : A<b<c>(), {
  // ...
  }
  // A, b, and c declared down here somewhere
};
}

Are we in the body of the constructor yet?

Prior to P0562R2, the answer was no: an open brace preceded by a comma
cannot start the constructor body. For this to be valid, \tcode{b} must be a
template, and the \tcode{\N{LEFT CURLY BRACKET}} is then the start
of the second template argument of \tcode{A}. (\etc) 

But after P0562R2, the above example seems to become ambiguous, and I'm not
sure how an implementation would be able to parse it.
}

Following these developments in St. Louis 2024-06,
the proposal has seen no activity.
It seems like the baby has been thrown out with the bathwater here,
since the rationale of the proposal is still sound and
this ambiguity does not affect \gterm{base-specifier-list}s.

\h3{Trailing commas in other languages}

Various modern programming languages support trailing commas,
not just in initialization of classes or when listing \tcode{enum} members,
but also in function parameter lists or function argument lists:

\style{
  #lang-table {
    margin-left: auto;
    margin-right: auto;
    width: 95%;
  }
  #lang-table td {
    padding-bottom: 1em;
  }
}

\table(id = lang-table){
  \tr{
    \th{Language} \th{Trailing commas support}
  }
  \tr{
    \td{Rust}
    \td{
      Has always supported trailing commas in.\br
      Use of trailing commas is recommended by the official style guide
      (\ref(RustTrailingCommas)).
    }
  }
  \tr{
    \td{Kotlin}
    \td{
      Added support for trailing commas in 2020 (\ref(KotlinTrailingCommas)).
    }
  }
  \tr{
    \td{JavaScript}
    \td{
      Support for trailing commas was standardized in ECMASCript2017
      (\ref(ECMAScriptTrailingCommas)).
    }
  }
  \tr{
    \td{TypeScript}
    \td{
      Added support at the same time it was standardized for JavaScript
      (\ref(TypeScriptTrailingCommas)).
    }
  }
  \tr{
    \td{C#}
    \td{
      No support yet,
      in part due to concerns regarding tuple syntax,
      which also uses parentheses (\ref(CSharpTrailingCommas)).
    }
  }
  \tr{
    \td{Swift}
    \td{
      No support yet.
      Concerns regarding tuple syntax have also been raised (\ref(SwiftTrailingCommas)).
    }
  }
}

The motivation for trailing commas in those languages equally applies to C++.

\Bnote{
More discussion on this language design choice can also be found at
\ref(RedditTrailingCommas) and \ref(OldNewThing).

Various other languages such as Python, Go, and Julia also support
trailing commas in function calls,
but are not specially listed in the table above.
That table aims to highlight particularly relevant examples with authoritative resources.
}

\h2{Motivation}

While trailing commas don't solve any major safety or performance issue,
they improve developer convenience significantly in some ways.
Given how many comma-separated lists developers regularly write,
this convenience can be noticeable on a daily basis.

\Bnote{
The following motivation uses only function parameter lists as motivating examples,
but the arguments equally apply to other comma-separated lists.
}

\h3{Improved text editing}

Advanced text editors typically have commands for cutting/copying whole lines,
or let the developer reorder lines via keyboard shortcut.
For example, a line can be swapped with the line above
with \kbd{Alt}+\kbd{\N{NO-BREAK SPACE}↑\N{NO-BREAK SPACE}} in VSCode.
This can result in compiler errors without trailing commas:

\cppblock{
void f(
    int x,
    int y
);
}

When reordering \tcode{int x,} and \tcode{int y}, errors are raised:

\cppblock{
void f(
    int y  // \N{DOWNWARDS ARROW WITH TIP LEFTWARDS} syntax error: "int" following "y"
    int x, // \N{LEFTWARDS ARROW} syntax error: trailing comma
);
}

If both lines had a trailing comma and C++ permitted that syntax,
reordering these lines would not be a problem.

\h3{Improved version control}

When an element is appended to a comma-separated list,
this means that the previous element needs to receive a separating comma,
resulting in menial changes:

\codeblock(diff){
 void f(
     int x,
-    int y
+    int y,
+    int z
 );
}

With trailing commas, we can turn a three-line change into a one-line change:

\codeblock(diff){
 void f(
     int x,
     int y,
+    int z,
 );
}

This smaller change is not just easier to review,
it also does not pollute the revision history (\tt{git blame}) for
the previous line of code,
and it does not introduce easily avoidable merge conflicts.

\h3{Improved auto-formatter control}

Many C++ developers auto-format their code using
\ref(https://clang.llvm.org/docs/ClangFormat.html){ClangFormat}.
One powerful feature it has is the ability to control
how brace-enclosed lists are formatted via the use of trailing commas.

\Bex{
ClangFormat may format C++ code like:
\cppblock{
vector<int> numbers { LIST_ITEM_A, LIST_ITEM_B,  //
                      LIST_ITEM_C };             // \N{LEFTWARDS ARROW} column limit here
                                                 // 
vector<int> numbers {
    LIST_ITEM_A,
    LIST_ITEM_B,
    LIST_ITEM_C, // \N{LEFTWARDS ARROW} trailing comma here
};
}

The compact version without a trailing comma may be situationally useful
by compactifying code, allowing more to fit on screen.
The verbose version with a trailing comma is more useful for regularly updated lists,
and can be perceived as more organized.
It's easy to envision the same example with function argument lists.
}

Trailing commas express the desire to format over multiple lines,
which auto-formatters may utilize.
Without support for trailing commas in e.g. function parameter lists,
the developer is robbed of their ability to (elegantly) express that desire,
since doing so would make the program ill-formed.

\Bnote{
A possible workaround for ClangFormat is to insert a trailing \tcode{//}
at the end of a line
(which forces line breaks to be retained),
or to manually format a section of code with \tcode{// clang-format off}.
}

\h3{Improved language consistency}

It is generally surprising that C++ only supports trailing commas
within a subset of its comma-separated lists.
Besides the design not sparking joy,
it creates practical problems.

For example, when refactoring code and e.g. converting list-initialization
such as \tcode{{1, 2, 3,}} which already uses trailing commas into direct-initialization
\tcode{(1, 2, 3,)},
the trailing comma introduces a compiler error until it is removed,
which is a mild inconvenience at least.

\h3{Eliminating some uses of \tt{\hl(macro){__VA_OPT__}}}

When we want to prepend an element to a variadic macro argument,
we may need to use \tt{\hl(macro){__VA_OPT__}} in the following way:

\cppblock{
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
}

With an unconditional comma,
\tcode{\hl(macro){F}()} would expand to \tcode{f(0,)},
which is currently ill-formed.
A trailing comma in function calls would allow us to simplify such macros.

\h3{Motivating examples}

In discussions of this proposal,
there is often some skepticism as to whether it's useful for specific lists.
For example, I have been told that trailing commas may be useful
in a \gterm{template-parameter-list}, but not in a \gterm{template-argument-list}.

However, while some lists are more frequently multi-line,
you can come up with a plausible multi-line example for virtually any list:

\cppblock{
// \serif{\gterm{template-parameter-list}}
template <
    input_iterator I,
    sentinel_for<I> S,
    weakly_incrementable O, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
>
copy_result function(I first, S last, O result);

// \serif{\gterm{template-argument-list}}
using V = variant<
    int_least64_t,
    float,
    double,
    char8_t,
    char16_t,
    char32_t,
    bool,
    string, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
>;

// \serif{\gterm{function-parameter-list}}
void pretty_print_log(
    log_level level,
    string_view message,
    optional<code_location> location = {},
    optional<const error&> error = {}, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
);

// \serif{\gterm{function-argument-list}}
auto it = find(
    ranges::begin(container),
    ranges::end(container) + (container.size() / 2), // \N{LEFTWARDS ARROW} \serif{trailing comma here}
);

// \serif{\gterm{lambda-capture}}
auto callback = [
        &,
        current_index = 0,
        invocation_count = 0, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
    ] {
        ++invocation_count;
        // ...
    };

// \serif{\gterm{annotation-list}}
[[
    = testing::description("Fuzzing test for ASCII sequences."),
    = testing::execution::parallel, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
]]
void fuzz_ascii() { /* ... */ }
}

For any of these list types, it is plausible that they are long enough
to be broken onto multiple lines,
and it is plausible that changes will be made to such lists in the future,
which makes a trailing comma useful in these lists.

\h2{Design}

I propose to add a trailing comma after a list whenever possible
(i.e. no parsing issues are introduced),
with the exception of lists terminated by a semicolon.
The design can be summed up as:

\Bquote{
When enclosed by \tcode{{}}, \tcode{()}, \tcode{[]}, or \tcode{<>},
lists can have a trailing comma.
}

All the following decisions are intended to make that rule of thumb correct.
Cherry-picking individual cases like permitting \tcode{array[a,b,]}
but not \tcode{[a,b,]{}} would only complicate the situation.

\h3{New trailing commas}

The following trailing commas are proposed,
and not currently permitted.

\cppblock{
[: /* ... */ :]<A, B,>              // \serif{\gterm{template-argument-list} in \gterm{splice-specialization-specifier}}
[]<A, B,>{}                         // \serif{\gterm{template-parameter-list} in \gterm{lambda-expression}}
[a, b,]{}                           // \serif{\gterm{capture-list} in \gterm{lambda-introducer}}
d[a, b,]                            // \serif{\gterm{expression-list} in subscript operator}
f(a, b,)                            // \serif{\gterm{expression-list} in call operator}
T(0,)                               // \serif{\gterm{expression-list} in function-style cast}
typename T(0,)                      // \serif{\gterm{expression-list} in function-style cast with \tcode{typename}}
new (a, b,) T                       // \serif{\gterm{expression-list} in \gterm{new-placement}}
new T(a, b,)                        // \serif{\gterm{expression-list} in \gterm{new-initializer}}
template for (int _ : { a, b, })    // \serif{\gterm{expression-list} in \gterm{expansion-init-list}}
auto [a, b,]                        // \serif{\gterm{sb-identifier-list} in \gterm{structured-binding-declaration}}
T f(a, b,)                          // \serif{\gterm{parameter-declaration-list} in \gterm{parameter-declaration-clause}}
T x(a, b,);                         // \serif{\gterm{expression-list} in \gterm{initializer}}
[[=a, =b,]]                         // \serif{\gterm{annotation-list} in \gterm{attribute-specifier}}
S() : m(a, b,)                      // \serif{\gterm{expression-list} in \gterm{mem-initializer}}
template<a, b,>                     // \serif{\gterm{template-parameter-list} in \gterm{template-head}}
template<C<a, b,> T>                // \serif{\gterm{template-argument-list} in \gterm{type-constraint}}
template<template<A, B,> concept>   // \serif{\gterm{template-parameter-list} in \gterm{concept-tt-parameter}}
T<A, B,>                            // \serif{\gterm{template-argument-list} in \gterm{simple-template-id}}
operator()<A, B,>                   // \serif{\gterm{template-argument-list} in \gterm{template-id}}
}

While this initially appears like a huge change,
it can be easily worded by incorporating the trailing comma directly
into lists such as \gterm{expression-list},
since every occurrence of these lists would allow for trailing commas.

\Bnote{
Of these, the \gterm{expression-list} in an \gterm{expansion-init-list} seems like a C++26 defect,
and a CWG issue has been requested at \ref(CWGGithub754).
Since this appears to be a separate C++26 defect,
not a new C++29 feature,
this paper's wording does not include that fix.
}

\Bnote{
Trailing commas would also be supported following a \gterm{capture-default},
such as in \tcode{[&,]}.
This is worth mentioning because a \gterm{capture-default} is not actually part of a
\gterm{capture-list}, but a standalone element within a \gterm{lambda-capture}.
}

\h4{Addressing ambiguity concerns}

Note that all of these proposed cases are safe from parsing ambiguities
encountered by \ref(P0562R2).
That is because a the trailing comma can only be followed by
'\tcode{\N{RIGHT CURLY BRACKET}}',
'\tcode{\N{RIGHT PARENTHESIS}}',
'\tcode{\N{RIGHT SQUARE BRACKET}}', or
'\tcode{>}'.
In the first three cases,
a closing bracket cannot possibly be the beginning of a new element,
only the end whatever encloses list.
Neither '\tcode{>}', '\tcode{>=}', nor '\tcode{>>}' are prefix unary operators,
so in any case, '\tcode{,>}' can only mean one thing.

Furthermore, \tcode{operator,} cannot be separated into \tcode{operator} and '\tcode{,}'
or combined into \tcode{operator,>} (there is no '\tcode{,>}' operator in the language),
so no ambiguity can be introduced by having \tcode{operator} appear at the end of a list.

\h3{Already supported trailing commas}

The following trailing commas are already supported:

\cppblock{
{ a, b, }                 // \serif{\gterm{initializer-list} in \gterm{braced-init-list}}
{ .a=0, .b=0, }           // \serif{\gterm{designated-initializer-list} in \gterm{braced-init-list}}
enum { a, b, }            // \serif{\gterm{enumerator-list} in \gterm{enum-specifier}}
[[a,b,,,,]]               // \serif{\gterm{attribute-list} in \gterm{attribute-specifier}}
}

\h3{Not proposed trailing commas}

\h4{Commas proposed in P0562R2}

The following two trailing commas are proposed by \ref(P0562R2) and should be added,
if at all possible,
as a revision of that paper.

\cppblock{
S() : a{}, b{},           // \serif{\gterm{mem-initializer-list} in \gterm{ctor-initializer}}
struct S : A, B, { };     // \serif{\gterm{base-specifier-list} in \gterm{base-clause}}
}

While the parsing ambiguity (\ref(#recent-history))
seems limited to a \gterm{mem-initializer-list},
a \gterm{base-specifier-list} is similarly followed by \tcode{\N{LEFT CURLY BRACKET}},
which makes it quite plausible that similar parsing issues could affect that case.
In any case, to keep this paper focused,
I do not propose those two commas.

\h4{Trailing commas in semicolon-terminated lists}

Two more commas are not proposed because they are in semicolon-terminated lists:

\cppblock{
int a, b,;                // \serif{\gterm{init-declarator-list} in \gterm{simple-declaration}}
struct S { int a, b,; };  // \serif{\gterm{member-declarator-list} in \gterm{member-declaration}}
friend A, B,;             // \serif{\gterm{friend-type-specifier-list} in \gterm{friend-type-declaration}}
using a, b,;              // \serif{\gterm{using-declarator-list} in \gterm{using-declaration}}
}

Firstly, for aesthetic reasons, it is unlikely that users would want to write this.
Furthermore, multiple elements in a \gterm{init-declarator-list} are already
discouraged by some style guides.
Last but not least, the \ref(#motivation) of this paper focuses on multi-line scenarios.
In the aforementioned cases,
to make good use of trailing commas,
developers would need to write:

\cppblock{
int
    a,
    b,
;

using
    a,
    b,
;
}

Not only is this exotic, it is also more verbose than the status quo,
which already allows reordering lines if we instead write:

\cppblock{
int a;
int b;

using a;
using b;
}

Overall, permitting trailing commas
in a \gterm{init-declarator-list} or \gterm{using-declarator-list} seems unmotivated,
and would create unnecessary work for implementers.

\h4{Non-lists}

The following trailing commas are not proposed because they are not following a list:

\cppblock{
static_assert(true,"",)   // \serif{\gterm{static_assert-declaration}}
contract_assert(true,)    // \serif{\gterm{assertion-statement}}
= delete("",)             // \serif{\gterm{deleted-function-body}}
}

While it may be more philosophically consistent to permit a comma within anything
that vaguely looks like a function call,
there is little motivation for such cases above.
To be fair, a trailing comma could yield a minimal one-line change as follows:

\codeblock(diff){
 static_assert(
     true,
+    "message"
 );
}

However, it seems unlikely that a developer would choose to distribute a no-message
\tcode{static_assert} over three lines in the first place.
Overall, these cases just seem to add more work for implementers.

\h4{Commas following ellipsis parameters}

Another not proposed trailing comma is that after an ellipsis parameter:

\cppblock{
void f(
  int x,
  ...,    // \serif{after \tcode{...} in \gterm{parameter-declaration-clause}}
);
}

This decision is largely based on negative feedback in \ref(CoreReflectorDiscussion).

The trailing comma in this place is largely unmotivated because the ellipsis is always
the last element in the list.
Consequently, a \tcode{...} line cannot be reordered with the line before,
and a comma will never have to be inserted after \tcode{...} to accommodate a subsequent element.

\h4{Commas in macros}

The following trailing commas are not proposed:

\cppblock{
#define M(x,y,) // \serif{\gterm{identifier-list} in \gterm{control-line}}
\hl(macro){M}(x,y,)         // \serif{arguments to a function-like macro}
}

The former lacks motivation because it is highly unlikely
that a C++ use would define multi-line parameters to a function-style macro.
Doing so requires each parameter line to be terminated by \tcode{\\},
among other reasons.

Supporting trailing commas in \tcode{\hl(macro){M}(x,y,)}
would alter the meaning of existing code.
Currently, that expression is providing three arguments to \tcode{\hl(macro){M}},
the last of which is empty.

\h3{Comparison to P0562R2}

It is worth noting that \ref(P0562R2) did not propose trailing commas
in function and template parameters
with the following rationale:

\Bquote{
Function and template parameters do not allow a final terminating comma,
but these do not  trouble me in practice.
(Arguably any function or template with enough parameters to be much 
of a maintenance issue seems like it is ripe for refactoring.)
This paper does not propose changing function or template parameters.
}

Note that \ref(P0562R2) argues that additional trailing commas for \gterm{mem-initializer-list}s
make "maintenance" easier.
Maintenance equally motivates trailing commas in function parameter lists.
However, \ref(P0562R2) holds function parameter lists to a double standard
where if you maintain such lists,
they are "ripe for refactoring" anyway.

This position is hypocritical, lacks reason,
and is out-of-touch with language development at large,
where trailing commas in function parameter lists have recently been added to
various programming languages (\ref(#trailing-commas-in-other-languages)).
In fact, developers write tremendously more function parameter lists and argument lists than
\gterm{mem-initializer-list}s,
so the former are more deserving of attention.

\h3{Could this syntax be used for something else?}

The idea has been floated on some mailing lists to give empty list elements special meaning,
such as using a default argument:

\cppblock{
void f(int x = 0, int y = 0);

f(, 1);    // OK, equivalent to f(0, 1)
f(1, );    // OK, equivalent to f(1, 0)
f(1,1,);   // error: third default argument requested, but only two parameters
}

Personally, I consider this idea terrible because of how non-descriptive it is;
a user could even unintentionally perform such calls by making a typo '\tcode{,,}'
somewhere in the argument list.
Using the syntax \tcode{f(1,1,)} to mean anything other than a function call
with two arguments and a trailing comma would be terribly confusing to developers
accustomed to trailing commas from other languages,
such as JavaScript or Kotlin developers (\ref(#trailing-commas-in-other-languages)).

\h3{Addressing criticisms}

\h4{Aesthetic objections}

I have unofficially polled the idea of trailing commas on social media
prior to drafting this proposal,
and a surprising amount of people objected to the idea.
Note that this was a blind poll without explaining the purpose of the feature beforehand.
When asking opponents of the idea why they don't like it,
the answers revolved around aesthetics.
In one case literally

\Bquote{
it looks ugly
}

Since trailing commas are foreign to both natural language and mathematical notation,
I can sympathize with this position.
However, we must keep two things in mind:

\ul{
  \li{
    Aesthetic perception is heavily influenced by familiarity.
    A Python developer likely perceives C++' use of special characters in
    \tcode{(!x && y)} or \tcode{int(T::*)} as "ugly".
    In practice, it is easy to get used to trailing commas.
    Since they are intended for multi-line scenarios,
    there is a fair amount of distance between '\tcode{,}' and e.g. \tcode{>} anyway.
  }
  \li{
    The job of WG21 is to standardize a programming language used by software engineers.
    Trailing commas have clear technical benefits laid out in \ref(#motivation),
    and clear technical benefits should always take precedence over matters of personal taste.
    If we had gotten hung up over \tcode{^^} and \tcode{[::]} "looking ugly",
    C++26 reflections would have died.
  }
}

\h4{Concerns over C compatibility}

Some concerns have been raised regarding the fact that only C++ but not C
would support the use of trailing commas.
This was alleged to make writing common C and C++ code harder.

However, the use of trailing commas is entirely optional,
so this claim is untrue.
It is not a stated design goal of C++ to make every possible line of C++ code valid C as well.
Instead, we maintain a common subset that is both valid C and valid C++.
If a developer wants to write C/C++-interoperable code,
they can simply not use trailing commas.

Furthermore, I intend to follow this proposal up with a WG14 counterpart
if it finds consensus.
For the sake of C++ compatibility,
it is plausible that WG14 would adopt the syntax as well;
this has been done with numerous features before.

\h4{Making previously ill-formed code valid}

Some people consider it a benefit that \tcode{f(0,)} is currently not allowed,
which may catch mistakes in some scenarios:

\Bquote{
Maybe I was typing, distracted, and forgot my last argument?
Maybe a macro expanded badly?
}

The problem with this line of reasoning is that there are infinite things
that a developer may forget to type
and infinite ways in which macros can expand into something unintended.
Trailing commas are not particularly inviting to mistakes.

Making obvious mistakes such as forgetting arguments likely results in a compiler error anyway,
unless that forgotten argument has a default argument.

\h4{Semantic inconsistencies with macros}

With the proposed syntax in function calls,
\tcode{f(0,)} would be valid for both regular functions and for function-style macros.
Previously, it would have only been valid if \tcode{f} is a function-style macro,
but the trailing comma would mean that we are passing two arguments, one of which is empty.

This does result in a bit of surprising behavior for non-variadic cases:
\cppblock{
void f(int x);
#define F(x)

f(0,);    // \serif{OK}
\hl(macro){F}(0,);    // \serif{error: two arguments provided, but only one parameter}
}

This inconsistency cannot be changed without altering the semantics of the preprocessor,
so it is here to stay.
However, it also seems largely inconsequential.
Users who are uncertain about whether \tcode{f} is a macro can choose
not to use a trailing comma; it is entirely optional.
Furthermore, trailing commas in variadic macros "just work":

\cppblock{
#define M(...) f(__VA_ARGS__)

// \serif{looks like four comma-separated macro arguments (last is empty), but three function arguments}
\hl(macro){M}(0, 1, 2,);
}

\h2{Implementation experience}

None.

\h2{Impact on existing code}

The proposal does not alter the meaning of any existing code;
it only makes previously ill-formed code valid.

\h2{Wording}

In \eelis{expr.prim.lambda.capture},
change the grammar as follows:

\style{
  .grammar {
    margin-left: 0;
  }
}

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{lambda-capture}:}
  \dd{capture-default \ins{\opt{\tcode{,}}}}
  \dd{capture-list \ins{\opt{\tcode{,}}}}
  \dd{capture-default \tcode{,} capture-list \ins{\opt{\tcode{,}}}}
}
}

In \eelis{dcl.pre#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{sb-identifier-list}:}
  \dd{sb-identifier \ins{\opt{\tcode{,}}}}
  \dd{\del{sb-identifier-list \tcode{,}} sb-identifier \ins{\tcode{,} sb-identifier-list}}
}
}

In \eelis{dcl.fct#2},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{parameter-declaration-clause}:}
  \dd{\tcode{...}}
  \dd{\opt{parameter-declaration-list}}
  \dd{parameter-declaration-list \tcode{,} \tcode{...}\ins{\opt}}
  \dd{parameter-declaration-list \tcode{...}}
}
}

In \eelis{dcl.init.general#1},
change the grammar as follows:

\Bdiff{
\etc

\dl(class=grammar){
  \dt{\grammarterm{braced-init-list}:}
  \dd{\tt{\N{LEFT CURLY BRACKET}} initializer-list \del{\opt{\tcode{,}}} \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\tt{\N{LEFT CURLY BRACKET}} designated-initializer-list \del{\opt{\tcode{,}}} \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\tt{\N{LEFT CURLY BRACKET}} \tt{\N{RIGHT CURLY BRACKET}}}
}

\dl(class=grammar){
  \dt{\grammarterm{initializer-list}:}
  \dd{initializer-clause \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{initializer-list \tcode{,}} initializer-clause \opt{\tcode{...}} \ins{\tcode{,} initializer-list}}
}

\dl(class=grammar){
  \dt{\grammarterm{designated-initializer-list}:}
  \dd{designated-initializer-clause \ins{\opt{\tcode{,}}}}
  \dd{\del{designated-initializer-list \tcode{,}} designated-initializer-clause \ins{\tcode{,} designated-initializer-list}}
}

\etc
}

In \eelis{dcl.attr.grammar#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{annotation-list}:}
  \dd{annotation \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{annotation-list \tcode{,}} annotation \opt{\tcode{...}} \ins{\tcode{,} annotation-list}}
}
}

In \eelis{temp.pre#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{template-parameter-list}:}
  \dd{template-parameter \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{template-parameter-list \tcode{,}} template-parameter \opt{\tcode{...}} \ins{\tcode{,} template-parameter-list}}
}
}

In \eelis{temp.names#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{template-argument-list}:}
  \dd{template-argument \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{template-argument-list \tcode{,}} template-argument \opt{\tcode{...}} \ins{\tcode{,} template-argument-list}}
}
}

If the proposed resolution of \ref(CWGGithub754) at the time of writing has been applied,
revert the change as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{expansion-init-list}:}
  \dd{\tt{\N{LEFT CURLY BRACKET}} expression-list \del{\tcode{,}}\opt \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\del{\tt{\N{LEFT CURLY BRACKET}} \tt{\N{RIGHT CURLY BRACKET}}}}
} 
}

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P0562R2,
  title = Trailing Commas in Base-clauses and Ctor-initializers,
  date = 2024-04-15,
  author = Alan Talbot,
  link = https://wg21.link/p0562r2,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r2.pdf,
)
\bib(
  id = P3312R1,
  title = Overload Set Types,
  date = 2025-04-16,
  author = Bengt Gustafsson,
  link = https://wg21.link/p3312r1,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf
)\
\bib(
  id = CWGGithub754,
  title = [stmt.expand] Trailing commas in an expansion-init-list should be permitted,
  date = 2025-08-24,
  author = Jan Schultke,
  link = https://github.com/cplusplus/CWG/issues/754,
)\
\bib(
  id = P0562R2ReflectorDiscussion,
  title = [isocpp-core] P0562R2 -- how is a compiler intended to find the end of a constructor definition?,
  date = 2024-06-27,
  link = https://lists.isocpp.org/core/2024/06/15961.php,
)\
\bib(
  id = CoreReflectorDiscussion,
  title = [isocpp-core] P3776R0 Review of grammar changes
  date = 2025-08-25,
  link = https://lists.isocpp.org/core/2025/08/18487.php,
)\
\bib(
  id = RustTrailingCommas,
  title = Rust Style Guide \N{EM DASH} Trailing commas,
  link = https://doc.rust-lang.org/style-guide/#trailing-commas,
)\
\bib(
  id = KotlinTrailingCommas,
  title = What's new in Kotlin 1.4.0 \N{EM DASH} Trailing comma,
  date = 2020-08-17,
  link = https://kotlinlang.org/docs/whatsnew14.html#trailing-comma,
)\
\bib(
  id = ECMAScriptTrailingCommas,
  title = Proposal to allow trailing commas in function parameter lists,
  link = https://github.com/tc39/proposal-trailing-function-commas,
)\
\bib(
  id = TypeScriptTrailingCommas,
  title = TypeScript 2.0 \N{EM DASH} Trailing commas in function parameter and argument lists,
  link = https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#trailing-commas-in-function-parameter-and-argument-lists,
)
\bib(
  id = CSharpTrailingCommas,
  title = Proposal: Allow trailing comma in tuples & argument lists,
  link = https://github.com/dotnet/csharplang/issues/1246,
)\
\bib(
  id = SwiftTrailingCommas,
  title = Allow trailing commas in parameter lists,
  link = https://forums.swift.org/t/allow-trailing-commas-in-parameter-lists/68549/29,
)\
\bib(
  id = RedditTrailingCommas,
  title = Does your language support trailing commas?,
  link = https://www.reddit.com/r/ProgrammingLanguages/comments/1amsalm/does_your_language_support_trailing_commas/,
)\
\bib(
  id = OldNewThing,
  title = On the virtues of the trailing comma,
  author = Raymond Chen,
  date = 2024-02-09,
  link = https://devblogs.microsoft.com/oldnewthing/20240209-00/?p=109379,
)\

\make_bib
