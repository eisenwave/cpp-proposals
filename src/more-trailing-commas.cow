\cowel_include{libwg21.cow}

\wg21_head(
    title = More trailing commas
){
\dl{
  \dt{Document number:} \dd{\docnum{D3776R1}}
  \dt{Date:}            \dd{\tt{2025-09-01}}
  \dt{Audience:}        \dd{EWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{Co-authors:}      \dd{Murat Can Çağrı <\mail{cancagri.dev@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3776/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/more-trailing-commas.cow)}
}
\hr
}

\Babstract{
C++ should support trailing commas in more places,
such as in function parameter lists.
}

\h2(listed = false){Contents}

\make_contents

\h2{Revision history}

\h3{Changes since R0}

\ul{
  \li{cited EWG polls in \ref(#recent-history)}
  \li{expanded and updated \ref(#trailing-commas-in-other-languages)}
  \li{elaborated on ClangFormat options in \ref(#improved-auto-formatter-control)}
  \li{added \ref(#preventing-string-joining-bugs)}
  \li{reworded \ref(#comparison-to-p0562r2)}
  \li{expanded \ref(#addressing-criticisms) based on EWG reflector discussion}
  \li{added Clang fork as \ref(#implementation-experience)}
  \li{added feature-test macro to \ref(#wording)}
  \li{various minor/editorial changes}
}

\h2{Introduction}

C++ permits the use of trailing commas in some lists, but not in others.
For example, trailing commas are permitted at the end of an \gterm{initializer-list},
but not following a
\gterm{mem-initializer-list},
\gterm{capture-list},
\gterm{template-parameter-list},
\gterm{expression-list},
in a \gterm{postfix-expression}, etc.
It would be convenient if the support for trailing commas was extended
to those other lists.

For example, the following should be valid:

\cppblock{
void f(
    int x,
    int y, // \N{LEFTWARDS ARROW} trailing comma here
);
}

\h3{Recent history}

While this proposal is new,
a very similar proposal \ref(P0562R2) has passed through EWG in Tokyo 2024.
\ref(P0562R2) argues in favor of trailing commas
following \gterm{mem-initializer-list}
and (following EWG feedback) \gterm{base-specifier-list},
with similar rationale as this proposal.

\Bquote{
Poll: D0562R1 — Initialization List Symmetry:
also add support for base class trailing commas.
\five_way_poll(18, 10, 2, 1, 0)

Result: Consensus

Poll: D0562R1 — Initialization List Symmetry: forward the paper
(with the addition of base class trailing comma) to CWG for inclusion in C++26.
\five_way_poll(12, 11, 4, 3, 0)

Result: Consensus
}

However, the subsequent revision \ref(P0562R2) was not polled
due to implementability concerns:
a comma after a \gterm{mem-initializer-list}
introduces a parsing ambiguity
between initializer lists and function bodies;
see Richard Smith's explanation at \ref(P0562R2ReflectorDiscussion):

\Bquote{
Classes are parsed in two phases: first, declarations are parsed, skipping
the bodies of member functions and a few other things, and then those
delayed parts are parsed in a context where the class is complete. 

For most functions, skipping the body in the first pass is easy. There's an
open brace, and you can just skip to the close brace. At worst, there's
\tcode{try \N{LEFT CURLY BRACKET}},
and you need to find the end of the last catch handler.

The problem is that a
\gterm{mem-initializer-id} can be a \gterm{template-id} that refers to a base class, and
the identifiers it uses to name the base class might be declared
(possibly after the constructor) in the same class \N{EM DASH} meaning that we've not parsed
them yet.
Therefore when we see a \tcode{<}, we don't know if it's introducing a
template argument list.
For example: 

\cppblock{
struct X {};
struct Y : X {
  Y() : A<b<c>(), {
  // ...
  }
  // A, b, and c declared down here somewhere
};
}

Are we in the body of the constructor yet?

Prior to P0562R2, the answer was no: an open brace preceded by a comma
cannot start the constructor body. For this to be valid, \tcode{b} must be a
template, and the \tcode{\N{LEFT CURLY BRACKET}} is then the start
of the second template argument of \tcode{A}. (\etc) 

But after P0562R2, the above example seems to become ambiguous, and I'm not
sure how an implementation would be able to parse it.
}

Following these developments in St. Louis 2024-06,
the proposal has seen no activity.
It seems like the baby has been thrown out with the bathwater here,
since the rationale of the proposal is still sound and
this ambiguity does not affect \gterm{base-specifier-list}s.

\h3{Trailing commas in other languages}

Various modern programming languages support trailing commas,
not just in initialization of classes or when listing \tcode{enum} members,
but also in function parameter lists or function argument lists.
We can see a clear trend:

\style{
  #lang-table {
    margin-left: auto;
    margin-right: auto;
    width: 95%;
  }
  #lang-table td {
    padding-bottom: 1em;
  }
}

\table(id = lang-table){
  \tr{
    \th{Language} \th{Trailing commas support}
  }
  \tr{
    \td{Swift}
    \td{
      Added support for trailing commas in parameter lists
      in 2025 (\ref(SwiftTrailingCommas)).
    }
  }
  \tr{
    \td{Kotlin}
    \td{
      Added support for trailing commas in parameter lists
      in 2020 (\ref(KotlinTrailingCommas)).
    }
  }
  \tr{
    \td{JavaScript}
    \td{
      Added support for trailing commas in parameter lists
      in ECMASCript2017 (\ref(ECMAScriptTrailingCommas)).
    }
  }
  \tr{
    \td{TypeScript}
    \td{
      Added support for trailing commas in parameter lists
      at the same time they was standardized for JavaScript (\ref(TypeScriptTrailingCommas)).
    }
  }
  \tr{
    \td{Rust}
    \td{
      Has always supported trailing commas in parameter lists.\br
      Use of trailing commas is recommended by the official style guide
      (\ref(RustTrailingCommas)).
    }
  }
  \tr{
    \td{Go}
    \td{
      Has always made it mandatory to use trailing commas in multi-line parameter lists
      (presumably to prevent implicit semicolon insertion).
    }
  }
  \tr{
    \td{Python}
    \td{
      Has always permitted the use of trailing commas in function parameter lists.
      Trailing commas in \tcode{(1,)} form unary tuples.
    }
  }
  \tr{
    \td{Julia}
    \td{
      Has always permitted the use of trailing commas in function parameter lists.
      Trailing commas in \tcode{(1,)} form unary tuples.
    }
  }
}

To the best of my knowledge,
trailing commas have been well-received by the users of these languages,
to the point where they are the default in e.g. the Rust Style Guide.
The motivation to have trailing commas in those languages equally applies to C++,
and is largely covered in \ref(#improved-text-editing) and \ref(#improved-version-control).

\Bnote{
Many more languages support trailing commas at least within braces,
such as C++, Java, C#, etc.

More discussion on this language design choice can also be found at
\ref(RedditTrailingCommas) and \ref(OldNewThing).
}

\h2{Motivation}

While trailing commas don't solve any major safety or performance issue,
they improve developer convenience significantly in some ways.
Given how many comma-separated lists developers regularly write,
this convenience can be noticeable on a daily basis.

\Bnote{
The following motivation uses only function parameter lists as motivating examples,
but the arguments equally apply to other comma-separated lists.
}

\h3{Improved text editing}

Advanced text editors typically have commands for cutting/copying whole lines,
or let the developer reorder lines via keyboard shortcut.
For example, a line can be swapped with the line above
with \kbd{Alt}+\kbd{\N{NO-BREAK SPACE}↑\N{NO-BREAK SPACE}} in VSCode.
This can result in compiler errors without trailing commas:

\cppblock{
void f(
    int x,
    int y
);
}

When reordering \tcode{int x,} and \tcode{int y}, errors are raised:

\cppblock{
void f(
    int y  // \N{DOWNWARDS ARROW WITH TIP LEFTWARDS} syntax error: "int" following "y"
    int x, // \N{LEFTWARDS ARROW} syntax error: trailing comma
);
}

If both lines had a trailing comma and C++ permitted that syntax,
reordering these lines would not be a problem.

\h3{Improved version control}

When an element is appended to a comma-separated list,
this means that the previous element needs to receive a separating comma,
resulting in menial changes:

\codeblock(diff){
 void f(
     int x,
-    int y
+    int y,
+    int z
 );
}

With trailing commas, we can turn a three-line change into a one-line change:

\codeblock(diff){
 void f(
     int x,
     int y,
+    int z,
 );
}

This smaller change is not just easier to review,
it also does not pollute the revision history (\tt{git blame}) for
the previous line of code,
and it does not introduce easily avoidable merge conflicts.

\h3{Improved auto-formatter control}

Many C++ developers auto-format their code using
\ref(https://clang.llvm.org/docs/ClangFormat.html){ClangFormat}.
One powerful feature it has is the ability to control
how brace-enclosed lists are formatted via the use of trailing commas.

\Bex{
ClangFormat "disables bin-packing" when a trailing comma is present,
as stated in
\ref(https://clang.llvm.org/docs/ClangFormatStyleOptions.html#inserttrailingcommas){\
the documentation of \tt{TrailingCommaStyle}}:

\cppblock{
vector<int> numbers { LIST_ITEM_A, LIST_ITEM_B,  //
                      LIST_ITEM_C };             // \N{LEFTWARDS ARROW} column limit here
                                                 // 
vector<int> numbers {
    LIST_ITEM_A,
    LIST_ITEM_B,
    LIST_ITEM_C, // \N{LEFTWARDS ARROW} trailing comma here
};
}

The version without a trailing comma may be situationally useful
by compactifying code, allowing more to fit on screen.
The verbose version with a trailing comma is more useful for regularly updated lists,
and can be perceived as more organized.
It's easy to envision the same example with function argument lists.
}

Trailing commas express the desire to format over multiple lines,
which auto-formatters may utilize.
Without support for trailing commas in e.g. function parameter lists,
the developer is robbed of their ability to (elegantly) express that desire,
since doing so would make the program ill-formed.

\Bnote{
A possible workaround for ClangFormat is to insert a trailing \tcode{//}
at the end of a line
(which forces line breaks to be retained),
or to manually format a section of code with \tcode{// clang-format off}.
}

\h3{Improved language consistency}

It is generally surprising that C++ only supports trailing commas
within a subset of its comma-separated lists.
Besides the design not sparking joy,
it creates practical problems.

For example, when refactoring code and e.g. converting list-initialization
such as \tcode{{1, 2, 3,}} which already uses trailing commas into direct-initialization
\tcode{(1, 2, 3,)},
the trailing comma introduces a compiler error until it is removed,
which is a mild inconvenience at least.

\h3(id = va-opt){Eliminating some uses of \tt{\hl(macro){__VA_OPT__}}}

When we want to prepend an element to a variadic macro argument,
we may need to use \tt{\hl(macro){__VA_OPT__}} in the following way:

\cppblock{
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define L(...) [& __VA_OPT__(,) __VA_ARGS__] {}
}

With an unconditional comma,
\tcode{\hl(macro){F}()} would expand to \tcode{f(0,)},
which is currently ill-formed.
A trailing comma in function calls and other lists would allow us to simplify such macros.

\Bnote{
While a \gterm{capture-default} like \tcode{&} is not part of the \gterm{capture-list},
a trailing comma should still be permitted following it.
Otherwise, the example above would still be broken.
}

\h3{Code generation convenience}

Allowing trailing commas makes it easier to generate C++ code,
for similar reasons as in \ref(#va-opt).
Generating lists is sometimes made easier if each element in a list can
be terminated by a comma, rather than adding special handling for the first/last element
to ensure no trailing commas in generated code.

\Bex{
Code generation for a list of function parameters
is simplified by trailing commas in C++ as follows:
\cppblock{
void emit_parameters(span<const Parameter> parameters) {
    emit('\N{LEFT PARENTHESIS}');
    \del{bool first = true;}
    for (const auto& p : parameters) {
\del{        if (!first) {
            emit(',');
        }
        first = false;}
        emit_parameter(p);
\ins{        emit(',');}
    }
    emit('\N{RIGHT PARENTHESIS}');
}
}
}

\h3{Preventing string joining bugs}

When appending a string literal to a list of arguments
and forgetting to add a comma,
our code may compile, but do the wrong thing:

\codeblock(diff){
 emplace_strings(
   "fee",
   "fie",
   "foe"
+  "fum"
 );
}

Rather than passing a four arguments,
the effect is as if the third argument was \tcode{"foe" "fum"},
which is valid and equivalent to \tcode{"foefum"}.
Among other causes, this may happen when pasting the line containing \tcode{"fum"}
into position.

This bug would be prevented by the use of trailing commas.
Even if we forget a comma after \tcode{"fum"},
there should already be one after \tcode{"foe"},
so nothing surprising happens:

\codeblock(diff){
 emplace_strings(
   "fee",
   "fie",
   "foe",
+  "fum"
 );
}

Furthermore, our linter or auto-formatter should enforce the use of commas there,
making the bug much easier to find.

\Bnote{
A similar bug is \em{enabled} by trailing commas:
we could swap the last and second-to-last line in a function call,
producing the now valid code:

\codeblock(cpp){
emplace_strings(
    "fee",
    "fie",
    "fum"
    "foe",
);
}

However, appending lines is more common than such a swap operation,
and as stated, linter or auto-formatter rules may reveal the lack of comma
following \tcode{"fum"}.
}

\h3{Motivating examples}

In discussions of this proposal,
there is often some skepticism as to whether it's useful for specific lists.
For example, I have been told that trailing commas may be useful
in a \gterm{template-parameter-list}, but not in a \gterm{template-argument-list}.
However, while some lists are more frequently multi-line,
you can come up with a plausible multi-line example for virtually any list:

\cppblock{
// \serif{\gterm{template-parameter-list}}
template <
    input_iterator I,
    sentinel_for<I> S,
    weakly_incrementable O, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
>
copy_result function(I first, S last, O result);

// \serif{\gterm{template-argument-list}}
using V = variant<
    int_least64_t,
    float,
    double,
    char8_t,
    char16_t,
    char32_t,
    bool,
    string, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
>;

// \serif{\gterm{function-parameter-list}}
void pretty_print_log(
    log_level level,
    string_view message,
    optional<code_location> location = {},
    optional<const error&> error = {}, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
);

// \serif{\gterm{function-argument-list}}
auto it = find(
    ranges::begin(container),
    ranges::end(container) + (container.size() / 2), // \N{LEFTWARDS ARROW} \serif{trailing comma here}
);

// \serif{\gterm{lambda-capture}}
auto callback = [
        &,
        current_index = 0,
        invocation_count = 0, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
    ] {
        ++invocation_count;
        // ...
    };

// \serif{\gterm{annotation-list}}
[[
    = testing::description("Fuzzing test for ASCII sequences."),
    = testing::execution::parallel, // \N{LEFTWARDS ARROW} \serif{trailing comma here}
]]
void fuzz_ascii() { /* ... */ }
}

For any of these list types, it is plausible that they are long enough
to be broken onto multiple lines,
and it is plausible that changes will be made to such lists in the future,
which makes a trailing comma useful in these lists.

\h2{Design}

I propose to add a trailing comma after a list whenever possible
(i.e. no parsing issues are introduced),
with the exception of lists terminated by a semicolon.
The design can be summed up as:

\Bquote{
When enclosed by \tcode{{}}, \tcode{()}, \tcode{[]}, or \tcode{<>},
lists can have a trailing comma.
}

All the following decisions are intended to make that rule of thumb correct.
Cherry-picking individual cases like permitting \tcode{array[a,b,]}
but not \tcode{[a,b,]{}} would only complicate the situation.

\h3{New trailing commas}

The following trailing commas are proposed,
and not currently permitted.

\cppblock{
[: /* ... */ :]<A, B,>              // \serif{\gterm{template-argument-list} in \gterm{splice-specialization-specifier}}
[]<A, B,>{}                         // \serif{\gterm{template-parameter-list} in \gterm{lambda-expression}}
[a, b,]{}                           // \serif{\gterm{capture-list} in \gterm{lambda-introducer}}
d[a, b,]                            // \serif{\gterm{expression-list} in subscript operator}
f(a, b,)                            // \serif{\gterm{expression-list} in call operator}
T(0,)                               // \serif{\gterm{expression-list} in function-style cast}
typename T(0,)                      // \serif{\gterm{expression-list} in function-style cast with \tcode{typename}}
new (a, b,) T                       // \serif{\gterm{expression-list} in \gterm{new-placement}}
new T(a, b,)                        // \serif{\gterm{expression-list} in \gterm{new-initializer}}
template for (int _ : { a, b, })    // \serif{\gterm{expression-list} in \gterm{expansion-init-list}}
auto [a, b,]                        // \serif{\gterm{sb-identifier-list} in \gterm{structured-binding-declaration}}
T f(a, b,)                          // \serif{\gterm{parameter-declaration-list} in \gterm{parameter-declaration-clause}}
T x(a, b,);                         // \serif{\gterm{expression-list} in \gterm{initializer}}
[[=a, =b,]]                         // \serif{\gterm{annotation-list} in \gterm{attribute-specifier}}
S() : m(a, b,)                      // \serif{\gterm{expression-list} in \gterm{mem-initializer}}
template<a, b,>                     // \serif{\gterm{template-parameter-list} in \gterm{template-head}}
template<C<a, b,> T>                // \serif{\gterm{template-argument-list} in \gterm{type-constraint}}
template<template<A, B,> concept>   // \serif{\gterm{template-parameter-list} in \gterm{concept-tt-parameter}}
T<A, B,>                            // \serif{\gterm{template-argument-list} in \gterm{simple-template-id}}
operator()<A, B,>                   // \serif{\gterm{template-argument-list} in \gterm{template-id}}
}

While this initially appears like a huge change,
it can be easily worded by incorporating the trailing comma directly
into lists such as \gterm{expression-list},
since every occurrence of these lists would allow for trailing commas.

\Bnote{
Of these, the \gterm{expression-list} in an \gterm{expansion-init-list} seems like a C++26 defect,
and a CWG issue has been requested at \ref(CWGGithub754).
Since this appears to be a separate C++26 defect,
not a new C++29 feature,
this paper's wording does not include that fix.
}

\Bnote{
Trailing commas would also be supported following a \gterm{capture-default},
such as in \tcode{[&,]}.
This is worth mentioning because a \gterm{capture-default} is not actually part of a
\gterm{capture-list}, but a standalone element within a \gterm{lambda-capture}.
}

\h4{Addressing ambiguity concerns}

Note that all of these proposed cases are safe from parsing ambiguities
encountered by \ref(P0562R2).
That is because a the trailing comma can only be followed by
'\tcode{\N{RIGHT CURLY BRACKET}}',
'\tcode{\N{RIGHT PARENTHESIS}}',
'\tcode{\N{RIGHT SQUARE BRACKET}}', or
'\tcode{>}'.
In the first three cases,
a closing bracket cannot possibly be the beginning of a new element,
only the end whatever encloses list.
Neither '\tcode{>}', '\tcode{>=}', nor '\tcode{>>}' are prefix unary operators,
so in any case, '\tcode{,>}' can only mean one thing.

Furthermore, \tcode{operator,} cannot be separated into \tcode{operator} and '\tcode{,}'
or combined into \tcode{operator,>} (there is no '\tcode{,>}' operator in the language),
so no ambiguity can be introduced by having \tcode{operator} appear at the end of a list.

\h3{Already supported trailing commas}

The following trailing commas are already supported:

\cppblock{
{ a, b, }                 // \serif{\gterm{initializer-list} in \gterm{braced-init-list}}
{ .a=0, .b=0, }           // \serif{\gterm{designated-initializer-list} in \gterm{braced-init-list}}
enum { a, b, }            // \serif{\gterm{enumerator-list} in \gterm{enum-specifier}}
[[a,b,,,,]]               // \serif{\gterm{attribute-list} in \gterm{attribute-specifier}}
}

\h3{Not proposed trailing commas}

\h4{Commas proposed in P0562R2}

The following two trailing commas are proposed by \ref(P0562R2) and should be added,
if at all possible,
as a revision of that paper.

\cppblock{
S() : a{}, b{},           // \serif{\gterm{mem-initializer-list} in \gterm{ctor-initializer}}
struct S : A, B, { };     // \serif{\gterm{base-specifier-list} in \gterm{base-clause}}
}

While the parsing ambiguity (\ref(#recent-history))
seems limited to a \gterm{mem-initializer-list},
a \gterm{base-specifier-list} is similarly followed by \tcode{\N{LEFT CURLY BRACKET}},
which makes it quite plausible that similar parsing issues could affect that case.
In any case, to keep this paper focused,
I do not propose those two commas.

\h4{Trailing commas in semicolon-terminated lists}

Two more commas are not proposed because they are in semicolon-terminated lists:

\cppblock{
int a, b,;                // \serif{\gterm{init-declarator-list} in \gterm{simple-declaration}}
struct S { int a, b,; };  // \serif{\gterm{member-declarator-list} in \gterm{member-declaration}}
friend A, B,;             // \serif{\gterm{friend-type-specifier-list} in \gterm{friend-type-declaration}}
using a, b,;              // \serif{\gterm{using-declarator-list} in \gterm{using-declaration}}
}

Firstly, for aesthetic reasons, it is unlikely that users would want to write this.
Furthermore, multiple elements in a \gterm{init-declarator-list} are already
discouraged by some style guides.
Last but not least, the \ref(#motivation) of this paper focuses on multi-line scenarios.
In the aforementioned cases,
to make good use of trailing commas,
developers would need to write:

\cppblock{
int
    a,
    b,
;

using
    a,
    b,
;
}

Not only is this exotic, it is also more verbose than the status quo,
which already allows reordering lines if we instead write:

\cppblock{
int a;
int b;

using a;
using b;
}

Overall, permitting trailing commas
in a \gterm{init-declarator-list} or \gterm{using-declarator-list} seems unmotivated,
and would create unnecessary work for implementers.

\h4{Non-lists}

The following trailing commas are not proposed because they are not following a list:

\cppblock{
static_assert(true,"",)   // \serif{\gterm{static_assert-declaration}}
contract_assert(true,)    // \serif{\gterm{assertion-statement}}
= delete("",)             // \serif{\gterm{deleted-function-body}}
}

While it may be more philosophically consistent to permit a comma within anything
that vaguely looks like a function call,
there is little motivation for such cases above.
To be fair, a trailing comma could yield a minimal one-line change as follows:

\codeblock(diff){
 static_assert(
     true,
+    "message"
 );
}

However, it seems unlikely that a developer would choose to distribute a no-message
\tcode{static_assert} over three lines in the first place.
Overall, these cases just seem to add more work for implementers.

\h4{Commas following ellipsis parameters}

Another not proposed trailing comma is that after an ellipsis parameter:

\cppblock{
void f(
  int x,
  ...,    // \serif{after \tcode{...} in \gterm{parameter-declaration-clause}}
);
}

This decision is largely based on negative feedback in \ref(CoreReflectorDiscussion).

The trailing comma in this place is largely unmotivated because the ellipsis is always
the last element in the list.
Consequently, a \tcode{...} line cannot be reordered with the line before,
and a comma will never have to be inserted after \tcode{...} to accommodate a subsequent element.

\h4{Commas in macros}

The following trailing commas are not proposed:

\cppblock{
#define M(x,y,) // \serif{\gterm{identifier-list} in \gterm{control-line}}
\hl(macro){M}(x,y,)         // \serif{arguments to a function-like macro}
}

The former lacks motivation because it is highly unlikely
that a C++ use would define multi-line parameters to a function-style macro.
Doing so requires each parameter line to be terminated by \tcode{\\},
among other reasons.

Supporting trailing commas in \tcode{\hl(macro){M}(x,y,)}
would alter the meaning of existing code.
Currently, that expression is providing three arguments to \tcode{\hl(macro){M}},
the last of which is empty.

\h3{Comparison to P0562R2}

It is worth noting that \ref(P0562R2) did not propose trailing commas
in function and template parameters
with the following rationale:

\Bquote{
Function and template parameters do not allow a final terminating comma,
but these do not  trouble me in practice.
(Arguably any function or template with enough parameters to be much 
of a maintenance issue seems like it is ripe for refactoring.)
This paper does not propose changing function or template parameters.
}

Note that \ref(P0562R2) argues that additional trailing commas for \gterm{mem-initializer-list}s
make "maintenance" easier.
Maintenance equally motivates trailing commas in function parameter lists.
However, \ref(P0562R2) holds function parameter lists to a double standard
where if you maintain such lists,
they are "ripe for refactoring" anyway.

This position is poorly motivated and out-of-touch with language development at large.
Trailing commas in function parameter lists have recently been added to
various programming languages (\ref(#trailing-commas-in-other-languages)).
In fact, developers write tremendously more function parameter lists and argument lists than
\gterm{mem-initializer-list}s,
so the former are more deserving of attention.

\h2{Addressing criticisms}

\h3{Aesthetic objections}

I have unofficially polled the idea of trailing commas on social media
prior to drafting this proposal,
and a surprising amount of people objected to the idea.
Some negative feedback was also given on R0 of this paper on the EWG reflector.
A surprising amount of negative feedback revolved around aesthetics,
ranging from "it looks ugly" to
"this makes me deeply uncomfortable".
This is a valid concern.
Since trailing commas are foreign to both natural language and mathematical notation,
I can sympathize with this position.
However, we must keep some things in mind:

\ul{
  \li{
    Trailing commas are entirely optional,
    so if they cause one discomfort,
    it is possible to avoid them,
    at least in one's own personal projects and possibly their code at work.
  }
  \li{
    Aesthetic perception is heavily influenced by familiarity.
    A Python developer likely perceives C++' use of special characters in
    \tcode{(!x && y)} or \tcode{int(T::*)} as "ugly".
    To many, it is easy to get used to trailing commas.
    Since they are intended for multi-line scenarios,
    there is a fair amount of distance between '\tcode{,}' and e.g. \tcode{>} anyway.
  }
  \li{
    The job of WG21 is to standardize a programming language used by software engineers.
    Trailing commas have clear technical benefits laid out in \ref(#motivation),
    and clear technical benefits should always take precedence over aesthetics.
    If we had gotten hung up over the aesthetics of \tcode{^^} and \tcode{[::]},
    C++26 reflections would have died.
  }
}

\h3{Concerns over C compatibility}

Some concerns have been raised regarding the fact that only C++ but not C
would support the use of trailing commas.
This was alleged to make writing common C and C++ code harder.

However, the use of trailing commas is entirely optional,
so this claim is untrue.
It is not a stated design goal of C++ to make every possible line of C++ code valid C as well.
Instead, we maintain a common subset that is both valid C and valid C++.
If a developer wants to write C/C++-interoperable code,
they can simply not use trailing commas.

Furthermore, I intend to follow this proposal up with a WG14 counterpart
if it finds consensus.
For the sake of C++ compatibility,
it is plausible that WG14 would adopt the syntax as well;
this has been done with numerous features before.

\h3{Making previously ill-formed code valid, possibly inviting bugs}

Some people consider it a benefit that \tcode{f(0,)} is currently not allowed,
which may catch mistakes in some scenarios:

\Bquote{
Maybe I was typing, distracted, and forgot my last argument?
Maybe a macro expanded badly?
}

However, there are numerous counter-arguments to this concern:
\ul{
  \li{
    Single-line trailing comma uses like \tcode{f(0,)}
    (which are unmotivated, and most likely how such a mistake is spelled)
    can also be diagnosed by linters and compilers.
    This would be similar to the \tt{only-multiline} string option
    for \ref(https://eslint.style/rules/comma-dangle#comma-dangle){ESLint Stylistic's}
    \tt{comma-dangle} rule.
  }
  \li{
    C++ is a statically typed language,
    so forgetting an argument, whether spelled \tcode{f(0)} or \tcode{f(0,)}, likely
    results in an error anyway (no matching overload).
  }
  \li{
    We know based on C++ user experience with trailing commas in braced lists
    as well as user experience from other languages with trailing comma support,
    that this is not rampant problem.
    I was unable to find an authoritative style guide for any language
    that recommends against the use of trailing commas.
    One would expect such a style guide to exist if trailing commas were a common source of bugs.
  }
}

Last but not least, it is worth remembering one of C++' design principles
(see Design and Evolution of C++ \N{EM DASH} 4.3 Design Support Rules):

\Bquote{
It is more important to allow a useful feature than to prevent every misuse.
}

\h3{Semantic inconsistencies with macros}

With the proposed syntax in function calls,
\tcode{f(0,)} would be valid for both regular functions and for function-style macros.
The trailing comma has different meaning in those two:

\cppblock{
void f(int x);
#define F(x)

f(0,);    // \serif{OK}
\hl(macro){F}(0,);    // \serif{error: two arguments provided, but only one parameter}
}

This inconsistency cannot be changed without altering the semantics of the preprocessor,
so it is here to stay.
However, the syntax of function-style macro expansions and function calls is already
inconsistent:

\cppblock{
f({1,});  // \serif{Passing one argument containing an initializer list to a function}
\hl(macro){F}({1,});  // \serif{Expanding function-style macro with two arguments (the second argument is a closing brace)}
}

As things stand, function calls need to be "massaged" a bit to also be valid macro expansions,
e.g. via the use of parentheses.
Users who are uncertain about whether \tcode{f} is a macro can choose
not to use a trailing comma; it is entirely optional.
Furthermore, trailing commas in variadic macros "just work":

\cppblock{
#define M(...) f(__VA_ARGS__)

// \serif{expands to \tt{f(0, 1, 2,)}}
\hl(macro){M}(0, 1, 2,);
}

\h3{Multiple ways to do the same thing}

A common and generally good rule of thumb in programming language design is:

\Bquote{
Don't introduce multiple ways to do the same thing.
}

It could be argued that we can already spell parameter lists without a trailing comma,
so it is bad to add a second way.
However, this rule is not universally and innately true;
it is important to understand why one may follow it:

\ul{
  \li{
    Multiple ways of doing the same thing makes a language harder to teach.
  }
  \li{
    If we can already do the same thing a different way, no value is added to the language.
  }
}

The first motivation hardly applies because C++ already supports trailing commas in some lists.
One could argue the language becomes \em{more} teachable by fixing this inconsistency
and permitting it in all lists.
Even if that argument is not accepted,
the teaching effort for an optional punctuation character is microscopic.

Secondly, \ref(#motivation) lays out numerous ways in which trailing commas
add value to the language.
It would be hard to argue that \tcode{// line comments} add no value to the language
because \tcode{/* block comments */} exist,
or that \tcode{1s} adds no value because \tcode{std::chrono::seconds(1)} exists.
It is fine to have multiple spellings of the same feature
when there are clear technical benefits to both spellings.
There are no hard rules in language design, only trade-offs and rules of thumb.

\h3{Claiming syntax space}

Concerns have been expressed that permitting trailing commas would claim
syntax space, so that \tcode{f(0,)} could not be given other meaning in the future.
Specifically, empty list elements could be given special meaning,
such as using a default argument:

\cppblock{
void f(int x = 0, int y = 0);

f(, 1);    // OK, equivalent to f(0, 1)
f(1, );    // OK, equivalent to f(1, 0)
f(1,1,);   // error: third default argument requested, but only two parameters
}

Firstly, note that \tcode{f(1,)} has the effect of passing
a default argument for \tcode{y}, no matter the meaning of a trailing comma.
\tcode{f(1,1,)} would be a special case,
but in principle, trailing commas are compatible with these hypothetical semantics.

Secondly, I consider this idea terrible because of how non-descriptive it is;
a user could even unintentionally perform such calls by making a typo '\tcode{,,}'
somewhere in the argument list.
Using the syntax \tcode{f(1,1,)} to mean anything other than a function call
with two arguments and a trailing comma would be terribly confusing to developers
accustomed to trailing commas from other languages,
such as JavaScript or Kotlin developers (\ref(#trailing-commas-in-other-languages)).

Without a plausible alternative use for the syntax
concerns over claiming syntax space have little relevance.
Even the people bringing up these syntax space concerns
are not confident that this "default argument passing" could find consensus.

\h2{Implementation experience}

This proposal has been implemented by Can Çağrı in a \ref(ClangFork),
and can be tested at \ref(CompilerExplorerDemo).
The implementation is a simple parser change of approximately 40 lines of code.

\h2{Impact on existing code}

The proposal does not alter the meaning of any existing code;
it only makes previously ill-formed code valid.

\h2{Wording}

In \eelis{expr.prim.lambda.capture},
change the grammar as follows:

\style{
  .grammar {
    margin-left: 0;
  }
}

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{lambda-capture}:}
  \dd{capture-default \ins{\opt{\tcode{,}}}}
  \dd{capture-list \ins{\opt{\tcode{,}}}}
  \dd{capture-default \tcode{,} capture-list \ins{\opt{\tcode{,}}}}
}
}

In \eelis{dcl.pre#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{sb-identifier-list}:}
  \dd{sb-identifier \ins{\opt{\tcode{,}}}}
  \dd{\del{sb-identifier-list \tcode{,}} sb-identifier \ins{\tcode{,} sb-identifier-list}}
}
}

In \eelis{dcl.fct#2},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{parameter-declaration-clause}:}
  \dd{\tcode{...}}
  \dd{\opt{parameter-declaration-list}}
  \dd{parameter-declaration-list \tcode{,} \tcode{...}\ins{\opt}}
  \dd{parameter-declaration-list \tcode{...}}
}
}

In \eelis{dcl.init.general#1},
change the grammar as follows:

\Bdiff{
\etc

\dl(class=grammar){
  \dt{\grammarterm{braced-init-list}:}
  \dd{\tt{\N{LEFT CURLY BRACKET}} initializer-list \del{\opt{\tcode{,}}} \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\tt{\N{LEFT CURLY BRACKET}} designated-initializer-list \del{\opt{\tcode{,}}} \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\tt{\N{LEFT CURLY BRACKET}} \tt{\N{RIGHT CURLY BRACKET}}}
}

\dl(class=grammar){
  \dt{\grammarterm{initializer-list}:}
  \dd{initializer-clause \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{initializer-list \tcode{,}} initializer-clause \opt{\tcode{...}} \ins{\tcode{,} initializer-list}}
}

\dl(class=grammar){
  \dt{\grammarterm{designated-initializer-list}:}
  \dd{designated-initializer-clause \ins{\opt{\tcode{,}}}}
  \dd{\del{designated-initializer-list \tcode{,}} designated-initializer-clause \ins{\tcode{,} designated-initializer-list}}
}

\etc
}

In \eelis{dcl.attr.grammar#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{annotation-list}:}
  \dd{annotation \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{annotation-list \tcode{,}} annotation \opt{\tcode{...}} \ins{\tcode{,} annotation-list}}
}
}

In \eelis{temp.pre#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{template-parameter-list}:}
  \dd{template-parameter \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{template-parameter-list \tcode{,}} template-parameter \opt{\tcode{...}} \ins{\tcode{,} template-parameter-list}}
}
}

In \eelis{temp.names#1},
change the grammar as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{template-argument-list}:}
  \dd{template-argument \opt{\tcode{...}} \ins{\opt{\tcode{,}}}}
  \dd{\del{template-argument-list \tcode{,}} template-argument \opt{\tcode{...}} \ins{\tcode{,} template-argument-list}}
}
}

If the proposed resolution of \ref(CWGGithub754) at the time of writing has been applied,
revert the change to \eelis{stmt.expand} as follows:

\Bdiff{
\dl(class=grammar){
  \dt{\grammarterm{expansion-init-list}:}
  \dd{\tt{\N{LEFT CURLY BRACKET}} expression-list \del{\tcode{,}}\opt \tt{\N{RIGHT CURLY BRACKET}}}
  \dd{\del{\tt{\N{LEFT CURLY BRACKET}} \tt{\N{RIGHT CURLY BRACKET}}}}
} 
}

Add the following table row to \eelis{cpp.predefined#tab:cpp.predefined.ft}:

\Bdiff{
\itemdecl{
\ins{__cpp_trailing_comma 20XXXXL}
}
}

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P0562R2,
  title = Trailing Commas in Base-clauses and Ctor-initializers,
  date = 2024-04-15,
  author = Alan Talbot,
  link = https://wg21.link/p0562r2,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0562r2.pdf,
)
\bib(
  id = P3312R1,
  title = Overload Set Types,
  date = 2025-04-16,
  author = Bengt Gustafsson,
  link = https://wg21.link/p3312r1,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf
)\
\bib(
  id = CWGGithub754,
  title = [stmt.expand] Trailing commas in an expansion-init-list should be permitted,
  date = 2025-08-24,
  author = Jan Schultke,
  link = https://github.com/cplusplus/CWG/issues/754,
)\
\bib(
  id = P0562R2ReflectorDiscussion,
  title = [isocpp-core] P0562R2 -- how is a compiler intended to find the end of a constructor definition?,
  date = 2024-06-27,
  link = https://lists.isocpp.org/core/2024/06/15961.php,
)\
\bib(
  id = CoreReflectorDiscussion,
  title = [isocpp-core] P3776R0 Review of grammar changes
  date = 2025-08-25,
  link = https://lists.isocpp.org/core/2025/08/18487.php,
)\
\bib(
  id = RustTrailingCommas,
  title = Rust Style Guide \N{EM DASH} Trailing commas,
  link = https://doc.rust-lang.org/style-guide/#trailing-commas,
)\
\bib(
  id = KotlinTrailingCommas,
  title = What's new in Kotlin 1.4.0 \N{EM DASH} Trailing comma,
  date = 2020-08-17,
  link = https://kotlinlang.org/docs/whatsnew14.html#trailing-comma,
)\
\bib(
  id = ECMAScriptTrailingCommas,
  title = Proposal to allow trailing commas in function parameter lists,
  link = https://github.com/tc39/proposal-trailing-function-commas,
)\
\bib(
  id = TypeScriptTrailingCommas,
  title = TypeScript 2.0 \N{EM DASH} Trailing commas in function parameter and argument lists,
  link = https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#trailing-commas-in-function-parameter-and-argument-lists,
)\
\bib(
  id = SwiftTrailingCommas,
  title = Swift 6.1 Released \N{EM DASH} Productivity Enhancements,
  date = 2025-03-31,
  link = https://www.swift.org/blog/swift-6.1-released/#productivity-enhancements,
)\
\bib(
  id = RedditTrailingCommas,
  title = Does your language support trailing commas?,
  link = https://www.reddit.com/r/ProgrammingLanguages/comments/1amsalm/does_your_language_support_trailing_commas/,
)\
\bib(
  id = OldNewThing,
  title = On the virtues of the trailing comma,
  author = Raymond Chen,
  date = 2024-02-09,
  link = https://devblogs.microsoft.com/oldnewthing/20240209-00/?p=109379,
)\
\bib(
  id = ClangFork,
  author = Murat Can Çağrı,
  link = https://github.com/term-est/llvm-project/tree/P3776-More-Trailing-Commas,
)\
\bib(
  id = CompilerExplorerDemo,
  link = https://godbolt.org/z/jf9xsbMq8,
)\

\make_bib
