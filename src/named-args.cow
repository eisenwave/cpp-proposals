\cowel_include{libwg21.cow}

\wg21_head(
  title = Named function arguments
){
\dl{
  \dt{Document number:} \dd{\docnum{D3777R0}}
  \dt{Date:}            \dd{\tt{2025-09-14}}
  \dt{Audience:}        \dd{EWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{\
Jan Schultke <\mail{janschultke@gmail.com}>\br
Murat Can Çağrı <\mail{cancagri.dev@gmail.com}>\br
Matthias Wippich <\mail{mfwippich@gmail.com}>\br
Lénárd Szolnoki <\mail{cpp@lenardszolnoki.com}>\
}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3777/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/named-args.cow)}
}
\hr
}

\Babstract{
We propose a syntax for calling C++ functions with named arguments.
}

\h2(listed=false){Contents}

\make_contents

\h2{Introduction}

We propose a syntax for calling C++ functions with named arguments:

\cppblock{
f(.x = 0, .y = 1, .z = 2);
}

There is no consensus yet on whether changes to C++ function declarations are needed
to opt into this call syntax.

A call syntax like this has been suggested multiple times historically
in \ref(N4172), \ref(P0671R2), and \ref(P1229R0),
but never in a way that found consensus in WG21.
Nonetheless, this shows that there is interest in the feature,
and perhaps,
if approached the right way,
the idea could succeed.

\h3(id=why-no-struct){Why not just use a \tt{struct} and designated initializers?}

A common criticism of the idea is that rather than using named arguments,
one could use a \tcode{struct}.

\Bex{
\cppblock{
struct lerp_args {
  double a, b, t;
};
double lerp(lerp_args args);

lerp({ .a = 10., .b = 20., .t = 0.5 });
}
}

While this seemingly solves the issue,
upon further thought,
this is not a good solution for the following reasons:

\h4{No templates}

The \tcode{lerp} approach cannot be used in a template like
\tcode{template<class T> T lerp(lerp_args<T>)},
or at least, a call like \tcode{lerp(lerp_args{/* ... */})} would be necessary.
To be fair, this problem may be solved by permitting CTAD for function parameters,
for some cases.
It does not work for forwarding references.
However, even if that approach worked,
it would require the user to create \em{really} complicated class templates
for parameter sets like the ones we have in \header{algorithm}.

\h4{Worse overload resolution}

With the proposed semantics,
overloads are eliminated as non-viable candidates extremely early,
on the basis of not having matching parameter names.
For the \tcode{struct} approach,
when an overload cannot be called due to a name mismatch,
this happens at a later stage:
when forming implicit conversion sequences.

\Bnote{
See also \ref(#simplifying-overload-resolution).
}

\h4{Complexity and inconvenience}

Users don't want to maintain these additional parameter \tcode{struct}s.
They make a simple problem of passing named arguments more tedious than it needs to be.
Realistically, proposing to add an overload to \tcode{std::lerp}
that took \tcode{std::lerp_args} would likely not be fruitful.
While the existing declaration is obviously problematic,
it would be a huge burden
on the committee to maintain these additional argument \tcode{struct}s.
Library authors in general face the same problem.

\h4{Dilemma of choice}

Even when designing new functions from scratch,
it \em{feels} unnecessary and much more complex to pass all arguments via \tcode{struct}
rather than simply writing a function.
In a code base where passing arguments via \tcode{struct} is common,
one constantly has to make the choice whether to pass normally, via \tcode{struct},
or perhaps both.
This adds up to wasted developer time.
Named arguments let us have our cake and eat it too.

\h4{ABI and performance considerations}

In most ABIs, when a \tcode{struct} is sufficiently large,
it will not be passed by register.
Inlining can sometimes solve this issue,
but especially for larger mathematical functions,
it should not be relied upon,
and these ABI issues can result in degraded performance.

\Bex{
Consider the following code sample
(with bad and naive implementation of linear interpolation):

\cppblock{
struct lerp_args { double a, b, t; }

double lerp(double a, double b, double t) {
  return (1 - t) * a + t * b;
}
double lerp(lerp_args args) {
  return (1 - args.t) * args.a + t * args.b;
}
}

The second overload is not only clunkier to write,
it also results in worse \tt{-O2} codegen with Clang 21 (targeting the x86-64 psABI):

\codeblock(asm){
.LCPI0_0:
        .quad   0x3ff0000000000000
\hl(id-label){lerp(double, double, double)}:
        movsd   xmm3, qword ptr [rip + .LCPI0_0] ; load 1.0 rip-relative
        subsd   xmm3, xmm2
        mulsd   xmm1, xmm2
        mulsd   xmm0, xmm3
        addsd   xmm0, xmm1
        ret

.LCPI1_0:
        .quad   0x3ff0000000000000
\hl(id-label){lerp(lerp_args)}:
        movsd   xmm1, qword ptr [rsp + 24]       ; load t from stack
        movsd   xmm0, qword ptr [rip + .LCPI1_0] ; load 1.0 rip-relative
        subsd   xmm0, xmm1
        mulsd   xmm1, qword ptr [rsp + 16]       ; load b from stack
        mulsd   xmm0, qword ptr [rsp + 8]        ; load a from stack
        addsd   xmm0, xmm1
        ret
}

This problem is extremely common, not specific to the x86-64 ABI.
To name one other example,
in the Basic C ABI for WebAssembly,
\tcode{lerp(double, double, double)} would compile to \tcode{(f64, f64, f64)} parameters
whereas \tcode{lerp_args} would be passed indirectly, i.e. via \tcode{(i32)} memory address.
}

These ABI problems make the prospect of using a \tcode{struct}
extremely unattractive for high-performance mathematical functions.
This is especially unfortunate considering that functions such as
\tcode{lerp} and \tcode{clamp} could significantly benefit from
argument names at the call site.

\Bnote{
See also \ref(#preventing-common-bugs).
}

\h4{Freezing API}

With \tcode{lerp} as specified as above,
the user is able to store and pass around \tcode{lerp_args},
meaning that any change to it, such as turning it into a class template
could break API and ABI.
In general, creating a \tcode{struct} for a set of parameters freezes that parameter set.
This would be unacceptable in e.g. the C++ standard library.
The functions specified there are deliberately stated to be "non-addressable"
so that changes to overload sets can be made.
For example, a single function in \header{algorithm} stated to take an iterator
could actually be implemented using two separate overloads:
one for forward iterators and one for random access iterators.

\h3{Other workarounds}

While creating a \tcode{struct} is most commonly cited as a workaround,
other options to provide named arguments are sometimes mentioned:

\cppblock{
// proposed, for reference
lerp(.a = 50, .b = 100, .t = 0.5);

// "Fluent Interface"
lerp{}
  .a(50)
  .b(100)
  .t(0.5)
  ();

// "parameter types"
lerp(Range{50, 100}, 0.5);
}

In short, \ref(https://en.wikipedia.org/wiki/Fluent_interface){Fluent Interfaces}
use member function chaining so that each argument is provided individually
to some kind of "builder class".
The parameter types technique involves various parameter-specific types
rather than working with scalar values,
which often makes misuse of functions less likely thanks to the type system.
These workarounds share most of the problems described in \ref(#why-no-struct).
Situationally, they can be quite reasonable.
For example, bundling the \tcode{a} and \tcode{b} parameters of \tcode{lerp}
in a \tcode{Range} class does make it unlikely that the function is misused,
and it's relatively lightweight.

As good as they sometimes are,
these workarounds only chip away at the massive problems we have.
For example, to prevent misuses of the \tcode{string} constructor,
are we seriously proposing to write code like this in the future?

\cppblock{
\del{cout << string(100, 'a');}
\ins{cout << string(size_arg{100}, char_arg{'a'});}
}

Should C++ developers generally be expected to design their APIs like this?
In practice, neither LEWG nor library developers at large want this.
It takes an absurd amount of API design effort,
extra written code,
and slower compilation.
A side-by-side comparison should make it obvious why these techniques are undesirable:

\style{
  .center {
    margin-left: auto;
    margin-right: auto;
  }
}

\table(class=center){
  \tr{
    \th{Parameter types}
    \th{Named arguments}
  }
  \tr{
  \td{
    \codeblock(cpp,borders=false){
struct size_arg {
  size_t value;
};
struct char_arg {
  char value;
};
// ...
string(size_arg size, char_arg c);
// ...
cout << string(size_arg{100}, char_arg{'a'});
}
  }
  \td{
    \codeblock(cpp,borders=false){
string(size_t size, char c);
// ...
cout << string(.size = 100, .c = 'a');
}
  } 
  }
}

\Bnote{
For the sake of simplicity,
this comparison ignores some nuances,
like \tcode{basic_string}, \tcode{CharT}, \tcode{size_type}, etc.
With those details involved,
parameter types become even less attractive because the technique would require
creating a large amount of class templates and relying on CTAD
rather than working with simple \tcode{struct}s.
}

\h2{Prior Art}

\h3{N4172 "Named arguments"}

\ref(N4172) proposed the following syntax:

\cppblock{
void draw_rect(int left, int top, int width, int height, bool fill_rect = false);
int main()
{
  // Both of the function calls below pass the same set of arguments to draw_rect.
  draw_rect(top: 10, left: 100, width: 640, height: 480);
  draw_rect(100, 10, height: 480, fill_rect: false, width: 640);
}
}

Functionally, our proposal is almost identical to \ref(N4172),
with a few key differences:

\ul{
  \li{We use the designated initializer syntax \tcode{.top = 10}.}
  \li{
    N4172 forfeits the possibility of perfect forwarding because the authors
    "are not aware of a way to make this work without making parameter names part of a function's type".
    We have a plausible solution,
    described in \ref(#forwarding-named-arguments).
  }
}

The proposal received overwhelmingly negative feedback,
with the following poll being taken:

\Bquote{
Poll: Should we encourage Botond to continue work on this proposal?
Yes=6, No=11.
}

The major criticism were:

\ul{
  \li{Large amount of technical work "without any new functionality".}
  \li{Encouraging large parameter lists.}
  \li{Consistency problems for parameter names.}
  \li{Parameter names becoming part of the API.}
}

We believe that our proposal meaningfully addresses all of these criticisms.
The language has evolved significantly since 2014,
and the perspective on many of these issues changed.

\h3{P0671R2 "Self-explanatory function arguments"}

\ref(P0671R2) proposes the following syntax:

\cppblock{
double Gauss(double x, double mean, double width, double height);
Gauss(0.1, mean: 0., width: 2., height: 1.);
}

While the R2 proposal is strikingly similar to what we have
(with different argument syntax though),
R2 was never seen by the committee,
and to our knowledge, it "died" in SG17.

However, R0 was seen in EWG at Toronto 2017, with largely negative feedback;
see \ref(MinutesP0671R0).
R0 has a syntax such as \tcode{double !mean} which is incompatible
with existing declarations, so it is unclear how relevant the negative feedback still is.
Much of the feedback revolved around API design and possible library workarounds,
something that we address in great detail in \ref(#introduction).

\h3{P1229R0 "Labelled Parameters"}

\ref(P1229R0) takes a dramatically different approach to the previous parameters.
In essence, it adds the syntax:

\cppblock{
// declaration
void memcpy(to: void*, from: void*, n: size_t);
// call
memcpy(to: buf, from: in, n: bytes);
}

This syntax is sugar, and expands to the following underlying code:

\cppblock{
// declaration
void memcpy(std::labelled<std::label<char, 't', 'o'>, void*>,
            std::labelled<std::label<char, 'f', 'r', 'o', 'm'>, const void*>,
            std::labelled<std::label<char, 'n'>, size_t>);
// call
memcpy(std::labelled<std::label<char, 't', 'o'>>(buf),
       std::labelled<std::label<char, 'f', 'r', 'o', 'm'>>(in),
       std::labelled<std::label<char, 'n'>>(bytes));
}

Unsurprisingly, this idea did not find consensus.
The paper was seen in SG17 at San Diego 2018 with negative feedback;
see \ref(MinutesP1229R0)
(though we don't have record of polls):

\Bquote{
Anon: (voted against seeing the paper again)
I want the feature, but I want to use it everywhere,
so I'm uneasy with functions having to take \tcode{std::label}.
I want a more intrusive language feature

Anon: (voted against seeing the paper again)
I want to see a more full-fledged feature for this.
This paper seems like a half-measure.
I want to be able to reorder, have optional parameters, etc.

Anon: (voted against seeing the paper again)
this has extensive impacts on the type system, ADL, overloading, etc.
These are complicated parts of the language.
It introduces identifiers in new places, and they leak out of the function scope.
These things weren't addressed in the paper,
and I would want to see extensive exploration of these things. 
}

We see further problems with \ref(P1229R0):

\ul{
  \li{
    There is no "upgrade path" that the C++ standard library could reasonably take
    to support this new syntax.
  }
  \li{
    Crucial benefits of our proposal such as
    \ref(#simplifying-overload-resolution)
    cannot function as a quasi-library solution.
  }
  \li{
    The proposed \tcode{label: arg} syntax is asymmetrical with
    designated initializers,
    which is now an obvious problem from a C++20 perspective.
  }
}

\h2{Motivation}

\h3{Simplifying overload resolution}

Named arguments can drastically simplify overload resolution
by disqualifying (almost) all candidates on the basis of name mismatch.

\Bex{
When calling \tcode{std::ranges::sort} with named arguments,
we can disqualify all but one overload based on name mismatch:

\cppblock{
std::vector<Employee> employees = /* ... */;
std::ranges::sort(.r = employees,
                  .comp = compare_case_insensitive,
                  .proj = &Employee::get_name);
}

By comparison, if we make a positional call with the three arguments,
we have many potential candidates:

\cppblock{
ranges::sort(I first, S last, Comp comp = {}, Proj proj = {}); // #1
ranges::sort(R&& r, Comp comp = {}, Proj proj = {}); // #2
ranges::sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {}); // #3
ranges::sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // #4
}

#1, #3, and #4 are only disqualified once template argument deduction
has taken place;
they are not viable due to constraints such as \tcode{random_access_iterator}
not being satisfied.
}

Named calls can completely bypass complex processes
such as template argument deduction,
constraint satisfaction checks,
or comparison of implicit conversion sequences when names don't match.
This is expected to significantly improve compilation speed,
especially for large and complex overload sets like the ones in \header{ranges}.

\Bnote{
Adding named argument support to \header{ranges}
is not part of this proposal,
but the design allows for such support to be added subsequently without breaking changes.
The long-term plan for the standard library should be to add
named argument support wherever useful.
}

\h3{Improving error messages}

Named calls are also tremendously useful when the user makes a mistake in calling a function
in an overload set.
Rather than requiring lengthy explanations about unsatisfied constraints
or implicit conversions sequences that cannot be formed,
the error message can simply say that a call was not possible due to
argument and parameter name mismatches.

\Bex{
Assume that the user intended to call the \tcode{S(int, int)}
overload in the following sample:

\cppblock{
struct S {
  S(void* p);
  S(int x, int y);
};

S s(100);
}

Clang 21 (similar to EDG 6.7) outputs the following error:

\codeblock(text){
<source>:6:3: error: no matching constructor for initialization of 'S'
    6 | S s(100);
      |   ^ ~~~
<source>:1:8: note: candidate constructor (the implicit copy constructor) not viable: no known
conversion from 'int' to 'const S' for 1st argument
    1 | struct S \N{LEFT CURLY BRACKET}
      |        ^
<source>:1:8: note: candidate constructor (the implicit move constructor) not viable: no known
conversion from 'int' to 'S' for 1st argument
    1 | struct S \N{LEFT CURLY BRACKET}
      |        ^
<source>:2:5: note: candidate constructor not viable: no known conversion from 'int' to 'void *'
for 1st argument
    2 |     S(void* p);
      |     ^ ~~~~~~~
<source>:3:5: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    3 |     S(int x, int y);
      |     ^ ~~~~~~~~~~~~
}

The constructor the user actually wanted to call is found at the very end of the error message,
buried under irrelevant explanations relating to why there is no viable conversion
from \tcode{int} to \tcode{const S} in order to call the copy constructor, etc.

GCC 15 is even worse
because it does not even mention the constructor the user intended to call;
it speculates that we tried to call \tcode{S(void*)}, which is wrong:

\codeblock(text){
<source>:6:5: error: invalid conversion from 'int' to 'void*' [-fpermissive]
    6 | S s(100);
      |     ^~~
      |     |
      |     int
<source>:2:13: note: initializing argument 1 of 'S::S(void*)'
    2 |     S(void* p);
      |       ~~~~~~^
}

MSVC 19.43 combines the worst of Clang and GCC;
it lists every constructor \em{except} the relevant one:

\codeblock(text){
<source>(6): error C2665: 'S::S': no overloaded function could convert all the argument types
<source>(4): note: could be 'S::S(S &&)'
<source>(6): note: 'S::S(S &&)': cannot convert argument 1 from 'int' to 'S &&'
<source>(6): note: Reason: cannot convert from 'int' to 'S'
<source>(4): note: or       'S::S(const S &)'
<source>(6): note: 'S::S(const S &)': cannot convert argument 1 from 'int' to 'const S &'
<source>(6): note: Reason: cannot convert from 'int' to 'const S'
<source>(2): note: or       'S::S(void *)'
<source>(6): note: 'S::S(void *)': cannot convert argument 1 from 'int' to 'void *'
<source>(6): note: Conversion from integral type to pointer type requires reinterpret_cast,
C-style cast or parenthesized function-style cast
<source>(6): note: while trying to match the argument list '(int)'
}

\hr

The diagnostic quality for named calls is expected to be better:

\cppblock{
S s(.x = 100);
}

This could hypothetically give us the following output:

\codeblock(text){
<source>:6:3: error: no matching constructor for initialization of 'S'
    6 | S s(.x = 100);
      |   ^ ~~~
<source>:3:5: note: candidate constructor not viable: no argument for parameter 'y' provided
    3 |     S(int x, int y);
      |              ^ ~~~
<source>:1:8: note: 3 other constructors are not viable because they have no 'x' parameter
    1 | struct S \N{LEFT CURLY BRACKET}
      |        ^
}

The problem in the example is not simply a quality-of-implementation issue;
the compiler cannot magically guess which constructor we intended to call.
Attempting initialization with the argument \tcode{100} could be an attempt
at calling pretty much any constructor,
and every compiler handles this situation in a uniquely broken way.
}

When we make calls with named arguments,
the compiler can take a much better guess at which constructor we meant to call
(presumably, the one with matching parameter names).
This meaningfully addresses one of the greatest and longest-standing complaints
that C++ users have:
overly long and complicated errors.

\h3{Preventing common bugs}

\Bug{
Functions such as \tcode{std::lerp} or \tcode{std::clamp}
are extremely easy to misuse with positional arguments:
\cppblock{
std::clamp(x, 0.f, 1.f); // OK, clamp x in [0, 1]
std::clamp(0.f, x, 1.f); // compiles, but does the wrong thing
std::clamp(0.f, 1.f, x); // compiles, but does the wrong thing
}

While the \tcode{v, lo, hi} order of parameters used in the C++ standard library
is the most common convention,
there is no universal rule for the signature of a \tcode{clamp} function,
leading to this potential mistake.
Confusingly, the "range arguments" are provided last for \tcode{std::clamp}
but first for \tcode{std::lerp},
so the standard library is not even internally consistent about these things.

The same mistake is impossible with a named call:

\cppblock{
std::clamp(.v = x, .lo = 0.f, .hi = 1.f); // OK
std::clamp(.lo = 0.f, .v = x, .hi = 1.f); // OK
std::clamp(.lo = 0.f, .hi = 1.f, .v = x); // OK
}
}

\tcode{std::lerp} and \tcode{std::lerp} are by no means the only examples
of standard library functions where such mistakes can be made.

\Bug{
Despite the following line being an obvious mistake,
no compiler issues a warning (at the time of writing)
due to the fact that all conversions are value-preserving:
\cppblock{
std::cout << std::string('a', 10);
}

This calls the \tcode{string(size_type, char)} constructor,
resulting in 97 U+0010 END OF LINE characters being printed.
Such a mistake is totally preventable:

\cppblock{
std::cout << std::string(.ch = 'a', .count = 10);
}
}

Another possible source of mistakes lies in the fact that there are two competing conventions
for how to order inputs and outputs in function signatures:

\ul{
  \li{
    \b{Output first.}
    For example, \tcode{memcpy}, \tcode{operator<<(ostream&, /* ... */)},
    \tcode{getline}, \tcode{exchange}, \tcode{to_chars}, etc.
  }
  \li{
    \b{Output last.}
    For example, \tcode{copy}, \tcode{partial_sort_copy},
    \tcode{operator>>(ostream&, /* ... */)}, \tcode{fwrite}, etc.
  }
}

This inconsistency can easily result in mistakes,
such as mixing up the source and destination buffer of \tcode{memcpy}
because the user expected it to work like \tcode{copy_n}.
These mistakes are generally impossible with named arguments
because the position of the source and destination parameters are irrelevant.

\h3{Avoiding magic numbers}

Named arguments can significantly improve the readability of a function call.

\Bex{
The following function call would raise the
\tt{readability-magic-numbers} ClangTidy diagnostic:

\cppblock{
draw_text("awoo", 18, true);
}

The meaning of the arguments is clearer with names provided:

\cppblock{
draw_text(.text = "awoo", .size = 18, .kerning = true);
}
}

Users have come up with variety of workarounds to avoid magic numbers/flags:

\ul{
  \li{Creating separate variables such as \tcode{constexpr bool kerning = true}.}
  \li{
    Using ClangTidy's \tt{bugprone-argument-comment} check
    and writing \tcode{/*kerning=*/ true}.
  }
  \li{
    Creating wrapper types like \tcode{enum class Kerning : bool { no, yes }}
    and providing a \tcode{Kerning::yes} argument.
  }
  \li{
    Creating \tcode{struct Options} aggregates and calling
    \tcode{draw_text({ /* ... */ .kerning = false })}.
  }
}

While all of these workarounds \em{technically} solve the problem,
there is no clear answer to which of these is best,
resulting in competing styles and dilemmas of choice.
Named arguments would largely obsolete these workarounds.

At some large amount of parameters,
users typically create \tcode{struct}s to bundle up options,
but even then, it's not obvious whether every parameter should be in that \tcode{struct}
or if some could remain outside (e.g. a \tcode{std::string_view text} parameter).
It is also not obvious how to handle smaller parameter lists of ≥ 3 parameters.
Just three parameters can be mentally demanding, and are not usually enough to warrant
a separate \tcode{struct}.

\h4{Note on encouraging large parameter lists}

Some people may argue that named arguments would encourage users to write
functions with overly many parameters.
We argue that the amount of parameters to a program's subroutine is innate.
Whether parameters are provided as function parameters, a \tcode{struct},
options for a builder class, or something else,
the amount of parameters remains the same;
text rendering doesn't become any simpler just because the font size is in a \tcode{struct}.
Parameters can only be shuffled into different places,
and there is no inherent reason why a function parameter list
would be a bad place compared to all these other alternatives.

\h3{Arbitrary keyword arguments}

There are certain use cases where
we would want to support a large set of "flags", "attributes", or "keyword arguments"
in our functions.
This is clearly illustrated by proposals such as \ref(P2019R8),
which proposes the following syntax:

\cppblock{
std::jthread thr(std::thread::name_hint("worker"),
                 std::thread::stack_size_hint(16384),
                 [] { std::puts("standard"); });
}

Since the set of supported "thread attributes" may change in the future
and may include implementation-defined attributes,
we cannot simply use a \tcode{struct} aggregate that bundles up the attributes.
Otherwise, future changes would be an ABI break.

With named arguments, and with the hypothetical syntax in \ref(#forwarding-named-arguments)
(not yet proposed),
we could solve this issue as follows:

\cppblock{
namespace std{
  template<class... Attr, meta::info... AttrNames>
    std::tuple<\exposid{unspecified}> kwargs(Attr&&... attr .AttrNames);

  class jthread {
  public:
    template<class... Attr, class F, class... Args>
      jthread(std::tuple<Attr...>, F&&, Args&&...);
    // ...
  };
}

// Attr = [std::string_view, int]
// AttrNames = ["name_hint", "stack_size_hint"],
//             i.e. we deduce a pack of argument name reflections
std::tuple attr = std::kwargs(.name_hint = "worker"sv, .stack_size_hint = 16384);

std::jthread thr(std::move(attr), [] { std::puts("standard"); });
}

This exact syntax may not actually be feasible or desirable,
but the principle should be clear:
arbitrary keyword arguments are much more concise and natural than creating a distinct type
for each "attribute".

\h2{Design}

\h3{Overload resolution impact}

In short, C++ function calls are resolved in the following stages:

\ol{
  \li{name lookup}
  \li{collecting viable candidates}
  \li{selecting the best viable candidate using various tie breakers}
}

Named arguments are resolved during the second stage,
i.e. when collecting viable candidates.
Essentially,
argument names are just a means of matching arguments to parameters.
Positional calls do this by matching arguments to parameters from left to right,
named calls do it by name.
Whether a call uses positional or named arguments is irrelevant to which overload is better.

\h3{Mixing named and positional arguments}

We propose a heavily restricted form of mixing name and positional arguments.
Namely, all positional arguments have to come first:

\cppblock{
draw_text(.text = "awoo", .font_size = 18); // OK, named only
draw_text("awoo", .font_size = 18);         // OK, positional then named
draw_text(.font_size = 18, "awoo");         // error: positional argument following named argument
}

This is useful because there are often tag parameters at the start,
or parameters whose names are either obvious or irrelevant.

\Bex{
The following calls could be valid:
\cppblock{
format("{x} {y}", .x = 10, .y = 20);
emit_html_element("div", .id = "container");
}
}

\h3{Forwarding named arguments}

Past proposals have faced concerns over the ability to forward argument names,
such as in:

\cppblock{
template<class... Args>
T& emplace(Args&&... args) {
  T* p = new (storage) T(std::forward<Args>(args)...);
  // ...
  return *p;
}
}

While the following syntax is \u{not} proposed,
it is possible to allow forwarding in the future,
with mechanics like:

\cppblock{
template<class... Args, std::meta::info... names>
T& emplace(Args&&... args .names) {
    T* p = new (storage) T(.[: names :]... = std::forward<Args>(args)...);
    // ...
    return *p;
}
}

Now that C++26 has reflection,
there seems to be a realistic path to forwarding argument names.
While the syntax is obviously up for debate,
the basic idea is:

\ul{
  \li{
    "\tcode{args .names}"
    deduces a pack of argument names as \tcode{std::meta::info}.
    Note that this cannot be done with \tcode{std::string_view}
    because it is not a structural type,
    and even if it was,
    it is unclear what the pointer inside would point to.
    "\tcode{args .names}" could also work bidirectionally,
    i.e. it could be used to specify the parameter names separately.
  }
  \li{
    "\tcode{.[: names :]...}"
    performs a pack expansion of an argument name slice.
    In other words, each of the names in \tcode{names}
    would be used as an argument name when calling \tcode{T}'s constructor.
  }
}

If it was possible to deduce argument names,
this would also enable support for named arguments in \tcode{std::format}:

\cppblock{
template<typename... Args, meta::info... names>
string format(format_string<Args...>, Args&&... args .names);

format("{x}", .x = 100); // Args  = [ int ]
                         // names = [ "x" ]
}

\h3{\tt{[[positional]]}}

While library authors in C++ don't feel comfortable
with making a parameter name a permanent part of the API,
experience from other languages with named argument support (e.g. Kotlin)
tells us that "parameter name permanence" is largely a non-issue.
It is rare that a parameter name would have to be changed.

Nonetheless, there are certain instances where parameter name stability
cannot be guaranteed,
and to cover this case,
we propose a \tcode{[[positional]]} attribute,
which may be applied to a function declaration.
This attribute enables a warning if a function is called with named arguments:

\Bex{
\cppblock{
[[positional]] void f(int x);
f(.x = 0); // warning: f should only be called with positional arguments
}
}

Such an attribute is particularly useful for functions where only positional calls make sense.

\Bex{
Consider the following function template:
\cppblock{
template<class T>
[[positional]] T max(const T& x, const T& y) {
  return x < y ? y : x;
}
}

Because we "disallow" named arguments,
we retain the freedom to turn this into a variadic function template later:
\cppblock{
template<class T, class... Us>
  requires (std::is_same_v<T, Us> && ...)
[[positional]] T max(const T& x, const Us&... ys) {
  // ...
}
}
}

That being said,
calling functions \tcode{max} with named arguments is dubious in the first place,
and it is unlikely that much — or any code would be broken by changing \tcode{y}.

\h2{Impact on the standard}

In summary,
a few parts of the core language are affected,
such as function call syntax and overload resolution.
The standard library impact is minimal because named argument support
is not enabled by this paper.
We merely add some policies in library wording.

\h3{Integration into the standard library}

None of the proposals in \ref(#prior-art) discuss
how named arguments could be integrated into the C++ standard library,
despite this being an extremely important point of motivation and an important design aspect.
There are a few key observations:

\ul{
  \li{
    When named arguments may be used,
    parameter names are effectively part of the API,
    and changing parameter names is a breaking change.
  }
  \li{
    Standard library implementations typically use reserved identifiers such as \tcode{__x}
    instead of \tcode{x} for parameter names
    in order to avoid conflicts with macros defined by the user.
  }
  \li{
    None of the functions in the standard were standardized with "normative parameters".
    LEWG never discussed or approved these parameter names as a language feature,
    they are all editorial.
  }
}

While allowing named arguments in the standard library is a long-term goal,
we do not yet propose it here.
Instead, we propose a general policy that the function parameter specified
in the standard library are not stable and may be different in the implementation.
This approach has precedent for SFINAE/expression-validity testing,
for reflecting on standard library declarations,
and other issues.

Subsequent proposals would gradually enable named arguments on a per-header basis.
For headers that are "named-argument-enabled",
\tcode{[[positional]]} would be specified on the few functions that
require parameter name instability.
While named arguments are not always useful (e.g. what's the point of \tcode{sqrt(.x = 2)}?),
they are rarely harmful
and rely on a parameter name that is likely to change,
especially in a document as stable as the C++ standard.

Any function that has reserved identifiers as parameter names (e.g. \tcode{f(int __x)})
is recommended to behave as if \tcode{[[positional]]} was implicitly applied to it,
meaning that to implement this proposal,
no standard library code would need to be changed.

\h2{Implementation experience}

See \ref(ClangFork) for an experimental implementation.

\h2{Wording}

None yet.
Will be provided in a future revision
once some design aspects have settled.

\h2{References}

\bib(
  id = N4172,
  title = Named arguments,
  date = 2014-10-07,
  author = Ehsan Akhgari\, Botond Ballo,
  link = https://wg21.link/n4172,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4172.htm,
)\
\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P0671R2,
  title = Self-explanatory Function Arguments,
  date = 2018-05-07,
  author = Axel Naumann,
  link = https://wg21.link/p0671r2,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0671r2.html,
)\
\bib(
  id = P1229R0,
  title = Labelled Parameters,
  date = 2018-10-08,
  author = Jorg Brown,
  link = https://wg21.link/p1229r0,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1229r0.html,
)\
\bib(
  id = P2019R8,
  title = Thread attributes,
  date = 2025-01-23,
  author = Corentin Jabot,
  link = https://wg21.link/P2019R8,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2019r8.pdf,
)\
\bib(
  id = MinutesN4172,
  title = N4172 EWG Minutes from Urbana-Champaign 2014,
  link = https://wiki.edg.com/bin/view/Wg21urbanachampaign/FunctionFacilities,
)\
\bib(
  id = MinutesP0671R0,
  title = P0671R0 EWG Minutes from Toronto 2017,
  link = https://wiki.edg.com/bin/view/Wg21toronto2017/P0671R0,
)\
\bib(
  id = MinutesP1229R0,
  title = P1229R0 SG17 Minutes from San Diego 2018,
  link = https://wiki.edg.com/bin/view/Wg21sandiego2018/P1229R0,
)\
\bib(
  id = ClangFork,
  title = named-args branch of term-est/llvm-project repository,
  author = Murat Can Çağrı,
  link = https://github.com/term-est/llvm-project/tree/named-args,
)\

\make_bib
