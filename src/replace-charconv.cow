\cowel_include{libwg21.cow}

\wg21_head(
  title = Provide a better replacement for \tt{std::to_chars} and \tt{std::from_chars}
){
\dl{
  \dt{Document number:} \dd{\docnum{D3944R0}}
  \dt{Date:}            \dd{\tt{2025-12-12}}
  \dt{Audience:}        \dd{LEWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3688/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/replace-charconv.cow)}
}
\hr
}

\Babstract{
The API of \tcode{std::to_chars} and \tcode{std::from_chars} is a dead end
for future standardization.
Providing improved replacements is better than maintaining the existing overloads.
}

\h2(listed=false){Contents}

\make_contents

\h2{Problem}

In recent history,
there have been at least five papers proposing changes
to the \header{charconv} API:

\ol{
  \li{
    \ref(P2584R0) points out that \tcode{std::from_chars} isn't composable.
    The APIs neither return a range in the result
    nor do they take a range, but a pair of pointers.
    The paper proposes new overloads that accept \tcode{std::string_view}
    and return a different result type.
  }
  \li{
    \ref(P3666R2) wants to add \tcode{std::from_chars} and \tcode{std::to_chars}
    support for the new bit-precise integers.
    However, the current interface has an overload
    for each \tcode{\placeholder{integer-type}} placeholder,
    and doing so for bit-precise integers would require millions of overloads.
    The paper proposes a new template overload instead.
  }
  \li{
    \ref(P3876R0) wants to add \tcode{std::from_chars} and \tcode{std::to_chars}
    for character types other than \tcode{char}.
    Since the functions aren't templates and \tcode{std::to_chars_result}
    isn't a template either, this is quite difficult to do.
    The paper also proposes function templates to avoid a huge overload set.
  }
  \li{
    \ref(P2827R1) points out that there is no way to detect floating-point
    overflow and underflow in \tcode{std::from_chars}.
    In fact, the wording for \tcode{std::from_chars} always relied on the term
    \q{range of representable values} which didn't have a definition in the C++ standard
    at the time \header{charconv} was added.
    The error handling design for floating-point overload has always been unclear,
    and none of libstdc++, libc++, and MSVC STL implement what the wording currently says.
    \q{Fixing} the API is not possible without breaking some user code.
  }
  \li{
    \ref(P3652R1) wants the floating-point overloads to be \tcode{constexpr}.
  }
}

\h3{Too many overloads}

Additionally, it is worth noting that the overload set for \tcode{std::to_chars}
is absurdly large.
An implementation that provides all standardized floating point types
(\tcode{float}, \tcode{double}, \tcode{long double},
\tcode{std::float16_t}, \tcode{std::bfloat}, \tcode{std::float32_t},
\tcode{std::float64_t}, and \tcode{std::float128_t})
needs to be provide 4 × 8 = 32 floating-point overloads, as well as 11 integer overloads.
There are 43 candidates participating in overload resolution.

For \tcode{std::from_chars},
there are \q{only} 27 candidates in that scenario.

\h3{Output parameters}

The practice of using output parameters like in \tcode{std::from_chars}
is widely regarded as bad practice.
It invites bugs such as reading from an uninitialized variable,
prevents the user from making their variables \tcode{const},
among other issues.

\h3{Problems with floating-point \tcode{std::from_chars}}

The specification of \tcode{std::from_chars} for floating-point overloads
is currently in a broken state.
To provide some more context beyond \ref(P2827R1),
here is a list of issues:

\ol{
  \li{
    \tcode{from_chars} is required to set \tcode{from_chars_result::ec}
    to \tcode{errc::result_out_of_range} if
    \q{the parsed value is not in the range representable by the type of \tcode{value}}\iref{charconv}.
    This wording existed since its introduction by \ref(P0067R5),
    but it was never clear what it meant because there existed no definition of
    \q{range of representable value} for floating-point types at the time,
    at least not in the C++ standard.
    The design discussion and recorded minutes for the paper offer no clarification.
  }
  \li{
    \ref(CWG2723) added a definition of
    \q{range of representable values},
    which created the current error handling design,
    but neither LEWG nor LWG polled that design.
    At best, the current design is a \q{happy accident}.
  }
  \li{
    Since the \q{range of representable values} for ISO/IEC 60559 types includes
    all real numbers,
    the wording mandates that overflow such as when parsing \tcode{"1e10000"} and
    underflow such as when parsing \tcode{"1e-10000"} result in \tcode{ec = std::errc{}}
    (i.e. no error status),
    and the result being set to infinity and zero, respectively.
    Making both overflow and underflow undetectable may not be desirable.
  }
  \li{
    While libstdc++, libc++, and MSVC STL have an implementation,
    none of these comply with the current wording;
    they set \tcode{ec = errc::result_out_of_range} when they are mandated not to.
  }
  \li{
    While \tcode{from_chars} is required to parse strings such as \tcode{"INFINITY"}
    or \tcode{"NaN"},
    by definition, these are not in the range of representable values
    (because infinity and NaN are not real numbers).
    This means that \tcode{ec = errc::result_out_of_range} has to be set
    and the \tcode{value} has to stay unmodified,
    making this functionality nonsensical and unusable.
    No implementation complies with the wording.
  }
  \li{
    The wording does not explicitly handle floating-point types
    that have no representation of infinity or NaN,
    but the C++ standard permits such floating-point types,
    as evidenced by \tcode{numeric_limits::has_infinity}.
    The wording currently mandates that \tcode{errc::result_out_of_range} is set
    in both the \tcode{"INFINITY"} case and the overflow case,
    which may be what we want.
    As stated above, the current wording is a \q{happy accident} at best,
    not deliberate design.
  }
}

\h3{No path forward for \tcode{std::from_chars}}

There are too many problems with the old API,
and the problems are too severe as that the issue could be fixed
by simply adding an overload here and making am minor adjustment there.
Any new overloads would compete with a large amount of candidates
(\ref(#too-many-overloads)).
There already exists user code that relies on the implemented behavior,
whether it complies or not.

There is no clear path to getting the floating-point overloads into a desirable state.
Users already rely on one specific error code \tcode{errc::result_out_of_range}
signaling different failures:
\ul{
  \li{Floating-point overflow.}
  \li{Floating-point underflow.}
  \li{Value too large for integers.}
  \li{Infinity not representable in the resulting floating-point type (?)}
}

Even if the wording (which mandates that the first two are entirely undetectable)
was aligned with implementations,
there are clearly too many distinct errors crammed into one error code.
In the \q{too large for the integer} case,
there is no meaningful value that could be written,
unlike for floating-point numbers,
where zero or infinity could be written,
and the user likely wants to access these values.
These are differently shaped pegs that shouldn't be fit through the same hole.

Creating new error codes would break existing user code
that checks for \tcode{errc::result_out_of_range}.

\h3{\tcode{std::from_chars} cannot parse digit separators}

Neither the integer nor the floating-point overloads of \tcode{std::from_chars}
can parse digit separators.
This is quite annoying because floating-point numbers in config formats,
scripting languages, etc.
may have digit separators.
It also means that \tcode{std::from_chars} isn't capable of parsing
a C++ \gterm{integer-literal} or \gterm{floating-point-literal} in the general case
(even after removing the prefix),
which is the bare minimum functionality a user is entitled to.

Removing the base prefix (e.g. \tt{0x}) is fairly easy and requires no extra allocations,
but removing digit separators from the middle of the string requires a separate buffer
and non-trivial effort from the user.

\h3{\tcode{std::to_chars} output isn't customizable enough}

\tcode{std::to_chars} makes some arbitrary, opinionated choices
that the user may not like:
\ul{
  \li{
    The integer overload outputs lowercase characters for digits beyond base 10.
  }
  \li{
    The floating-point overload outputs lowercase \tcode{e} or \tcode{p}
    exponent separators.
  }
  \li{
    The floating-point overload always outputs exponents zero-padded by one,
    such as \tcode{e+09}.
    This doesn't make parsing any easier since \tcode{std::from_chars} should still
    accept exponents with only a single digit;
    it merely bloats the output with redundant information.
  }
  \li{
    The minimum and maximum exponent for exponential notation cannot be customized.
  }
}

The first two points are somewhat inconsequential;
the user can simply convert each character to uppercase after running \tcode{std::to_chars}.

The zero-padding of the exponent is quite problematic though;
if the user wants the \em{truly} shortest representation,
without \q{unfairly handicapping} the exponential notation with zero-padding,
they need to run \tcode{std::to_chars} two times in certain cases.
If the goal is to optimize for space by outputting the shortest representation
(even if it's less readable),
why would the user want to waste space with this zero?

Last but not least,
if the goal is to maximize human-readability,
the user often wants to constrain the exponent instead of going with the shortest representation.

\Bex{
For a floating-point number \tt{1.0e} with some exponent,
\ul{
  \li{
    JS consoles in web browsers output in fixed format
    for exponents in the range [-6, 20].
  }
  \li{
    Python consoles output in fixed format
    for exponents in the range [-4, 15].
  }
  \li{
    Kotlin's \tcode{println} outputs in fixed format
    for exponents in the range [-3, 6].
  }
  \li{
    \tcode{std::to_chars} with \tcode{chars_format::general} outputs in fixed format
    for exponents in the range [-4, 5].
  }
}
}

\tcode{chars_format::general} is better than no choice,
but only provides the user with one completely arbitrary alternative to the default behavior.
Clearly, every other software has a different opinion on when to choose
fixed notation over exponential notation.
Unfortunately, \tcode{std::to_chars} makes it very difficult to implement that opinion.
The default behavior of choosing the shortest representation is not very common
for user-facing output,
and \tcode{std::to_chars} doesn't even implement that properly due to zero-padding
the exponent.

\h2{Solution}

\h3{What to do with \tcode{std::to_chars} and \tcode{std::from_chars}}

To state the obvious:
the functionality provided by \tcode{std::to_chars} and \tcode{std::from_chars}
is immensely useful,
even if the API is in a bad state.
The user should be given an easy upgrade path,
and deprecation is not desirable,
especially not without a replacement.
At least the integer overload of \tcode{std::to_chars} and \tcode{std::from_chars}
are not defective,
so it would create pointless code churn if those
need to be ported over to a different API.

However, starting with C++29,
committee work on \tcode{std::to_chars} and \tcode{std::from_chars}
should be largely abandoned.
These functions could live in the standard without deprecation,
as largely obsolete features, similar to \tcode{std::strtod}.

\h3{The issue of floating-point underflow}

To ensure round-tripping, \tcode{std::to_chars} needs to produce
output that is always accepted by \tcode{std::from_chars}
and results in the same floating-point value.
There are three distinct problematic scenarios:
\ol{
  \li{
    Parsing an inexact representation of a subnormal number, such as
    \tcode{"1e-45"}.
  }
  \li{
    Parsing an exact representation of a subnormal number, such as
    \tcode{"0.00000000000000000000000000000000000000000000" "14012984643248170709237295832899161312802619418765157" "7175706828388979108268586060148663818836212158203125"}.
  }
  \li{
    Parsing a nonzero number that is zero after rounding, such as
    \tcode{"1e-100000000000"}.
  }
}

\Bnote{
When parsing a \tcode{std::float32_t} with the input from the first or second bullet,
the same floating-point value is produced.
However, only the input in the second bullet matches the exact decimal value
of the floating-point number without any rounding.
}

All existing implementations work by extracting the significant digits
(17 in the case of \tcode{std::float64_t})
and multiplying this mantissa with the exponent part,
adjusted based on the position of the radix point.
This makes it impossible to distinguish between the first and second scenario,
and distinguishing between them would require unreasonable effort because all digits
(possibly over 100) contribute
to whether the string is an exact or inexact representation of a floating-point number.

Therefore, the only detectable scenario should be the last case,
i.e. parsing an \q{inexact zero}.
Neither the first nor second case should result in an error because that would make
parsing subnormal numbers impossible and would violate the round-tripping guarantee.

\Bnote{
Distinguishing between the exact and inexact case is not impossible,
just difficult and expensive.
A possible implementation could parse and round,
then feed the rounded value into \tcode{std::to_chars} with a high
precision value to produce as many significant digits as necessary,
then compare those digits to the original input string.
}

\h3{A better alternative API}

Rather than continuing work on \tcode{std::to_chars} and \tcode{std::from_chars},
a better API should be provided that combines all the desired changes
listed in the papers above.
The implementation would be relatively trivial because all the hard work
has already been done when \tcode{std::to_chars} and \tcode{std::from_chars}
were implemented.

A rough draft of a new API looks as follows.

\h4{\tcode{std::to_characters}}

\cppblock{
enum class characters_notation {
  // Only fixed notation permitted.
  fixed = \exposid{unspecified},
  // Only scientific notation permitted.
  scientific = \exposid{unspecified},
  // Either notation permitted.
  any = fixed | scientific,
};

struct to_characters_options {
  // For integers, in range [2, 36].
  // For floating-point, either 10 or 16.
  int base = 10;
  // Output uppercase characters such as 1E+3 or FF00
  bool uppercase = false,

  // Permitted notations.
  characters_notation notation = characters_notation::any,
  // If positive, specifies the precision.
  // Otherwise ignored.
  int precision = -1;
  // Zero-padding of the exponent.
  int exponent_zero_pad = 0;
  // Force fixed notation if an exponent in scientific notation is in the range
  // [fixed_min_exponent, fixed_max_exponent),
  // even if scientific notation would yield shorter output.
  int fixed_min_exponent = 0;
  int fixed_max_exponent = 0;
};

// Same options as to_chars without any std::chars_format.
inline constexpr to_characters_options \exposid{to-chars-default-options} {
  .exponent_zero_pad = 2,
};
// Same options as chars_format::general.
inline constexpr to_characters_options \exposid{to-chars-general-options} {
  .exponent_zero_pad = 2,
  .fixed_min_exponent = -4,
  .fixed_max_exponent = 6,
};
// Same options as with chars_format::fixed.
inline constexpr to_characters_options \exposid{to-chars-fixed-options} {
  .exponent_zero_pad = 2,
  .notation = characters_notation::fixed,
};
// Same options as with chars_format::scientific.
inline constexpr to_characters_options \exposid{to-chars-scientific-options} {
  .exponent_zero_pad = 2,
  .notation = characters_notation::scientific,
};
// Same options as with chars_format::hex.
inline constexpr to_characters_options \exposid{to-chars-hex-options} {
  .base = 16,
  .exponent_zero_pad = 2,
};

template<class T>
  concept \exposid{signed-or-unsigned} = \exposid{any signed or unsigned integer type};
template<class T>
  concept \exposid{cv-unqualified-floating-point}
    = !is_const_v<T> && !is_volatile_v<T> && floating_point<T>;

template<class T>
  requires \exposid{signed-or-unsigned}<T>
        || \exposid{cv-unqualified-floating-point}<T>
  constexpr size_t to_characters(span<char> out, T value,
                                 const to_characters_options& options = {});
}

\tcode{std::to_chars} can only signal one possible failure,
namely \tcode{std::errc::value_too_large}.
On success, \tcode{std::to_chars_result::ptr} can be used to detect how many characters
were written.

It is actually possible to have all that functionality by simply returning \tcode{size_t}.
On success, the amount of written characters is returned;
on failure, zero is returned, which also happens to be the amount of (usable) characters written.
A \tcode{size_t} result completely eliminates the need for a dedicated result type,
while conveying the same amount of information.

The \tcode{out} parameter is deliberately not dependent;
template argument deduction does not consider implicit conversions,
so the API would not be ergonomic.
The \tcode{span<char>} parameter lets the user store the result in an
\tcode{array<char, N>}, a \tcode{char[N]}, etc.

\h4{\tcode{std::from_characters}}

\cppblock{
enum class from_characters_status {
  // Success.
  ok = 0,
  // A value could be parsed, but is infinity after rounding.
  // For example, "1e999999999999".
  floating_overflow = 1,
  // A value could be parsed, but is zero after rounding,
  // and not exactly zero.
  // For example, "1e-999999999999".
  floating_underflow = 2,
  // The input is is not valid, such as "@#&*".
  invalid_string = -1,
  // A value could be parsed, but is not representable in the type.
  // For example, if "INFINITY" is parsed,
  // but the floating-point type cannot represent infinity.
  // This also includes integers which are too large.
  unrepresentable = -2,
};

template<class T>
struct from_characters_result {
  T value;
  ptrdiff_t matched;
  from_characters_status status;
  friend constexpr bool operator==(from_characters_result,
                                   from_characters_result) = default;
  constexpr explicit operator bool() const { return status == ok; }
};

template<\exposid{signed-or-unsigned} T>
  constexpr from_characters_result<T>
    from_characters(span<const char> in, int base = 10);
template<\exposid{cv-unqualified-floating-point} T, class charT>
  constexpr from_characters_result<T>
    from_characters(span<const char> in, chars_format fmt = chars_format::general);
}

Error handling works as follows:
\ul{
  \li{
    For status \tcode{ok},
    \tcode{matched} is the amount of matched characters,
    and the parsed and rounded value is stored in \tcode{value}.
  }
  \li{
    For status \tcode{floating_overflow},
    \tcode{matched} is the amount of matched characters,
    and positive or negative infinity is stored in \tcode{value},
    or greatest or lowest finite value if infinity is not representable.
    This does not apply when parsing an exact infinity or NaN,
    like \tcode{"inf"} or \tcode{"NaN"}.
  }
  \li{
    For status \tcode{floating_underflow},
    \tcode{matched} is the amount of matched characters,
    and positive or negative zero is stored in \tcode{value}.
    This does not apply when parsing an exact zero,
    like \tcode{"0.0"} or \tcode{"0.00000000000000e1000000}.
  }
  \li{
    For status \tcode{invalid_string} or \tcode{unrepresentable},
    \tcode{matched} is zero,
    and \tcode{value} is value-initialized.
  }
}

The status \tcode{floating_overflow} and \tcode{floating_underflow}
are only returned for floating-point types,
whereas integers which are too large are signaled by \tcode{unrepresentable}.
If the user doesn't want to handle overflow or underflow
but is fine with obtaining infinity or zero in that case,
they can check for \tcode{status >= from_characters_status::ok}.
This is the behavior of the Python and C++ floating-point literals,
for example.

\Bnote{
According to the current wording for floating-point \tcode{std::from_chars},
overflow and underflow are undetectable and simply result
in zero or infinity being stored.

However, there exists no implementation that complies with the wording.
Overflow and underflow are both signaled by \tcode{errc::result_out_of_range}
and thus indistinguishable,
and only some implementations set \tcode{value}.

The case signaled by \tcode{from_characters_status::not_representable}
is a hole in the wording and was likely never even considered in the original design,
or perhaps it was the only case that should be signaled by \tcode{errc::result_out_of_range}.
Nobody knows.
}

\h4{Integrating other proposal into this design}

\ul{
  \li{
    \ref(P2584R0) wants an API that works with \tcode{std::span},
    and the API above provides that.
    There are no more raw pointers in the API.
  }
  \li{
    \ref(P3666R2) wants to provide additional overloads for bit-precise integers,
    which becomes a no-op if the functions are already templates
    that support all integer types.
  }
  \li{
    \ref(P3876R0) wants to provide additional overloads
    for character types other than \tcode{char}.
    Since the base set of overloads is manageable (4×\tcode{std::to_characters},
    2×\tcode{std::from_characters}),
    it is not unreasonable to multiply its size by five,
    for each character type.
    Note that having a non-template \tcode{span<const char>} parameter
    is important for being able to pass \tcode{std::string_view}
    and other contiguous containers.
    However, 20 overloads of \tcode{std::to_characters} is still quite a lot,
    so perhaps a \tcode{std::contiguous_range auto&} parameter would be better.
    Furthermore,
    the use of \tcode{std::ptrdiff_t} instead of a pointer in the result
    works for any character type.
  }
  \li{
    \ref(P2827R1) wants to detect underflow and overflow,
    which is implemented by the more granular \tcode{from_characters_status}.
  }
  \li{
    \ref(P3652R1) wants the floating-point overloads to be \tcode{constexpr},
    which is done for the API above.
  }
}

\h2{Implementation}

The new API is obviously implementable because it is functionally almost identical
to \tcode{std::to_chars} and \tcode{std::from_chars};
it just takes \tcode{std::span} instead of pointer pairs,
and uses more distinct error codes for the failures already signaled by implementations.

\h2{Wording}

It doesn't make sense to provide wording
until a general design direction has been given by LEWG.

There are two questions that need to be answered:
\ul{
  \li{Do we want the changes proposed by the various other papers listed above?}
  \li{
    If so, do we really want them in the \tcode{std::to_chars} and \tcode{std::from_chars}
    overload set,
    or do we create a new API,
    similar to what is shown above?
  }
}

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P0067R5,
  title = Elementary string conversions\, revision 5,
  date =  2016-11-11,
  author = Jens Maurer,
  link = https://wg21.link/p0067r5,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0067r5.html,
)\
\bib(
  id = P2584R0,
  title = A More Composable from_chars,
  date = 2022-05-12,
  author = Corentin Jabot,
  link = https://wg21.link/p2584r0,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2584r0.pdf,
)\
\bib(
  id = P3666R2,
  title = Bit-precise integers,
  author = Jan Schultke,
  link = https://isocpp.org/files/papers/P3666R2.html,
)\
\bib(
  id = P3876R0,
  title = Extending <charconv> support to more character types,
  author = Jan Schultke\, Peter Bindels,
  link = https://isocpp.org/files/papers/P3876R0.html,
)\
\bib(
  id = P2827R1,
  title = Floating-point overflow and underflow in from_chars (LWG 3081),
  date = 2023-11-20,
  author = Zhihao Yan,
  link = https://wg21.link/p2827r1,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2827r1.html,
)\
\bib(
  id = P3652R1,
  title = Constexpr floating-point <charconv> functions,
  date = 2025-04-16,
  author = Lénárd Szolnoki,
  link = https://wg21.link/p3652r1,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r1.html,
)\
\bib(
  id = CWG2723,
  title = Range of representable values for floating-point types,
  date = 2023-04-21,
  author = Jiang An,
  link = https://wg21.link/CWG2723,
)\
\bib(
  id = LWG3081,
  title = Floating point \tcode{from_chars} API does not distinguish between overflow and underflow,
  date = 2018-03-12,
  author = Jiang An,
  link = https://wg21.link/LWG3081,
)\

\make_bib
