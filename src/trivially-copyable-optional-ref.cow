\cowel_include{libwg21.cow}

\wg21_head(
  title = Make \tcode{optional<T&>} trivially copyable\br{}(NB comment US 134-215)
){
\dl{
  \dt{Document number:} \dd{\docnum{P3836R2}}
  \dt{Date:}            \dd{\tt{2025-11-05}}
  \dt{Audience:}        \dd{LEWG, LWG}
  \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
  \dt{Reply-to:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>\br
                            Nevin Liber <\mail{nliber@anl.gov}>\br
                            Steve Downey <\mail{sdowney@gmail.com}>}
  \dt{GitHub Issue:}    \dd{\ref(https://wg21.link/P3836/github)}
  \dt{Source:}          \dd{\ref(https://github.com/eisenwave/cpp-proposals/blob/master/src/trivially-copyable-optional-ref.cow)}
}
\hr
}

\Babstract{
Possibly due to a wording oversight,
\tcode{optional<T&>} is not guaranteed to be trivially copyable.
We propose to fix this in C++26.
Due to certain design questions that concern LEWG,
this issue is not simply handled as an LWG issue.
}

\h2(listed=false){Contents}

\make_contents

\h2{Revision history}

\h3{Changes since R1}

\ul{
  \li{used more conventional "NB comment US 134-215" in title}
  \li{
    applied LEWG direction (\em{only} specify \tcode{optional<T&>} to be trivially copyable)
    after Kona 2025 poll
  }
}

\h3{Changes since R0}

\ul{
  \li{added Steve Downey as co-author}
  \li{referenced related US NB comment 134}
  \li{rewrote \ref(#wording)}
}

\h2{Introduction}

Making operations (at least construction)
of \tcode{optional<T&>} trivial is the design intent of \ref(P2988R12):

\Bquote{
\cowel_html_element(h3){3.3 Trivial construction}

Construction of \tcode{optional<T&>} should be trivial,
because it is straightforward to implement, and \tcode{optional<T>}
is trivial.
Boost is not.
}

However, possibly due to a wording oversight,
trivial construction is not actually guaranteed,
nor is trivial copyability in general.
This status quo is inconsistent with the design of \tcode{optional<T>} as a whole:
the special members (copy constructor, destructor, etc.) of the primary template
are all specified to be trivial if the relevant operations on \tcode{T} are trivial.
Therefore, \tcode{optional<int*>} is required to be trivially copyable,
unlike \tcode{optional<int&>}.

This issue should be fixed in C++26.
Our paper corresponds to the US national body comment 134.

\h3{Wording problem}

Intuitively, \tcode{optional<T&>} (see \ref(P2988R12)) is a \tcode{T*},
wrapped \tcode{optional}.
In fact, the synopsis as specified in \iref{optional.optional.ref} is as follows:

\cppblock{
template<class T>
class optional<T&> {
  \etc

  public:
    // \serif{[optional.ref.ctor], constructors}
    constexpr optional() noexcept = default;
    
    \etc

    constexpr ~optional() = default;

    \etc

  private:
    T* \exposid{val} = nullptr; // \serif{exposition only}
};
}

If the only non-static data member was \tcode{\exposid{val}},
\tcode{optional<T&>} would be trivially copyable
according to \eelis{class.prop#def:class,trivially_copyable}.
However, the implementation has the freedom to add extra non-static
data members, bit-fields, and base classes,
so no trivial operation is strictly guaranteed.

\h2{Motivation}

\tcode{optional<T&>} should be guaranteed to be trivially copyable for the following reasons:

\ul{
  \li{It makes the design consistent with the primary template \tcode{optional<T>}.}
  \li{
    Trivial copyability is a useful property in this case.
    It allows storing \tcode{optional<T&>} in a \tcode{struct} whose bytes are copied
    between processes,
    uploaded from CPU to GPU (e.g. in CUDA), etc.
  }
  \li{
    Trivial copyability also makes \tcode{optional<T&>} an implicit-lifetime class type,
    which makes it possible to starts its lifetime in a \tcode{union}
    more easily via assignment operator,
    among other benefits.
  }
}

\h2{Design}

There are two plausible options to fix the issue of \tcode{optional<T&>}:

\ol{
  \li{
    Simply specify \tcode{optional<T&>} to be trivially copyable.
  }
  \li{
    Additionally constrain its layout so it \em{actually}
    becomes a wrapper for a \tcode{T*}.
  }
}

Both directions were considered during Kona 2025,
but the room only had appetite for the first option,
so only the first option was polled:

\Bquote{
\b{POLL:} Apply the resolution described in NB comment
“US 134-215 22.5.4.1 [optional.optional.ref.general] optional<T&> is a trivially copyable type”
with option 1 (specify \tcode{optional<T&>} to be trivially copyable)
from P3836R1 and send resolution to LWG.

\five_way_poll(12, 2, 1, 1, 0)

\b{Outcome}: Consensus in favor
}

\h3{Option 2 (no longer proposed)}

R0 and R1 of this paper argued that option 2 would have provided more value to the user
because trivial copyability is much more useful when the layout of a type is somewhat constrained.
This makes it possible to \tcode{bit_cast<T*>(optional_ref)}
or to encode \tcode{optional<T&>} using \tcode{memcpy}
with \em{some} guarantees regarding its layout.

\Bex{
If \tcode{optional<int&>} is trivially copyable \em{and} its layout is that of a pointer,
we can do the following:

\cppblock{
int* legacy_api(); // returns nullable pointer

optional<int&> modern_api() {
\del{  int* p = legacy_api();
  return p ? *p : optional<int&>{};}
\ins{  return bit_cast<optional<int&>>(legacy_api());}
}
}

There are no "null references", so bit-casting is the easiest way
to wrap old pointer-based APIs like this.
}

\Bnote{
The layout assumptions could still be false for an implementation
where the layout of "wrapper \tcode{struct}s" and the types they wrap is different,
but that concern is largely hypothetical.
}

However, LEWG found option 2 to be unconvincing because:
\ul{
  \li{
    That de-facto leaks the private \tcode{T*} data member in an \tcode{optional<T&>};
    why not just make it public?
  }
  \li{
    Specifying the layout of \tcode{optional<T&>} was arguably not within the scope
    of NB comment US 134-215.
  }
  \li{
    The change lacked motivation and lacked symmetry with the rest of the standard library.
  }
}

\h2{Wording}

The wording changes are relative to \ref(N5014).

Immediately following \eelis{optional.optional.ref.general#1},
append a paragraph as follows:

\Bins{
Each type \tcode{optional<T&>} is a trivially copyable class\iref{class.prop}.
}

\h2{Acknowledgements}

Thanks to Brian Bi for reviewing the flawed wording in R0 of this paper.

\h2{References}

\bib(
  id = N5014,
  title = Working Draft\, Programming Languages — C++,
  date = 2025-08-05,
  author = Thomas Köppe,
  link = https://wg21.link/n5014,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf,
)\
\bib(
  id = P2988R12,
  title = std::optional<T&>,
  date = 2025-04-04,
  author = Steve Downey\, Peter Sommerlad,
  link = https://wg21.link/p2988r12,
  long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r12.pdf,
)\

\make_bib
